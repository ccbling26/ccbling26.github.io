<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java 相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="http://example.com/2024/02/19/Java/index.html">
<meta property="og:site_name" content="随笔">
<meta property="og:description" content="Java 相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Java/valueOf.png">
<meta property="og:image" content="http://example.com/images/Java/String%20StringBuilder%20StringBuffer.png">
<meta property="og:image" content="http://example.com/images/Java/Serializable.png">
<meta property="og:image" content="http://example.com/images/Java/Collection.png">
<meta property="og:image" content="http://example.com/images/Java/Map.png">
<meta property="og:image" content="http://example.com/images/Java/%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png">
<meta property="og:image" content="http://example.com/images/Java/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png">
<meta property="og:image" content="http://example.com/images/Java/CAS.png">
<meta property="article:published_time" content="2024-02-19T07:35:13.000Z">
<meta property="article:modified_time" content="2024-02-19T07:38:58.414Z">
<meta property="article:author" content="Bling">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Java/valueOf.png">

<link rel="canonical" href="http://example.com/2024/02/19/Java/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java | 随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/19/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Bling">
      <meta itemprop="description" content="绳锯木断，水滴石穿">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随笔">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-19 15:35:13 / 修改时间：15:38:58" itemprop="dateCreated datePublished" datetime="2024-02-19T15:35:13+08:00">2024-02-19</time>
            </span>

          
            <div class="post-description">Java 相关知识</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Java-的三个体系"><a href="#Java-的三个体系" class="headerlink" title="Java 的三个体系"></a>Java 的三个体系</h2><p>Java SE（Java Platform Standard Edition，Java 平台标准版）</p>
<p>Java ME（Java Platform Micro Edition，Java 平台微型版）</p>
<p>Java EE（Java Platform Enterprise Edition，Java 平台企业版）</p>
<h2 id="Java-特点"><a href="#Java-特点" class="headerlink" title="Java 特点"></a>Java 特点</h2><p>面向对象：只支持类之间的单继承，但可以使用接口来实现多继承</p>
<p>平台无关：依靠 JVM 机制</p>
<p>解释执行：Java 程序（<code>*.java</code> 文件）会先被 Java 编译器编译成 Java 字节码文件（<code>*.class</code> 文件），然后在有 Java 环境的操作系统上解释执行</p>
<p>多线程：线程由 Thread 类及其子类创建。Java 运行多个线程同时执行，并提供多线程之间的同步机制</p>
<p>分布式：提供网络应用编程接口，包括 URL、URL Connection、Socket 等。提供 RIM 机制</p>
<p>健壮性：Java 的强类型机制、异常处理、垃圾回收机制等</p>
<p>高性能：主要是相对其他高级脚本语言来说的</p>
<p>安全性：提供了一个安全机制以防止恶意代码的攻击，对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以防替代本地的同名类，并包含安全管理机制。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>以大小写字母、美元符号 <code>$</code>、人民币符号 <code>¥</code>、下划线 <code>_</code> 开始</p>
<p>由大小写字母、美元符号、下划线、数字以及所有在十六进制 0xc0 前的 ASCII 码组成</p>
<p>不能与关键字、保留字（未来可能作为关键字使用）重名</p>
<p>大小写敏感</p>
<p>不能以单独的下划线 <code>_</code> 作为标识符</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释：<code>//</code></p>
<p>多行注释：<code>/* */</code></p>
<p>文档注释：<code>/** */</code></p>
<h2 id="常量-常量值"><a href="#常量-常量值" class="headerlink" title="常量 &amp; 常量值"></a>常量 &amp; 常量值</h2><p>常量是指在程序的整个运行过程中值保持不变的量</p>
<ul>
<li>使用 <code>final</code> 关键字定义，需要初始化，且不可以被修改</li>
<li>三种类型<ul>
<li>静态常量：在 <code>final</code> 之前使用 <code>public static</code> 修饰，作用域是全局的，不需要创建对象也可以访问</li>
<li>成员常量</li>
<li>局部常量</li>
</ul>
</li>
</ul>
<p>常量值又称字面常量，是通过数据直接表示的，有多种数据类型</p>
<ul>
<li>整型（<code>int</code>、<code>long</code>）、实型（<code>float</code>、<code>double</code>）、布尔型、字符型、字符串型、转义字符</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Java 是强类型语言，所有变量必须先声明，后使用，且指定类型的变量只能接受类型与之匹配的值</p>
<p>根据作用域的不同，变量分为成员变量和局部变量两类</p>
<ul>
<li>成员变量：定义在方法体和语句块之外，不属于任何一个方法，作用域是整个类<ul>
<li>全局变量（实例变量）：无 static 修饰，只要对象被当作引用，实例变量就将存在</li>
<li>静态变量（类变量）：用 static 修饰，其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁</li>
</ul>
</li>
<li>局部变量：指在方法或方法代码块中定义的变量，其作用域是其所在的代码块<ul>
<li>方法参数变量（形参）：在整个方法内有效</li>
<li>方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效</li>
<li>代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型</p>
<ul>
<li>字节型：byte，1 字节</li>
<li>短整型：short，2 字节</li>
<li>整型：int，4 字节</li>
<li>长整型：long，8 字节</li>
<li>单精度浮点型：float，4 字节</li>
<li>双精度浮点型：double，8 字节</li>
<li>字符型：char，2 字节</li>
<li>布尔型：bool，1 字节<ul>
<li>boolean 只有 true &#x2F; false 两个值，可以使用 1 bit 存储，但是具体大小没有明确规定</li>
<li>JVM 会在编译时将 boolean 类型的数据转换为 int，使用 1 &#x2F; 0 分别表示 true &#x2F; false</li>
<li>JVM 支持 boolean 数组，通过读写 byte 数组实现</li>
</ul>
</li>
</ul>
<p>引用数据类型</p>
<ul>
<li>类：class</li>
<li>接口：interface</li>
<li>数组：<code>[]</code></li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>隐式转换（自动类型转换）</p>
<ul>
<li>两种数据类型彼此兼容</li>
<li>目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）</li>
<li>数值型数据的转换：<code>byte</code> $\rightarrow$ <code>short</code> $\rightarrow$ <code>int</code> $\rightarrow$ <code>long</code> $\rightarrow$ <code>float</code> $\rightarrow$ <code>double</code></li>
<li>字符型转换为整型：<code>char</code> $\rightarrow$ <code>int</code></li>
</ul>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1</span>; <span class="comment">// 编译失败</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.1f</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>不能隐式地将高精度类型向下转型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">s1 = s1 + <span class="number">1</span>; <span class="comment">// 编译失败</span></span><br><span class="line">s1 += <span class="number">1</span>; <span class="comment">// true，等同 s1 = (short) (s1 + 1); 将 s1 + 1 的计算结果向下转型</span></span><br><span class="line">s1++; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>显式转换（强制类型转换）：<code>(type) variableName</code></p>
<ul>
<li>两种数据类型不兼容</li>
<li>目标类型的取值范围小于源类型</li>
</ul>
<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><h2 id="switch-case-语句"><a href="#switch-case-语句" class="headerlink" title="switch case 语句"></a>switch case 语句</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cond 为 byte、short、int、char 类型</span></span><br><span class="line"><span class="comment">// Java7 后 cond 允许为 String 类型，但不能是 StringBuffer 或 StringBuilder</span></span><br><span class="line"><span class="comment">// 不支持 long、float、double，因为其设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，应该使用 if 比较好</span></span><br><span class="line"><span class="comment">// case 为 byte、short、int、char 常量、枚举常量，不允许重复</span></span><br><span class="line"><span class="comment">// 如果在 case 分支语句的末尾没有 break 语句，有可能触发多个 case 分支</span></span><br><span class="line"><span class="comment">// Java7 后 case 允许为字符串字面量</span></span><br><span class="line"><span class="comment">// default 在所有 case 不满足时执行，与顺序无关，可以省略</span></span><br><span class="line"><span class="comment">// 所有 case 都不满足，且不存在 default 语句，则什么也不执行（不会阻塞）</span></span><br><span class="line"><span class="keyword">switch</span>(cond) &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> val2:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当编译一个 switch 语句时，Java 编译器将检查每个 case 常量并且创造一个跳转表，这个表将用来在表达式值的基础上选择执行路径。因此，如果需要在一组值中做出选择，switch 语句将比与之等效的 if-else 语句快得多。</p>
<h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><ul>
<li>在 switch 语句中终止一个语句序列</li>
<li>直接强行退出循环</li>
<li>实现 goto 的功能：在循环前加上一个标签，以冒号结束。使用 <code>break label</code> 结束指定的循环</li>
</ul>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><strong>字符串定义</strong></p>
<blockquote>
<p>字符串对象一旦创建，其值是不能改变的</p>
</blockquote>
<p>1、直接定义字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">String b;</span><br><span class="line">b = <span class="string">&quot;Hello world&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>2、使用 String 类定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个新创建的 String 对象，表示一个空字符序列</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="comment">// 初始化一个新创建的 String 对象，即创建一个副本，值相等，不是同一个对象。</span></span><br><span class="line"><span class="comment">// a == b; false</span></span><br><span class="line"><span class="comment">// a.equals(b); true</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(a);</span><br><span class="line"><span class="comment">// 分配一个新的字符串，将参数中的字符数组元素全部变为字符串</span></span><br><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(a);</span><br><span class="line"><span class="comment">// 分配一个新的 String，它包含来自该字符数组参数一个子数组的字符</span></span><br><span class="line"><span class="comment">// String(char[] value, int offset, int count)</span></span><br><span class="line"><span class="comment">// offset 参数是子数组第一个字符的索引，count 参数指定子数组的长度</span></span><br><span class="line"><span class="type">char</span> a[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(a, <span class="number">1</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>



<p><strong>字符串与整型相互转换</strong></p>
<p>String 转 int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">Integer.parseInt(a);</span><br><span class="line">Integer.valueOf(a).intValue();</span><br></pre></td></tr></table></figure>

<p>int 转 String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Integer.toString(i);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + i;</span><br></pre></td></tr></table></figure>



<p><strong>valueOf()</strong></p>
<p>一种静态方法，将数据的内部格式转换为可读的形式。</p>
<p>对于所有 Java 内置的类型，在字符串内被重载，以便每一种类型都能被转换成字符串</p>
<p>还被类型 Object 重载，所以创建的任何形式类的对象也可被用作一个参数</p>
<p><img src="/images/Java/valueOf.png" alt="valueOf"></p>
<p>Object to string</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="literal">null</span>) ? <span class="string">&quot;null&quot;</span> : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj.toString()，没有重写时会返回这个</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>去除字符串中前后的空格</strong></p>
<p><code>str.trim()</code></p>
<ul>
<li>只能去掉半角空格（英文空格），无法去掉全角空格（中文空格）（可以先使用替换函数再 <code>trim()</code>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将中文空格替换为英文空格，12288 是中文全角空格的 unicode 编码</span></span><br><span class="line">str = str.replace((<span class="type">char</span>) <span class="number">12288</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">str = str.trim();</span><br></pre></td></tr></table></figure>



<p><strong>字符串截取</strong></p>
<p><code>str.substring(int beginIdx, int endIdx)</code></p>
<p><strong>字符串分割</strong></p>
<p><code>str.split(String sign, int limit)</code></p>
<ul>
<li><p>sign：指定的分隔符，可以有对个，如 <code>and|or</code></p>
</li>
<li><p>limit：分割后生成的字符串的限制个数，不指定表示不限制</p>
</li>
</ul>
<p><strong>字符串替换</strong></p>
<p><code>str.replace(String oldStr, String newStr)</code>：将目标字符串中的指定字符（串）替换成新的字符（串）</p>
<p><code>str.replaceFirst(String regex, String replacement)</code>：将目标字符串中匹配某正则表达式的第一个子字符串替换成新的字符串</p>
<p><code>str.replaceAll(String regex, String replacement)</code>：将目标字符串中匹配某正则表达式的所有子字符串替换成新的字符串</p>
<p><strong>字符串比较</strong></p>
<p><code>a.equals(b)</code>：逐个比较两个字符串的每个字符是否相同。<code>==</code> 运算符比较两个对象引用看它们是否引用相同的实例</p>
<p><code>a.equalsIgnoreCase(b)</code>：不区分大小写逐个比较两个字符串的每个字符是否相同</p>
<p><code>str.compareTo(String other)</code>：按字典顺序（基于字符串各个字符的 Unicode 值）比较两个字符串的大小</p>
<p><strong>字符串查找</strong></p>
<p><code>str.indexOf(value, beginIdx, endIdx)</code>：返回字符（串）在指定字符串中首次出现的索引位置，如果能找到，则返回索引值，否则返回 -1</p>
<p><code>str.lastIndexOf(value, beginIdx)</code>：从右往左查找字符（串）在指定字符串中最后一次出现的索引位置，如果能找到则返回索引值，否则返回 -1。如果不指定起始索引，则默认从字符串的末尾开始查找。</p>
<p><code>str.charAt(idx)</code>：在字符串内根据指定的索引查找字符</p>
<h2 id="为什么-String-为不可变的"><a href="#为什么-String-为不可变的" class="headerlink" title="为什么 String 为不可变的"></a>为什么 String 为不可变的</h2><p>在 Java 8 中，String 内部使用 char 数组存储数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">  <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">  <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 中的 value 数组被声明为 final，在初始化后不能再引用其他数组，String 内部也没有改变 value 数组的方法，保证 String 不可变</p>
<p>String 设置为不可变有以下好处</p>
<ul>
<li><p>可以缓存 hash 值：计算得到的 hash 值不可变，只需要计算一次</p>
</li>
<li><p>String Pool 的需要：保证从 String Pool 中引用的内容不会发生变化</p>
</li>
<li><p>安全性：保证 String 类型的参数不可变，防止函数运行的实际效果与期望效果不一致</p>
</li>
<li><p>线程安全：由于 String 不可变，因此天生具备线程安全，可以在多线程中安全使用</p>
</li>
</ul>
<h2 id="StringBuffer-类"><a href="#StringBuffer-类" class="headerlink" title="StringBuffer 类"></a>StringBuffer 类</h2><blockquote>
<p>一个可变字符串类，创建 StringBuffer 类的对象后可以随意修改字符串的内容。每个 StringBuffer 类的对象都能存储指定容量的字符串，超过容量时会触发扩容机制</p>
</blockquote>
<p><strong>创建 StringBuffer 类</strong></p>
<p><code>StringBuffer()</code>：构造一个空的字符串缓冲区，并且初始化为 16 个字符的容量</p>
<p><code>StringBuffer(int length)</code>：创建一个空的字符串缓冲区，并且初始化为指定长度的容量</p>
<p><code>StringBuffer(String str)</code>：创建一个字符串缓冲区，并将其内容初始化为指定的字符串内容，字符串缓冲区的初始容量为 16 加上字符串的长度</p>
<p><strong>追加字符串</strong></p>
<p><code>obj.append(String str)</code>：追加内容到当前 StringBuffer 对象的末尾</p>
<p><strong>替换字符</strong></p>
<p><code>obj.setCharAt(int idx, char ch)</code>：在字符串的指定索引位置替换一个字符</p>
<p><strong>反转字符串</strong></p>
<p><code>obj.reverse()</code>：将字符串序列用其反转的形式取代</p>
<p><strong>删除字符串</strong></p>
<p><code>obj.deleteCharAt(int idx)</code>：用于移除序列中指定位置的字符</p>
<p><code>obj.delete(int beginIdx, int endIdx)</code>：用于移除序列中子字符串的字符</p>
<h2 id="String、StringBuffer-和-StringBuilder-的区别"><a href="#String、StringBuffer-和-StringBuilder-的区别" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别"></a>String、StringBuffer 和 StringBuilder 的区别</h2><img src="/images/Java/String StringBuilder StringBuffer.png" alt="String StringBuilder StringBuffer" style="zoom: 25%;" />

<ul>
<li>String 类是不可变类，StringBuffer 和 StringBuilder 是可变字符串类</li>
<li>StringBuffer 内部使用 <code>synchronized</code> 实现了线程安全功能，而 StringBuilder 没有</li>
<li>CharSequence 是一个定义字符串操作的接口，它只包括 <code>length()</code>、<code>charAt(int idx)</code>、<code>subSequence(int start, int end)</code> 这几个 API</li>
</ul>
<h2 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时确定</p>
<p>可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s2.intern();</span><br><span class="line">System.out.println(s3 == s4);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当一个字符串调用 intern() 时，如果 String Pool 中已经存在一个字符串和该字符串值相等，则会返回 String Pool 中字符串的引用；否则在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这种方式会自动将字符串放入 String Pool 中</p>
<p>在 Java 7 之前，String Pool 被放在<strong>运行时常量池</strong>中，属于<strong>永久代</strong>。而在 Java 7，String Pool 被移到<strong>堆</strong>中，因为永久代的空间有限，在大量使用字符串的场景下会导致 <strong>OutOfMemoryError</strong> 错误</p>
<h2 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h2><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量</li>
<li>使用 new 的方式会在堆中创建一个字符串对象</li>
</ul>
<p>从 String 构造源码可以看出，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.value = original.value;</span><br><span class="line">  <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java-正则表达式"><a href="#Java-正则表达式" class="headerlink" title="Java 正则表达式"></a>Java 正则表达式</h2><p>String 类里提供了如下几个特殊的方法</p>
<ul>
<li><code>boolean matches(String regex)</code>：判断该字符串是否匹配指定的正则表达式</li>
<li><code>String replaceAll(String regex, String replacement)</code>：替换该字符串中所有匹配的子串</li>
<li><code>String replaceFirst(String regex, String replacement)</code>：替换该字符串中第一个匹配的子串</li>
<li><code>String[] split(String regex)</code>：以 regex 作为分隔符，把该字符串分割成多个子串</li>
</ul>
<p>java.util.regex 还提供了 Pattern 和 Matcher 两个类专门用于提供正则表达式支持</p>
<ul>
<li>Pattern 对象是正则表达式编译后在内存中的表示形式，是不可变类，可供多个并发线程安全使用</li>
<li>Matcher 对象保留匹配所涉及的状态，多个 Matcher 对象可共享同一个 Pattern 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般调用顺序</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;a*b&quot;</span>);</span><br><span class="line"><span class="type">Matcher</span> <span class="variable">m</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;aaaab&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> m.matches(); <span class="comment">// 返回整个目标字符串与 Pattern 是否匹配</span></span><br><span class="line"><span class="comment">// 如果只使用一次</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> Pattern.matches(<span class="string">&quot;a*b&quot;</span>, <span class="string">&quot;aaaab&quot;</span>);</span><br><span class="line"><span class="comment">// 其他常用方法</span></span><br><span class="line">m.find(); <span class="comment">// 返回目标字符串中是否包含与 Pattern 匹配的子串</span></span><br><span class="line">m.group(); <span class="comment">// 返回上一次与 Pattern 匹配的子串</span></span><br><span class="line">m.start(); <span class="comment">// 返回上一次与 Pattern 匹配的子串在目标字符串中的开始位置</span></span><br><span class="line">m.end(); <span class="comment">// 返回上一次与 Pattern 匹配的子串在目标字符串中的结束位置 + 1</span></span><br><span class="line">m.lookingAt(); <span class="comment">// 返回目标字符串前面部分与 Pattern 是否匹配</span></span><br><span class="line"><span class="comment">// boolean res = Pattern.lookingAt(&quot;a*b&quot;, &quot;aaaabc&quot;); true</span></span><br><span class="line"><span class="comment">// boolean res = Pattern.matches(&quot;a*b&quot;, &quot;aaaabc&quot;); false</span></span><br><span class="line">m.reset(); <span class="comment">// 将现有的 Matcher 对象应用于一个新的字符序列。</span></span><br></pre></td></tr></table></figure>



<h1 id="数字和日期处理"><a href="#数字和日期处理" class="headerlink" title="数字和日期处理"></a>数字和日期处理</h1><p><strong>Math 类</strong></p>
<p>位于 java.lang 包，其构造方法是私有的，因此无法创建 Math 类对象</p>
<p>类中的所有方法都是类方法，可以直接通过类名调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态变量</span></span><br><span class="line">Math.E; <span class="comment">// 自然对数</span></span><br><span class="line">Math.PI; <span class="comment">// 圆周率</span></span><br><span class="line"><span class="comment">// 最大值、最小值、绝对值</span></span><br><span class="line">Math.max();</span><br><span class="line">Math.min();</span><br><span class="line">Math.abs();</span><br><span class="line"><span class="comment">// 求整运算</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> Math.ceil(<span class="type">double</span> a); <span class="comment">// 返回大于或等于 a 的最小整数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> Math.floor(<span class="type">double</span> a); <span class="comment">// 返回小于或等于 a 的最大整数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> Math.rint(<span class="type">double</span> a); <span class="comment">// 返回最接近 a 的整数值，如果有两个同样接近的整数，则结果取偶数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> Math.round(<span class="type">float</span> a); <span class="comment">// 将参数加上 1/2 后返回与参数最近的整数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">long</span> Math.round(<span class="type">double</span> a); <span class="comment">// 将参数加上 1/2 后返回与参数最近的整数，然后强制转换为长整型</span></span><br><span class="line"><span class="comment">// 三角函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sin</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回角的三角正弦值，参数以孤度为单位</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">cos</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回角的三角余弦值，参数以孤度为单位</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">asin</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回一个值的反正弦值，参数域在 [-1, 1]，值域在 [-PI/2, PI/2]</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">acos</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回一个值的反余弦值，参数域在 [-1, 1]，值域在 [0.0, PI]</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">tan</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回角的三角正切值，参数以弧度为单位</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">atan</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回一个值的反正切值，值域在 [-PI/2, PI/2]</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">toDegrees</span><span class="params">(<span class="type">double</span> angrad)</span>; <span class="comment">// 将用孤度表示的角转换为近似相等的用角度表示的角</span></span><br><span class="line">staticdouble <span class="title function_">toRadians</span><span class="params">(<span class="type">double</span> angdeg)</span>; <span class="comment">// 将用角度表示的角转换为近似相等的用弧度表示的角</span></span><br><span class="line"><span class="comment">// 指数运算</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">exp</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回 e 的 a 次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>; <span class="comment">// 返回以 a 为底数，以 b 为指数的幂值</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回 a 的平方根</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">cbrt</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回 a 的立方根</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回 a 的自然对数，即 lna 的值</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> a)</span>; <span class="comment">// 返回以 10 为底 a 的对数</span></span><br></pre></td></tr></table></figure>



<p><strong>随机数生成</strong></p>
<p>调用 java.util 包的 Random 类，有两种常见的构造方法</p>
<ul>
<li><p><code>Random()</code>：使用一个和当前系统时间对应的数字作为种子数，然后使用这个种子数构造 Random 对象</p>
<p><code>Random(long seed)</code>：使用单个 long 类型的参数创建一个新的随机数生成器</p>
</li>
</ul>
<p>调用 Math 类的 <code>random()</code> 方法，只能产生 <code>double</code> 类型的 <code>[0,1)</code> 的随机数</p>
<p><strong>数字格式化</strong></p>
<p>使用 DecimalFormat 类，是 NumberFormat 的一个子类，用于格式化十进制数字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0: 显示数字，如果位数不够则补 0</span></span><br><span class="line"><span class="comment">// #: 显示数字，如果位数不够不发生变化</span></span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;0.0&quot;</span>);</span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;#.#&quot;</span>);</span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;000.000&quot;</span>);</span><br><span class="line"><span class="type">DecimalFormat</span> <span class="variable">df4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecimalFormat</span>(<span class="string">&quot;###.###&quot;</span>);</span><br><span class="line">System.out.println(df1.format(<span class="number">5.0</span>)); <span class="comment">// 5.0</span></span><br><span class="line">System.out.println(df2.format(<span class="number">5.0</span>)); <span class="comment">// 5</span></span><br><span class="line">System.out.println(df2.format(<span class="number">5.1</span>)); <span class="comment">// 5.1</span></span><br><span class="line">System.out.println(df3.format(<span class="number">5.0</span>)); <span class="comment">// 005.000</span></span><br><span class="line">System.out.println(df4.format(<span class="number">5.0</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>



<p><strong>大数字运算</strong></p>
<p>java.math.BigInteger 类用于处理大整型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;12345&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>java.math.BigDecimal 类用于处理大小数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.2345&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">1.2345</span>);</span><br></pre></td></tr></table></figure>



<p><strong>时间日期处理</strong></p>
<p>java.util.Date 类：主要封装了系统的日期和时间的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 获取本地的当前时间</span></span><br><span class="line">System.out.println(date1); <span class="comment">// Mon Dec 11 21:44:44 CST 2023</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">60000</span>); <span class="comment">// 从 GMT 时间 1970年1月1日0时0分0秒开始经过参数 date 指定的毫秒数</span></span><br><span class="line">System.out.println(date2); <span class="comment">// Thu Jan 01 08:01:00 CST 1970</span></span><br></pre></td></tr></table></figure>

<p>java.util.Calendar 类：根据系统的日历来解释 Date 对象</p>
<p>不能使用 <code>new</code> 关键字创建 Calendar 对象，因为 Calendar 类是一个抽象类，但它提供了一个 <code>getInstance()</code> 方法来获得 Calendar类的对象</p>
<p><strong>日期格式化</strong></p>
<p>DateFormat 类：日期&#x2F;时间格式化子类的<strong>抽象类</strong>，它以与语言无关的方式格式化并解析日期或时间。在创建 DateFormat 对象时不能使用 <code>new</code> 关键字，而应该使用 DateFormat 类中的静态方法 <code>getDateInstance()</code></p>
<p>SimpleDateFormat 类：DateFormat 类的子类，一个以与语言环境有关的方式来格式化和解析日期的<strong>具体类</strong>，它允许进行格式化（日期→文本）、解析（文本→日期）和规范化。</p>
<h1 id="内置包装类"><a href="#内置包装类" class="headerlink" title="内置包装类"></a>内置包装类</h1><blockquote>
<p>将基本类型转换为对象进行处理</p>
</blockquote>
<p><strong>装箱和拆箱</strong></p>
<p>装箱：基本数据类型转换为包装类的过程</p>
<p>拆箱：包装类变为基本数据类型的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> m; <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj; <span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(m);  <span class="comment">// 手动装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obj.intValue();  <span class="comment">// 手动拆箱</span></span><br></pre></td></tr></table></figure>



<p><strong>Object 类</strong></p>
<p>Java 类库中的一个特殊类，是所有类的父类。Java 允许把任何类型的对象赋给 Object 类型的变量。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是 Object 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;...&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Number 类</strong></p>
<p>一个抽象类，也是一个超类（即父类）</p>
<p>Byte、Short、Integer、Long、Float、Double 类都是 Number 类的子类</p>
<p><strong>System 类</strong></p>
<p>代表当前 Java 程序的运行平台，包含系统级的很多属性和控制方法</p>
<p>构造方法是私有的，因此无法对其进行实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line">PrintStream out; <span class="comment">//标准输出流</span></span><br><span class="line">InputStream in; <span class="comment">// 标准输入流</span></span><br><span class="line">PrintStream err; <span class="comment">// 标准的错误输出流</span></span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line">arraycopy(); <span class="comment">// 复制数组</span></span><br><span class="line">currentTimeMills(); <span class="comment">// 返回当前的计算机时间</span></span><br><span class="line">exit(); <span class="comment">// 终止当前正在运行的 Java 虚拟机。status 为 0 时表示正常退出</span></span><br><span class="line">gc(); <span class="comment">// 请求系统进行垃圾回收</span></span><br><span class="line">getProperty(); <span class="comment">// 获得系统中指定属性对应的值</span></span><br></pre></td></tr></table></figure>



<h1 id="错误-异常"><a href="#错误-异常" class="headerlink" title="错误 &amp; 异常"></a>错误 &amp; 异常</h1><p>Java 把异常当作对象来处理，并定义一个基类 <code>java.lang.Throwable</code> 作为所有异常的超类</p>
<p>在 Java API 中已经定义了许多异常类，可以分为两类</p>
<ul>
<li>错误 Error：用来表示 JVM 无法处理的错误</li>
<li>异常 Exception<ul>
<li>受检异常：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复</li>
<li>非受检异常：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复</li>
</ul>
</li>
</ul>
<p><img src="/images/Java/Serializable.png" alt="Serializable"></p>
<p>Throwable 可以用来表示任何可以作为异常抛出的类</p>
<p><strong>异常处理的关键字</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>, <span class="keyword">catch</span>, <span class="keyword">finally</span>, <span class="keyword">throw</span>, <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>



<h1 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 Annotation"></a>注解 Annotation</h1><p>JDK 5.0 引入，不是程序本身，可以对程序作出解释，也可以被其他程序（如编译器等）读取</p>
<p>以 <code>@注释名</code> 格式在代码中存在，可以添加一些参数值，如 <code>@SuppressWarnings(value=&quot;unchecked&quot;)</code></p>
<p>可以附加在 package、class、method、filed 等上面，相当于给它们添加了额外的辅助信息，可以通过反射机制编程实现对这些元数据的访问</p>
<p><strong>内置注解</strong></p>
<p><code>@Override</code>：定义在 <code>java.lang.Override</code> 中，此注释只用于修饰方法，表示一个方法声明打算重写超类中的另一个方法声明</p>
<p><code>@Deprecated</code>：定义在 <code>java.lang.Deprecated</code> 中，此注释可以用于修饰方法、属性、类，表示不鼓励程序员使用这样的元素，通常是因为它存在缺陷或存在更好的选择</p>
<p><code>@SuppressWarnings</code>：定义在 <code>java.lang.SuppressWarnings</code> 中，用来抑制编译时的警告信息，需要添加一个定义好的参数</p>
<p><strong>元注解</strong></p>
<p>负责注解其它注解，Java 定义了 4 个标准的 meta-annotation 类型，在 <code>java.lang.annotation</code> 包中可以找到</p>
<p><code>@Target</code>：描述注解的使用范围</p>
<p><code>@Retention</code>：描述注解的生命周期，表示需要在什么级别保存该注释信息（SOURCE &lt; CLASS &lt; RUNTIME）</p>
<p><code>@Documented</code>：说明该注解需要被包含在 javadoc 中</p>
<p><code>@Inherited</code>：说明子类可以继承父类中的该注解</p>
<p><strong>自定义注解</strong></p>
<p>使用 <code>@interface</code> 自定义注解，自动继承了 <code>java.lang.annotation.Annotation</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">// 注解的参数: 参数类型 + 参数名称();</span></span><br><span class="line">    String[] value();</span><br><span class="line">    <span class="comment">// defualt 声明参数的默认值</span></span><br><span class="line">    String name <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射 Reflection"></a>反射 Reflection</h1><p>反射是 Java 被视为动态语言的关键，反射机制允许程序在执行期间借助与反射 API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p>
<p>在加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象（一个类只有一个 Class 对象，hashCode 一样），一个类被加载后，类的整个结构都会被封装在 class 对象中（接口、父类、构造器、方法、Field、注解）</p>
<p>利用反射，可以实现动态创建对象和编译，体现很大的灵活性，但也对性能有一定的影响</p>
<p><strong>静态语言 vs. 动态语言</strong></p>
<p>动态语言：在代码执行过程中，可以根据某些条件改变自身结构。主要的动态语言有：JavaScript、Python、PHP 等</p>
<p>静态语言：运行时结构不可变的语言，如 C、C++、Java（不是动态语言，可以称为准动态语言，有一定的动态性，利用反射机制获得类似动态语言的特性）</p>
<p><strong>Java 反射机制提供的功能</strong></p>
<p>在运行时判断任意一个对象所属的类</p>
<p>在运行时构造任意一个类的对象</p>
<p>在运行时判断任意一个类所具有的成员变量和方法</p>
<p>在运行时获取泛型信息</p>
<p>在运行时调用任意一个对象的成员变量和方法</p>
<p>在运行时处理注解</p>
<p>生成动态代理</p>
<p><strong>Class 类</strong></p>
<p>Class 本身也是一个类</p>
<p>Class 对象只能由系统建立对象</p>
<p>一个加载的类在 JVM 中只会有一个 Class 实例</p>
<p>一个 Class 对象对应的是一个加载到 JVM 中的一个 <code>.class</code> 文件</p>
<p>每个类的实例都会记得自己是由哪个 Class 实例所生成</p>
<p>通过 Class 可以完整地得到一个类中的所有被加载的结构</p>
<p>Class 类是 Reflection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class 对象</p>
<p><strong>获取 Class 类的实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若已知具体的类，通过类的 class 属性获取。该方法最为安全可靠，程序性能最高</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> MyClass.class;</span><br><span class="line"><span class="comment">// 已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> obj.getClass();</span><br><span class="line"><span class="comment">// 已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName() 获取，可能会抛出 ClassNotFoundException 异常</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>);</span><br><span class="line"><span class="comment">// 内置基本数据类型可以直接用类名.Type</span></span><br><span class="line"><span class="comment">// 用 ClassLoader</span></span><br></pre></td></tr></table></figure>



<p><strong>可以有 Class 对象的类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class; <span class="comment">// 外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class; <span class="comment">// 接口</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class; <span class="comment">// 一维数组</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class; <span class="comment">// 二维数组</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> Override.class; <span class="comment">// 注解</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> ElementType.class; <span class="comment">// 枚举</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c7</span> <span class="operator">=</span> Integer.class; <span class="comment">// 基本数据类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class; <span class="comment">// void</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class; <span class="comment">// Class</span></span><br></pre></td></tr></table></figure>



<p><strong>类的加载</strong></p>
<p>加载：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入口</p>
<p>链接：将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程</p>
<ul>
<li>验证：确保加载的类信息符合 JVM 规范，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li>
</ul>
<p>初始化</p>
<ul>
<li>执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。类构造器 <code>&lt;clinit&gt;()</code> 方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li>
<li>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确加锁和同步</li>
</ul>
<p><strong>类初始化触发</strong></p>
<p>类的主动引用（一定会发生类的初始化）</p>
<ul>
<li>当虚拟机启动，先初始化 main 方法所在的类</li>
<li>new 一个类的对象</li>
<li>调用类的静态成员（除了 final 常量）和静态方法</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>
</ul>
<p>类的被动引用（不会发生类的初始化）</p>
<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
</ul>
<p><strong>类加载器</strong></p>
<p>JVM 规范定义了如下类型的类加载器（自顶向下尝试加载类，自底向上检查类是否已装载）</p>
<ul>
<li>引导类加载器（Bootstap ClassLoader）：C++ 编写的，是 JVM 自带的类加载器，负责 Java 平台核心库，用来装载核心类库，该加载器无法直接获取</li>
<li>扩展类加载器（Extension ClassLoader）：负责 jre&#x2F;lib&#x2F;ext 目录下的 jar 包或-D java.ext.dirs 指定目录下的 jar 包装入工作库</li>
<li>系统类加载器（System ClassLoader）：负责 java -classpath 或 -D java.class.path 所指的目录下的类与 jar 包装入工作库，是最常用的加载器</li>
<li>自定义类加载器</li>
</ul>
<p><strong>反射动态创建&amp;操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;User&quot;</span>);</span><br><span class="line"><span class="comment">// 通过 getInstance() 构造一个对象，本质上是调用了无参构造器</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> c1.getInterfaces();</span><br><span class="line"><span class="comment">// 通过构造器构建对象</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> c1.getDeclaredConstructor(Integer.class, String.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> constructor.newInstance(<span class="number">1</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"><span class="comment">// 通过反射调用普通方法</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">setName</span> <span class="operator">=</span> c1.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"><span class="comment">// invoke：激活的意思。(对象，&quot;方法的值&quot;)</span></span><br><span class="line">setName.invoke(user2, <span class="string">&quot;Jason&quot;</span>);</span><br><span class="line"><span class="comment">// 通过反射操作属性，不能直接操作私有属性</span></span><br><span class="line"><span class="type">Filed</span> <span class="variable">name</span> <span class="operator">=</span> c1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 取消安全检测，不实施 Java 语言的访问检查</span></span><br><span class="line">name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">name.set(user2, <span class="string">&quot;Michael&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><strong>反射操作泛型</strong></p>
<p>Java 采用泛型擦除的机制来引入泛型，Java 中的泛型仅仅是给编译器 javac 使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除<br>为了通过反射操作这些类型，Java 新增了 <code>ParameterizedType</code>、<code>GenericArrayType</code>、<code>TypeVariable</code> 和 <code>WildcardType</code> 几种类型来代表不能被归一到 Class 类中的类型但是又和原始类型齐名的类</p>
<ul>
<li><code>ParameterizedType</code>：表示一种参数化类型，比如 <code>Collection&lt;String&gt;</code></li>
<li><code>GenericArrayType</code>：表示一种元素类型是参数化类型或者类型变量的数组类型</li>
<li><code>TypeVariable</code>：是各种类型变量的公共父接口</li>
<li><code>WildcardType</code>：代表一种通配符类型表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">(Map&lt;String, User&gt; map, List&lt;User&gt; list)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test01&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, User&gt; <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test02&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Main.class.getMethod(<span class="string">&quot;test01&quot;</span>, Map.class, List.class);</span><br><span class="line">        <span class="comment">// 获取泛型参数信息</span></span><br><span class="line">        Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">        <span class="keyword">for</span> (Type genericParameterType : genericParameterTypes) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;#&quot;</span> + genericParameterType);</span><br><span class="line">            <span class="comment">// 判断是否为参数化类型，如果是进行强转，获得真实参数类型</span></span><br><span class="line">            <span class="keyword">if</span> (genericParameterType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                Type[] artualTypeArguments = ((ParameterizedType) genericParameterType).getActualTypeArguments();</span><br><span class="line">                <span class="keyword">for</span> (Type artualTypeArgument : artualTypeArguments) &#123;</span><br><span class="line">                    System.out.println(artualTypeArgument);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取方法</span></span><br><span class="line">        method = Main.class.getMethod(<span class="string">&quot;test02&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 获取泛型返回的信息</span></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericReturnType</span> <span class="operator">=</span> method.getGenericReturnType();</span><br><span class="line">        <span class="comment">// 判断是否为参数化类型，如果是进行强转，获得真实参数类型</span></span><br><span class="line">        <span class="keyword">if</span> (genericReturnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">            Type[] artualTypeArguments = ((ParameterizedType) genericReturnType).getActualTypeArguments();</span><br><span class="line">            <span class="keyword">for</span> (Type artualTypeArgument : artualTypeArguments) &#123;</span><br><span class="line">                System.out.println(artualTypeArgument);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>反射操作注解</strong></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.FILED)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyFiledAnnotation &#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">type</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 通过反射获取注解</span></span><br><span class="line">Annotation[] annotations = c1.getAnnotations();</span><br><span class="line"><span class="keyword">for</span> (Annotation annotation: annotations) &#123;</span><br><span class="line">    System.out.println(annotation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取注解的 value 的值</span></span><br><span class="line"><span class="type">MyAnnotation</span> <span class="variable">myAnnotation</span> <span class="operator">=</span> (MyAnnotation)c1.getAnnotation(MyAnnotation.class);</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> myAnnotation.value();</span><br><span class="line">System.out.println(value);</span><br><span class="line"><span class="comment">// 获取类指定的注解</span></span><br><span class="line"><span class="type">Filed</span> <span class="variable">f</span> <span class="operator">=</span> c1.getDeclaredFiled(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">MyFiledAnnotation</span> <span class="variable">myFiledAnnotation</span> <span class="operator">=</span> f.getAnnotation(MyFiledAnnotation.class);</span><br><span class="line">System.out.println(myFiledAnnotation.columnName());</span><br><span class="line">System.out.println(myFiledAnnotation.type());</span><br><span class="line">System.out.println(myFiledAnnotation.length());</span><br></pre></td></tr></table></figure>





<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p><strong>线程创建</strong></p>
<p>1、继承 Thread 类</p>
<p>不建议使用，避免 OOP 单继承局限性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建线程对象，调用 start 方法启动线程，等待 CPU 调度（不一定立即执行）</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、继承 Thread 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 2、重写 run 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、实现 Runnable 接口</p>
<p>推荐使用，避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、创建 Runnable 接口的实现类对象</span></span><br><span class="line">        <span class="type">MyRunnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">// 4、创建线程对象代理开启线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、实现 Runnable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 2、重写 run 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、实现 Callable 接口</p>
<p>可以a返回值，可以抛出异常 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3、 创建 Callable 接口的实现类对象</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        <span class="comment">// 4、创建执行任务</span></span><br><span class="line">        FutureTask&lt;Boolean&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Boolean&gt;(c);</span><br><span class="line">        <span class="comment">// 5、获取结果</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">res</span> <span class="operator">=</span> task.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、实现 Callable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Boolean&gt; &#123;</span><br><span class="line">    <span class="comment">// 2、重写 call 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>静态代理模式</strong></p>
<p>要求</p>
<p>1、真实对象和代理对象需要实现同一个接口</p>
<p>2、代理对象需要代理真实对象</p>
<p>好处</p>
<p>1、代理对象可以实现真实对象做不了的事情</p>
<p>2、真实对象只需要专注做自己的事情</p>
<p><strong>函数式接口</strong></p>
<p>只包含唯一一个抽象方法的接口</p>
<p><strong>线程方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span>; <span class="comment">// 更改线程优先级</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span>; <span class="comment">// 在指定的毫秒数内让当前正在执行的线程休眠</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span>; <span class="comment">// 合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>; <span class="comment">// 暂停当前正在执行的线程对象，CPU 重新调度线程执行</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span>; <span class="comment">// 中断线程（不推荐使用）</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>; <span class="comment">// 测试线程是否处于活动状态</span></span><br></pre></td></tr></table></figure>



<p><strong>守护（daemon）线程</strong></p>
<p>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></p>
<p>虚拟机必须确保用户线程执行完毕，不用等待守护线程执行完毕（如后台 log 记录，内存监控，gc 等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>));</span><br><span class="line">thread.setDaemon(<span class="literal">true</span>); <span class="comment">// 默认是 false，表示是用户线程</span></span><br></pre></td></tr></table></figure>



<p><strong>线程同步</strong></p>
<p>由于同一进程的多个线程共享同一块存储空间，在并发情况下可能引发冲突问题，为了保证数据在方法中被访问时的正确性，引入锁机制，当一个线程获得对象的排他锁，独占资源，其他线程必须等待，直到锁的释放</p>
<p> 可能存在以下问题：</p>
<p>1、一个线程持有锁会导致其他所有需要此锁的线程挂起</p>
<p>2、在多线程竞争下，锁的添加和释放会导致比较多的上下文切换和调度延时，引起性能问题</p>
<p>3、如果一个优先级高的线程等待优先级低的线程释放锁，会导致优先级倒置，引起性能问题</p>
<p>1、synchronized 关键字</p>
<p>两种用法</p>
<ul>
<li>synchronized 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">methd</span><span class="params">(<span class="type">int</span> args)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>控制对对象的访问，每个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞</p>
<p>缺陷：若将一个大的方法申明为 synchronized 将会影响效率</p>
<ul>
<li>synchronized 块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;&#125;</span><br><span class="line"><span class="comment">// obj 称为同步监视器</span></span><br><span class="line"><span class="comment">// 可以是任何对象，但是推荐使用共享资源作为同步监视器</span></span><br><span class="line"><span class="comment">// 在 synchronized 方法中，同步监视器就是 this（对象本身或 class）</span></span><br></pre></td></tr></table></figure>

<p>2、Lock（锁）</p>
<p>从 JDK 5.0 开始提供的更强大的线程同步机制，显式定义同步锁对象</p>
<p>每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前先获得 Lock 对象</p>
<p>ReentrantLock（可重入锁）类实现了 Lock，拥有与 synchronized 相同的并发性和内存语义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">// 代码</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3、synchronized 关键字 vs. Lock</p>
<table>
<thead>
<tr>
<th>synchronized</th>
<th>Lock</th>
</tr>
</thead>
<tbody><tr>
<td>隐式锁，出了作用域自动释放</td>
<td>显式锁，需要手动开启和关闭锁</td>
</tr>
<tr>
<td>有代码块锁和方法锁</td>
<td>只有代码块锁</td>
</tr>
<tr>
<td>使用不当可能会性能差</td>
<td>性能更好，扩展性强</td>
</tr>
</tbody></table>
<p>优先使用顺序：Lock &gt; 同步代码块 &gt; 同步方法</p>
<p><strong>线程通信</strong></p>
<p>Java Object 类提供以下方法解决线程之间的通信问题</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>wait()</td>
<td>表示线程一直等待，直到其他线程通知。与 sleep 不同，会释放锁</td>
</tr>
<tr>
<td>wait(long timeout)</td>
<td>指定等待的毫秒数</td>
</tr>
<tr>
<td>notify()</td>
<td>唤醒一个处于等待状态的线程</td>
</tr>
<tr>
<td>notifyAll()</td>
<td>唤醒同一个对象上所有调用 wait() 方法的线程，优先级别高的线程优先调度</td>
</tr>
</tbody></table>
<p>都只能在同步方法或同步代码块中使用，否则会抛出异常 <code>illegalMonitorStateException</code></p>
<p><strong>线程池</strong></p>
<p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中</p>
<p>好处</p>
<p>1、提高响应速度（减少创建新线程的时间）</p>
<p>2、降低资源消耗（重复利用线程池中的线程，不需要每次都创建）</p>
<p>3、便于线程管理</p>
<ul>
<li><code>corePoolSize</code>：核心池的大小</li>
<li><code>maximumPoolSize</code>：最大线程数</li>
<li><code>keepAliveTime</code>：线程没有任务时最多保持多久时间后终止</li>
</ul>
<p>JDK 5.0 起提供了线程池相关 API：<code>ExecutorService</code> 和 <code>Executors</code></p>
<ul>
<li>ExecutorService：真正线程池接口，常见子类 ThreadPoolExecutor<ul>
<li><code>void execute(Runnable command)</code>：执行任务&#x2F;命令，没有返回值，一般用来执行 Runnable</li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务，有返回值，一般用来执行 Callable</li>
<li><code>void shutdown()</code>：关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</li>
</ul>
<h1 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h1><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成</p>
<h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><ul>
<li>装箱：自动将基本数据类型转换为包装类类型</li>
<li>拆箱：自动将包装类类型转换为基本数据类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// 装箱，调用 Integer 的 valueOf 方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;  <span class="comment">// 拆箱，调用 Integer 的 intValue 方法</span></span><br></pre></td></tr></table></figure>



<h1 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h1><p><code>new Integer(123)</code> 和 <code>Integer.valueOf(123)</code> 的区别在于：</p>
<ul>
<li><code>new Integer(123)</code> 每次都会创建一个对象</li>
<li><code>Integer.valueOf(123)</code> 会使用缓存池中的对象，多次调用会取得同一个对象的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">p</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">q</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(p == q); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="valueOf-的实现"><a href="#valueOf-的实现" class="headerlink" title="valueOf 的实现"></a>valueOf 的实现</h2><p>先判断值是否在缓存池中，如果在则直接返回缓存池的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 8 中，Integer 缓存池的大小默认为 <code>-128～127</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span> sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基本类型对应的缓存池"><a href="#基本类型对应的缓存池" class="headerlink" title="基本类型对应的缓存池"></a>基本类型对应的缓存池</h2><ul>
<li>boolean - true and false</li>
<li>byte - all</li>
<li>short - <code>-128~127</code></li>
<li>int - <code>-128~127</code></li>
<li>char - <code>\u0000~\u007F</code></li>
</ul>
<blockquote>
<p>Integer 的缓存池 IntegerCache 比较特殊，其上界是可调的。在启动 JVM 时，通过 <code>-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来指定缓存池的大小，该选项在 JVM 初始化时会设定一个名为 <code>java.lang.IntegerCache.high</code> 系统属性，然后 IntegerCache 初始化时会读取该系统属性决定上界 </p>
</blockquote>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递</p>
<h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><ul>
<li><p>声明数据为常量</p>
<ul>
<li>编译时常量</li>
<li>在运行时被初始化后不能被改变的常量。</li>
</ul>
</li>
<li><p>对于基本类型，final 使数值不变；</p>
</li>
<li><p>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">x += <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Obj</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Obj</span>();</span><br><span class="line">obj.val += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>声明方法不能被子类重写。</li>
<li>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>声明类不允许被继承</li>
</ul>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><ul>
<li>静态变量：又称为类变量，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份</li>
<li>实例变量：每创建一个实例就会产生一个实例变量</li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul>
<li>在类加载时就存在，不依赖于任何实例。所以静态方法必须有实现，不能是抽象方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> y; <span class="comment">// error</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="built_in">this</span>.y; <span class="comment">// error</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态语句块"><a href="#静态语句块" class="headerlink" title="静态语句块"></a>静态语句块</h2><ul>
<li>在类初始化时运行一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Obj</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ul>
<li><p>非静态内部类依赖于外部类的实例，也就是需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要</p>
</li>
<li><p>静态内部类不能访问外部类的非静态的变量和方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>(); <span class="comment">// error</span></span><br><span class="line">    <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">    <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">    <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h2><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><ul>
<li><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。最后才是构造函数的初始化。</p>
</li>
<li><p>存在继承的情况下，初始化顺序为</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
</li>
</ul>
<h1 id="Object-通用方法"><a href="#Object-通用方法" class="headerlink" title="Object 通用方法"></a>Object 通用方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><h3 id="等价关系"><a href="#等价关系" class="headerlink" title="等价关系"></a>等价关系</h3><p>两个对象具有等价关系，需要满足</p>
<ul>
<li>自反性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对称性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>传递性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z)) </span><br><span class="line">  x.equals(z); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一致性：多次调用 <code>equals()</code> 方法结果不变</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>与 null 的比较：对任何不是 null 的对象 x 调用 <code>x.equals(null)</code> 结果都为 false</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(<span class="literal">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<h3 id="等价与相等"><a href="#等价与相等" class="headerlink" title="等价与相等"></a>等价与相等</h3><ul>
<li>对于基本类型，&#x3D;&#x3D; 判断两个值是否相等，基本类型没有 equals() 方法</li>
<li>对于引用类型，&#x3D;&#x3D; 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x == y); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EqualExample</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> z;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">EqualExample</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">    <span class="built_in">this</span>.z = z;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否为同一个对象的引用，如果是直接返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 检查是否是同一个类型，如果不是，直接返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将 Object 对象进行转型</span></span><br><span class="line">    <span class="type">EqualExample</span> <span class="variable">that</span> <span class="operator">=</span> (EqualExample) o;</span><br><span class="line">    <span class="comment">// 判断每个关键域是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (x != that.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (y != that.y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> z == that.z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><ul>
<li>返回哈希值</li>
<li>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等</li>
<li>HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置</li>
</ul>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><p>默认返回 <code>类名@散列码的无符号十六进制表示</code>，如 <code>org.example.ToStringExample@7be30</code></p>
<h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><ul>
<li><p>cloneable</p>
<ul>
<li><p>clone() 是 Object 的 protected 方法，不是 public，一个类不显式去重写 clone()，其它类就不能直接调用该类实例的 clone() 方法</p>
</li>
<li><p><code>clone()</code> 方法并不是 <code>Cloneable</code> 接口的方法，而是 <code>Object</code> 的一个 <code>protected</code> 方法。<code>Cloneable</code> 接口只是规定，如果一个类没有实现 <code>Cloneable</code> 接口又调用了 <code>clone()</code> 方法，就会抛出 <code>CloneNotSupportedException</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneExample</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CloneExample <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (CloneExample) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>浅拷贝</p>
<ul>
<li>拷贝对象和原始对象的引用类型引用同一个对象</li>
</ul>
</li>
<li><p>深拷贝</p>
<ul>
<li>拷贝对象和原始对象的引用类型引用不同对象</li>
</ul>
</li>
<li><p>clone() 的替代方案</p>
<ul>
<li>使用拷贝构造函数或者拷贝工厂来拷贝一个对象</li>
</ul>
</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见</p>
<p>类可见：表示其它类可以用这个类创建实例对象</p>
<p>成员可见：表示其它类可以用这个类的实例对象访问到该成员</p>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义</p>
<p>子类的方法重写了父类的方法时，子类的方法的访问级别不允许低于父类的访问级别。以确保可以使用父类实例的地方都可以使用子类实例去代替（确保满足里氏替换原则）</p>
<h2 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h2><ul>
<li>抽象类<ul>
<li>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类</li>
<li>抽象类和普通类最大的区别是：抽象类不能被实例化，只能被继承</li>
</ul>
</li>
<li>接口<ul>
<li>接口是抽象类的延伸</li>
<li>在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现</li>
<li>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。</li>
<li>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。</li>
<li>接口的字段默认都是 static 和 final 的</li>
</ul>
</li>
<li>比较<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限</li>
</ul>
</li>
<li>使用<ul>
<li>接口<ul>
<li>需要让不相关的类都实现一个方法</li>
<li>需要使用多重继承</li>
</ul>
</li>
<li>抽象类<ul>
<li>需要在几个相关的类中共享代码</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public</li>
<li>需要继承非静态和非常量字段</li>
</ul>
</li>
<li>建议<ul>
<li>接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现</li>
</ul>
<h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><ul>
<li><p>重写 Override</p>
<ul>
<li>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法</li>
<li>为了满足里式替换原则，重写有以下三个限制：<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li>
</ul>
</li>
<li>使用 <code>@Override</code> 注解，可以让编译器帮忙检查是否满足上面的三个限制条件</li>
<li>在调用一个方法时，先<strong>从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来</strong>。否则就要<strong>对参数进行转型，转成父类之后看是否有对应的方法</strong>。方法调用的优先级为：<ul>
<li>this.func(this)</li>
<li>super.func(this)</li>
<li>this.func(super)</li>
<li>super.func(super)</li>
</ul>
</li>
</ul>
</li>
<li><p>重载 Overload</p>
<ul>
<li>存在于同一个类中，指一个方法与已经存在的方法<strong>名称上相同</strong>，但是<strong>参数类型、个数、顺序至少有一个不同</strong></li>
<li>返回值不同，其它都相同不算是重载。</li>
</ul>
</li>
</ul>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ul>
<li><p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 <code>.class</code> 文件，保存着 Class 对象</p>
</li>
<li><p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 方式控制类的加载，该方法会返回一个 Class 对象</p>
</li>
<li><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来</p>
</li>
<li><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li>Field：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段</li>
<li>Method：可以使用 invoke() 方法调用与 Method 对象关联的方法</li>
<li>Constructor：可以用 Constructor 的 newInstance() 创建新的对象</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><strong>可扩展性</strong>：应用程序可以利用全限定名（包名+类型）创建可扩展对象的实例，来使用来自外部的用户自定义类</li>
<li>类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</li>
<li>调试器和测试工具：调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</li>
</ul>
</li>
<li><p>缺点（能不用则不用）</p>
<ul>
<li><strong>性能开销</strong> ：反射涉及了<strong>动态类型的解析</strong>，所以 JVM <strong>无法优化</strong>这些代码。应该避免在<strong>经常被执行的代码</strong>或<strong>对性能要求很高的程序</strong>中使用反射</li>
<li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个<strong>没有安全限制</strong>的环境中运行</li>
<li><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</li>
</ul>
</li>
</ul>
<h1 id="Wait-Notify-机制"><a href="#Wait-Notify-机制" class="headerlink" title="Wait &#x2F; Notify 机制"></a>Wait &#x2F; Notify 机制</h1><p>所谓通信就是指相互交换一些数据或者发送一些控制指令</p>
<p>可变共享变量是天然的通信媒介</p>
<p>由于原子性操作、内存可见性和指令重排序的存在，java 提供了 volatile 和 synchronized 的同步手段来保证通信内容的正确性</p>
<p>java 规定每一个锁对应一个等待队列，如果一个线程在获得锁之后发现某些条件不满足，应该主动让出锁，并将线程添加到这个锁对应的等待队列里。另一个线程在完成对应条件时需要获取同一个锁，在条件完成后通知它获取的锁对应的等待队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线程获取到锁后，调用锁对象的本方法，线程释放锁并且把该线程放置到与锁对象关联的等待队列（等待线程池）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">// 与 wait() 方法相似，只不过等待指定的毫秒数，如果超过指定时间则自动把该线程从等待队列中移出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">// 与上述方法一样，只不过超时时间粒度更小，即指定的毫秒数+纳秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">// 唤醒一个在与该锁对象关联的等待队列的线程，一次唤醒一个，而且是任意的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 将等待队列中的所有线程都唤醒</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>所谓唤醒的意思就是让等待队列中的线程具备执行资格，这些方法都是在同步中才有效，同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程</p>
<p>notify() 或者 notifyAll() 调用时并不会真正释放对象锁，必须等到 synchronized 方法或者语法块执行完才真正释放锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">([]String args)</span> &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    obj.notifyAll();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然调用了 notifyAll，但是紧接着进入了一个死循环，会导致一直无法退出临界区，不能释放对象锁，因此即使把所有在等待池中的线程都唤醒放到了对象的锁池中，但是锁池中的所有线程都不会运行，因为它们始终拿不到锁</p>
<p>其他：<a target="_blank" rel="noopener" href="https://blog.csdn.net/AttleeTao/article/details/110133661">https://blog.csdn.net/AttleeTao/article/details/110133661</a></p>
<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p> <img src="/images/Java/Collection.png" alt="Collection"></p>
<ul>
<li>Set<ul>
<li>TreeSet：基于红黑树实现，支持有序性操作</li>
<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作</li>
<li>LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序</li>
</ul>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul>
<li><p>基于动态数组实现，支持快速随机访问（RandomAccess 接口）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认大小为 10</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容</p>
<ul>
<li><p>添加元素时使用 <code>ensureCapacityInternal()</code> 方法来保证容量足够，如果不够时，需要使用 <code>grow()</code> 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即约为原来的 1.5 倍左右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高</p>
</li>
</ul>
</li>
<li><p>删除：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，时间复杂度 $O(N)$</p>
</li>
<li><p>序列化</p>
<ul>
<li><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化</p>
</li>
<li><p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容</p>
</li>
<li><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">oos.writeObject(list);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Fail-Fast</p>
<ul>
<li>modCount 用来记录 ArrayList 结构发生变化的次数（添删元素、调整内部数组的大小，设置元素的值不算）</li>
<li>在进行序列化或者迭代等操作时，如果 modCount 发生改变，则需要抛出 ConcurrentModificationException</li>
</ul>
</li>
</ul>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul>
<li>和 ArrayList 类似，但它是线程安全的（使用 synchronized）</li>
<li>扩容：Vector 的构造函数可以传入 capacityIncrement 参数用于扩容。如果参数值 &lt;&#x3D; 0，则容量扩大为原来的两倍</li>
<li>替代方案<ul>
<li>使用 <code>Collections.synchronizedList()</code> 得到一个线程安全的 ArrayList</li>
<li>使用 concurrent 并发包下的 CopyOnWriteArrayList 类<ul>
<li>实现了读写分离，即在写操作时复制出一个数组并在这个数组上进行，需要加锁防止并发写导致的数据丢失；读操作还是在原来的数组上进行。写操作结束之后需要把原始数组指向新的复制数组</li>
<li>很适合读多写少的应用场景</li>
<li>不适合内存敏感以及对实时性要求很高的场景<ul>
<li>内存占用为原来的两倍</li>
<li>读操作不能读取实时性的数据，出现数据不一致，</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul>
<li><p>基于双向链表实现，只能顺序访问，但可以快速地在链表中间插入和删除元素</p>
</li>
<li><p>与 ArrayList 的区别（可以归结为数组和链表的区别）</p>
<ul>
<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素</li>
<li>链表不支持随机访问，但插入删除只需要改变指针</li>
</ul>
</li>
</ul>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul>
<li>LinkedList：可以用它来实现双向队列</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列</li>
</ul>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="/images/Java/Map.png" alt="Map"></p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul>
<li>基于红黑树实现</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li><p>基于哈希表实现</p>
</li>
<li><p>内部包含了一个 Node 类型的数组 table。Node 存储着键值对（数组 + 链表）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>允许插入键为 null 的键值对，但因为无法调用 null 的 hashCode() 方法确定桶下标，因此强制指定第 0 个桶存放键为 null 的键值对</p>
</li>
<li><p>put 方法</p>
<ul>
<li>如果 table 没有初始化就先进行初始化过程</li>
<li>使用 hash 算法计算 key 的索引</li>
<li>判断索引处有没有存在元素，没有就直接插入</li>
<li>如果索引处存在元素，则遍历插入，有两种情况，一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入</li>
<li>链表的数量大于阈值 8，就要转换成红黑树的结构</li>
<li>添加成功后会检查是否需要扩容</li>
</ul>
</li>
<li><p>扩容</p>
<ul>
<li><p>相关参数</p>
<ul>
<li>capacity：table 的容量大小，默认为 16，保证为 $2^n$</li>
<li>size：键值对数量</li>
<li>threshold：size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作</li>
<li>loadFactor：装载因子，table 能够使用的比例，threshold &#x3D; (int)(capacity* loadFactor)</li>
</ul>
</li>
<li><p>需要扩容时，令 capacity 为原来的两倍。使用 resize() 实现，需要把 oldTable 的所有键值对重新插入 newTable 中，很费时</p>
</li>
<li><p>重新计算桶下标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity     : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></table></figure>

<ul>
<li>对于一个 Key，它的哈希值 hash 在第 5 位<ul>
<li>为 0：桶位置和原来一致</li>
<li>为 1：桶位置是原位置 + 16</li>
</ul>
</li>
</ul>
</li>
<li><p>数组容量计算：HashMap 构造函数允许用户传入的容量不是 $2^n$，因为它可以自动地将传入的容量转换为 $2^n$</p>
</li>
<li><p>链表 $\leftrightarrow$ 红黑树（从 JDK 1.8 开始）</p>
<ul>
<li>若桶存储的链表长度大于等于 8 时，链表转换为红黑树</li>
<li>若桶中元素小于等于6时，树结构还原成链表形式</li>
</ul>
</li>
</ul>
</li>
<li><p>与 HashTable 的比较</p>
<ul>
<li>Hashtable 使用 synchronized 来进行同步</li>
<li>HashMap 可以插入键为 null 的 Entry</li>
<li>HashMap 的迭代器是 fail-fast 迭代器</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul>
<li><p>和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶，多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  <span class="keyword">volatile</span> V val;</span><br><span class="line">  <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Segment 继承自 ReentrantLock（重入锁）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2249069246763182397L</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line">  Segment(<span class="type">float</span> lf) &#123; <span class="built_in">this</span>.loadFactor = lf; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认的并发级别为 16</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized</p>
</li>
<li><p>size 操作</p>
<ul>
<li>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数</li>
<li>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来</li>
<li>先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的</li>
<li>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3</li>
<li>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁</li>
</ul>
</li>
</ul>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><ul>
<li>和 HashMap 类似，但它是线程安全的。建议使用 ConcurrentHashMap 来支持线程安全（引入了分段锁，效率高）</li>
</ul>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><ul>
<li><p>继承自 HashMap，使用双向链表来维护元素的顺序</p>
</li>
<li><p>accessOrder 决定了顺序，默认为 false</p>
<ul>
<li>false：插入顺序</li>
<li>true：最近最少使用（LRU）顺序</li>
</ul>
</li>
<li><p>afterNodeAccess()</p>
<ul>
<li>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部</li>
</ul>
</li>
<li><p>afterNodeInsertion()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">  LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">  <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">    removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点</li>
<li>evict 只有在构建 Map 的时候才为 false，在这里为 true</li>
<li>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现</li>
</ul>
</li>
</ul>
<h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><ul>
<li><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">	V value;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">  Entry&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p>
</li>
</ul>
<h4 id="ConcurrentCache"><a href="#ConcurrentCache" class="headerlink" title="ConcurrentCache"></a>ConcurrentCache</h4><ul>
<li><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能</p>
</li>
<li><p>ConcurrentCache 采取的是分代缓存</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收</li>
<li>当调用 get() 方法时，会先从 eden 区获取，再到 longterm 获取。当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，则将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象</li>
</ul>
</li>
</ul>
<h2 id="容器中的设计模式"><a href="#容器中的设计模式" class="headerlink" title="容器中的设计模式"></a>容器中的设计模式</h2><ul>
<li><p>迭代器模式：Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">List</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">  System.out.println(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>适配器模式：java.util.Arrays#asList() 可以把数组类型转换为 List 类型。应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">asList</span><span class="params">(T... a)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h1><p>有三种使用线程的方法</p>
<ul>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口</li>
<li>继承 Thread 类</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，最后还需要通过 Thread 来调用</p>
<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><ul>
<li><p>实现接口中的 run 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">myRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myRunnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h2><ul>
<li><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">  	<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(myCallable);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h2><ul>
<li><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runnable 接口</p>
</li>
<li><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h2><p>实现接口会更好一些，因为</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但可以实现多个接口</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大</li>
</ul>
<h1 id="基础线程机制"><a href="#基础线程机制" class="headerlink" title="基础线程机制"></a>基础线程机制</h1><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><ul>
<li><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作</p>
</li>
<li><p>主要有三种 Executor</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool</li>
</ul>
</li>
</ul>
<h2 id="Darmon"><a href="#Darmon" class="headerlink" title="Darmon"></a>Darmon</h2><ul>
<li>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分</li>
<li>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程</li>
<li>main() 属于非守护线程</li>
<li>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程</li>
</ul>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h2><ul>
<li>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒</li>
<li>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理</li>
</ul>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><ul>
<li>声明当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行</li>
<li>该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行</li>
</ul>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束</p>
<h2 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h2><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程<strong>处于阻塞、限期等待或者无限期等待状态</strong>，则会抛出 <strong>InterruptedException</strong>，从而提前结束该线程。但是<strong>不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞</strong></p>
<h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><ul>
<li><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束</p>
</li>
<li><p>但是调用 interrupt() 方法<strong>会设置线程的中断标记</strong>，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程</p>
</li>
</ul>
<h2 id="Executor-的中断操作"><a href="#Executor-的中断操作" class="headerlink" title="Executor 的中断操作"></a>Executor 的中断操作</h2><ul>
<li><p>调用 Executor 的 shutdown() 方法会<strong>等待线程都执行完毕之后再关闭</strong>，但如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法</p>
</li>
<li><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">    &#125;);</span><br><span class="line">    future.cancel(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问：1）JVM 实现的 synchronized；2）JDK 实现的 ReentrantLock</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><ul>
<li><p>同步一个代码块：只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">                System.out.println(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用同一个对象的同步代码块，这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SynchronizedExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(e1::func);</span><br><span class="line">    executorService.execute(e1::func);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用了不同对象的同步代码块，这两个线程就不需要同步</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SynchronizedExample</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">    <span class="type">SynchronizedExample</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(e1::func);</span><br><span class="line">    executorService.execute(e2::func);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6 0 1 2 3 4 5 6 7 8 9 7 8 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>同步一个方法：和同步代码块一样，作用于同一个对象</p>
</li>
<li><p>同步一个类：作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步</p>
</li>
<li><p>同步一个静态方法：作用于整个类</p>
</li>
</ul>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLockExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLockExample</span>();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(example::func);</span><br><span class="line">    executorService.execute(example::func);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    <span class="comment">// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul>
<li><p><strong>锁的实现</strong>：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的</p>
</li>
<li><p><strong>性能</strong>：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同</p>
</li>
<li><p><strong>等待可中断</strong>：</p>
<ul>
<li>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</li>
<li>ReentrantLock 可中断，而 synchronized 不行</li>
</ul>
</li>
<li><p>公平锁</p>
<ul>
<li>公平锁是指多个线程在等待同一个锁时，必须<strong>按照申请锁的时间顺序</strong>来依次获得锁</li>
<li>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的</li>
</ul>
</li>
<li><p>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象</p>
</li>
</ul>
<h2 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h2><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized</p>
<ul>
<li>synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持</li>
<li>使用 synchronized 不用担心没有释放锁而导致死锁问题， JVM 会确保锁的释放</li>
</ul>
<h1 id="线程间协作"><a href="#线程间协作" class="headerlink" title="线程间协作"></a>线程间协作</h1><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束</p>
<h2 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait() &amp; notify() &amp; notifyAll()"></a>wait() &amp; notify() &amp; notifyAll()</h2><ul>
<li><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程</p>
</li>
<li><p>它们都属于 Object 的一部分，而不属于 Thread</p>
</li>
<li><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException</p>
</li>
<li><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁</p>
</li>
<li><p>wait() 和 sleep() 的区别</p>
<ul>
<li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法</li>
<li>wait() 会释放锁，sleep() 不会</li>
</ul>
</li>
</ul>
<h2 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() &amp; signal() &amp; signalAll()"></a>await() &amp; signal() &amp; signalAll()</h2><ul>
<li><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程</p>
</li>
<li><p>相比于 wait() 这种等待方式，await() 可以<strong>指定等待的条件</strong>，因此更加灵活</p>
</li>
<li><p>使用 Lock 来获取一个 Condition 对象</p>
</li>
</ul>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态</p>
<h2 id="新建-NEW"><a href="#新建-NEW" class="headerlink" title="新建 NEW"></a>新建 NEW</h2><ul>
<li>创建后尚未启动</li>
</ul>
<h2 id="可启动-RUNABLE"><a href="#可启动-RUNABLE" class="headerlink" title="可启动 RUNABLE"></a>可启动 RUNABLE</h2><ul>
<li>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</li>
</ul>
<h2 id="阻塞-BLOCKED"><a href="#阻塞-BLOCKED" class="headerlink" title="阻塞 BLOCKED"></a>阻塞 BLOCKED</h2><ul>
<li>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入 RUNABLE 需要其他线程释放 monitor lock</li>
</ul>
<h2 id="无限期等待-WAITING"><a href="#无限期等待-WAITING" class="headerlink" title="无限期等待 WAITING"></a>无限期等待 WAITING</h2><ul>
<li>等待其它线程显式地唤醒</li>
<li>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入</li>
</ul>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">没有设置 Timeout 参数的 Object.wait() 方法</td>
<td align="center">Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td align="center">没有设置 Timeout 参数的 Thread.join() 方法</td>
<td align="center">被调用的线程执行完毕</td>
</tr>
<tr>
<td align="center">LockSupport.park() 方法</td>
<td align="center">LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h2 id="限期等待-TIMED-WAITING"><a href="#限期等待-TIMED-WAITING" class="headerlink" title="限期等待 TIMED_WAITING"></a>限期等待 TIMED_WAITING</h2><ul>
<li>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒</li>
</ul>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Thread.sleep() 方法</td>
<td align="center">时间结束</td>
</tr>
<tr>
<td align="center">设置了 Timeout 参数的 Object.wait() 方法</td>
<td align="center">时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td align="center">设置了 Timeout 参数的 Thread.join() 方法</td>
<td align="center">时间结束 &#x2F; 被调用的线程执行完毕</td>
</tr>
<tr>
<td align="center">LockSupport.parkNanos() 方法</td>
<td align="center">LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td align="center">LockSupport.parkUntil() 方法</td>
<td align="center">LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h2 id="死亡-TERMINATED"><a href="#死亡-TERMINATED" class="headerlink" title="死亡 TERMINATED"></a>死亡 TERMINATED</h2><ul>
<li>可以是线程结束任务之后自己结束，或者产生了异常而结束</li>
</ul>
<h1 id="J-U-C-AQS"><a href="#J-U-C-AQS" class="headerlink" title="J.U.C - AQS"></a>J.U.C - AQS</h1><p>java.util.concurrent (J.U.C) 大大提高了并发性能，AQS 被认为是 J.U.C 的核心</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用来控制一个或者多个线程等待多个线程</p>
<p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalThread</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(totalThread);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;run..&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.print(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// run..run..run..run..run..run..run..run..run..run..end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行</p>
<p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行</p>
<p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障</p>
<p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalThread</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(totalThread);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;before..&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">&quot;after..&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// before..before..before..before..before..before..before..before..before..before..</span></span><br><span class="line">        <span class="comment">// after..after..after..after..after..after..after..after..after..after..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>类似于操作系统中的信号量，可以控制对互斥资源的访问线程数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">clientCount</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">totalRequestCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(clientCount);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 0 1 0 2 0 1 0 0 1 1 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="J-U-C-其它组件"><a href="#J-U-C-其它组件" class="headerlink" title="J.U.C - 其它组件"></a>J.U.C - 其它组件</h1><h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 <code>Future&lt;V&gt;</code> 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 <code>Future&lt;V&gt;</code> 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt;</span><br></pre></td></tr></table></figure>

<p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">computeThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">otherThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Other thread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">        <span class="comment">// Other thread is running...</span></span><br><span class="line">        <span class="comment">// 4950</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p>
<ul>
<li>FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li>
<li>优先级队列 ：PriorityBlockingQueue</li>
</ul>
<p>提供了阻塞的 take() 和 put() 方法</p>
<ul>
<li>如果队列为空 take() 将阻塞，直到队列中有内容</li>
<li>如果队列为满 put() 将阻塞，直到队列有空闲位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;String&gt; stringBlockingDeque = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stringBlockingDeque.put(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;P&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stringBlockingDeque.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>();</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">Producer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>();</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PPCCPPPCCC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threshold</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ForkJoinExample</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> last)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.first = first;</span><br><span class="line">        <span class="built_in">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小，则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对任务进行拆分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (first + last) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">ForkJoinExample</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinExample</span>(first, middle);</span><br><span class="line">            <span class="type">ForkJoinExample</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinExample</span>(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">ForkJoinExample</span> <span class="variable">forkJoinExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinExample</span>(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">    Future&lt;Integer&gt; result = forkJoinPool.submit(forkJoinExample);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">    <span class="comment">// 50005000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span></span><br></pre></td></tr></table></figure>

<p>ForkJoinPool 实现了<strong>工作窃取算法</strong>来提高 CPU 的利用率。每个线程都维护了一个<strong>双端队列</strong>，用来存储需要执行的任务。工作窃取算法<strong>允许空闲的线程从其它线程的双端队列中窃取一个任务来执行</strong>。窃取的任务<strong>必须是最晚的任务</strong>，避免和队列所属线程发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p>
<h1 id="线程不安全示例"><a href="#线程不安全示例" class="headerlink" title="线程不安全示例"></a>线程不安全示例</h1><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadUnsafeExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">ThreadUnsafeExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadUnsafeExample</span>();</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;threadSize;i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">    <span class="comment">// 990</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果</p>
<h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p><img src="/images/Java/%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" alt="主内存与工作内存"></p>
<p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p>
<p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p>
<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，<strong>工作内存存储在高速缓存或者寄存器中</strong>，保存了该线程使用的变量的主内存副本拷贝。</p>
<p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p><img src="/images/Java/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png" alt="内存间交互操作"></p>
<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
<h2 id="内存模型三大特性"><a href="#内存模型三大特性" class="headerlink" title="内存模型三大特性"></a>内存模型三大特性</h2><ul>
<li><p>原子性</p>
<ul>
<li><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性</p>
</li>
<li><p>Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性</p>
</li>
<li><p>AtomicInteger 能保证多个线程修改的原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadSize</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">AtomicExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicExample</span>();</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(threadSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;threadSize;i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">    <span class="comment">// 1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit</p>
</li>
</ul>
</li>
<li><p>可见性</p>
<ul>
<li>指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改</li>
<li>Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现</li>
<li>实现方式<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存<ul>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值</li>
</ul>
</li>
</ul>
</li>
<li>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性</li>
</ul>
</li>
<li><p>有序性</p>
<ul>
<li>指在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序</li>
<li>在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性</li>
<li>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前</li>
<li>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码</li>
</ul>
</li>
</ul>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成</p>
<ul>
<li>单一线程原则 Single Thread Rule：在一个线程内，在程序前面的操作先行发生于后面的操作</li>
<li>管程锁定规则 Monitor Lock Rule：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作</li>
<li>volatile 变量规则 Volatile Variable Rule：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作</li>
<li>线程启动规则 Thread Start Rule：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作</li>
<li>线程加入规则 Thread Join Rule：Thread 对象的结束先行发生于 join() 方法返回</li>
<li>线程中断规则 Thread Interrupt Rule：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生</li>
<li>对象终结规则 Finalizer Rule：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始</li>
<li>传递性 Transitivity：若操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，则操作 A 先行发生于操作 C</li>
</ul>
<h1 id="CAS-机制"><a href="#CAS-机制" class="headerlink" title="CAS 机制"></a>CAS 机制</h1><blockquote>
<p>Java 提供的一种强大的并发原语，Compare and Swap，用于解决并发编程中多线程对共享资源的访问和修改时可能导致的竞态条件和数据不一致的问题</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/12160085.html">并发编程的基石——CAS 机制</a></p>
</blockquote>
<p>在多线程环境下，对共享变量进行数据更新有两种模式</p>
<p>1、悲观锁模式</p>
<p>在更新数据时大概率会有其他线程去争夺共享资源，因此第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。</p>
<p>synchronized 就是 Java 中悲观锁的典型实现，它使用方便，但是缺点是：没争抢到资源的线程进入阻塞状态，线程在阻塞状态和 Runnable 状态之间切换效率较低（比较慢）</p>
<p>2、乐观锁模式</p>
<p>在更新数据时其他线程争抢这个共享变量的概率非常小，因此更新数据时不会对共享数据加锁。但在正式更新数据之前会检查数据是否被其他线程改变过，如果没有则更新共享变量，否则需要进行重试，直到成功为止。</p>
<p>CAS 机制就是乐观锁的典型实现，其主要的核心参数有</p>
<img src="/images/Java/CAS.png" alt="CAS" style="zoom:50%;" />

<ul>
<li>主内存中存放的共享变量的值：V（一般是内存的地址值，通过这个地址可以获得内存中的值）</li>
<li>工作内存中共享变量的副本值，也叫预期值：A</li>
<li>需要将共享变量更新到的最新值：B</li>
</ul>
<p>流程</p>
<ul>
<li><p>主存中保存 V 值，线程中要使用 V 值要先从主存中读取 V 值到线程的工作内存 A 中，然后计算后变成 B 值，最后再把 B 值写回到内存V值中</p>
</li>
<li><p>CAS 的核心是在将 B 值写入到 V 之前要比较 A 值和 V 值是否相同，如果不相同证明此时 V 值已经被其他线程改变，重新将 V 值赋给 A，并重新计算得到 B，如果相同，则将 B 值赋给 V。</p>
</li>
<li><p>CAS 的步骤是原子性的（从指令层面提供的原子操作），因此可以解决多线程并发编程对共享变量读写的原子性问题</p>
</li>
</ul>
<p>优缺点</p>
<ul>
<li>优点<ul>
<li>可以保证变量操作的原子性</li>
<li>并发量不是很高的情况下，使用 CAS 机制比使用锁机制效率更高</li>
<li>在线程对共享资源占用时间较短的情况下，使用 CAS 机制效率也会较高</li>
</ul>
</li>
<li>缺点<ul>
<li>ABA 问题<ul>
<li>问题：CAS 在操作时会检查变量的值是否被更改过，如果没有则更新值，但这会有一个问题，最开始的值是 A，接着变成 B，最后又变成了 A。经过检查这个值确实没有修改过，因为最后的值还是 A，但是实际上这个值确实已经被修改过了</li>
<li>解决措施：在每次进行操作时加上一个版本号，每次操作的就是两个值，一个版本号和某个值，ABA 问题就变成了 1A-2B-3A。在 jdk 中提供了 AtomicStampedReference 类解决 ABA 问题，用 Pair 这个内部类实现，包含两个属性，分别代表版本号和引用，在 compareAndSet 中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值</li>
</ul>
</li>
<li>CPU 消耗高<ul>
<li>在线程之间竞争程度大时，CAS 机制会比较耗 CPU，因为会有大量更新失败并重试</li>
<li>因此如果线程竞争程度小，可以使用 CAS，如果竞争程度大，建议使用锁，或者使用 AtomicLong 的替代类：LongAdder</li>
</ul>
</li>
<li>不能保证代码块的原子性<ul>
<li>CAS 机制只能保证共享变量操作的原子性，而不能保证代码块的原子性（使用 synchronied 锁）</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag"># 编程语言</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/02/19/Python/" rel="prev" title="Python">
      <i class="fa fa-chevron-left"></i> Python
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/02/19/Golang/" rel="next" title="Golang">
      Golang <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E7%9A%84%E4%B8%89%E4%B8%AA%E4%BD%93%E7%B3%BB"><span class="nav-number">1.1.</span> <span class="nav-text">Java 的三个体系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E7%89%B9%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">Java 特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">1.3.</span> <span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">1.4.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F-%E5%B8%B8%E9%87%8F%E5%80%BC"><span class="nav-number">1.5.</span> <span class="nav-text">常量 &amp; 常量值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.6.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.8.</span> <span class="nav-text">数据类型转换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.</span> <span class="nav-text">流程控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#switch-case-%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.1.</span> <span class="nav-text">switch case 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break-%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.2.</span> <span class="nav-text">break 语句</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-String-%E4%B8%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="nav-number">3.1.</span> <span class="nav-text">为什么 String 为不可变的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StringBuffer-%E7%B1%BB"><span class="nav-number">3.2.</span> <span class="nav-text">StringBuffer 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E3%80%81StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">String、StringBuffer 和 StringBuilder 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-Pool"><span class="nav-number">3.4.</span> <span class="nav-text">String Pool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-String-%E2%80%9Cabc%E2%80%9D"><span class="nav-number">3.5.</span> <span class="nav-text">new String(“abc”)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">Java 正则表达式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%92%8C%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">数字和日期处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">内置包装类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%99%E8%AF%AF-%E5%BC%82%E5%B8%B8"><span class="nav-number">6.</span> <span class="nav-text">错误 &amp; 异常</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3-Annotation"><span class="nav-number">7.</span> <span class="nav-text">注解 Annotation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84-Reflection"><span class="nav-number">8.</span> <span class="nav-text">反射 Reflection</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">9.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-number">10.</span> <span class="nav-text">包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="nav-number">10.1.</span> <span class="nav-text">装箱和拆箱</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="nav-number">11.</span> <span class="nav-text">缓存池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#valueOf-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">11.1.</span> <span class="nav-text">valueOf 的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="nav-number">11.2.</span> <span class="nav-text">基本类型对应的缓存池</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">12.</span> <span class="nav-text">参数传递</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final"><span class="nav-number">13.</span> <span class="nav-text">final</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE"><span class="nav-number">13.1.</span> <span class="nav-text">数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">13.2.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">13.3.</span> <span class="nav-text">类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static"><span class="nav-number">14.</span> <span class="nav-text">static</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">14.1.</span> <span class="nav-text">静态变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">14.2.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="nav-number">14.3.</span> <span class="nav-text">静态语句块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">14.4.</span> <span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%AF%BC%E5%8C%85"><span class="nav-number">14.5.</span> <span class="nav-text">静态导包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">14.6.</span> <span class="nav-text">初始化顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Object-%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">15.</span> <span class="nav-text">Object 通用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#equals"><span class="nav-number">15.1.</span> <span class="nav-text">equals()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB"><span class="nav-number">15.1.1.</span> <span class="nav-text">等价关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E4%BB%B7%E4%B8%8E%E7%9B%B8%E7%AD%89"><span class="nav-number">15.1.2.</span> <span class="nav-text">等价与相等</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">15.1.3.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hashCode"><span class="nav-number">15.2.</span> <span class="nav-text">hashCode()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#toString-NaN"><span class="nav-number">15.3.</span> <span class="nav-text">toString()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clone"><span class="nav-number">15.4.</span> <span class="nav-text">clone()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">16.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-number">16.1.</span> <span class="nav-text">访问权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="nav-number">16.2.</span> <span class="nav-text">抽象类与接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#super"><span class="nav-number">16.3.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="nav-number">16.4.</span> <span class="nav-text">重写和重载</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">17.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Wait-Notify-%E6%9C%BA%E5%88%B6"><span class="nav-number">18.</span> <span class="nav-text">Wait &#x2F; Notify 机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-number">19.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection"><span class="nav-number">19.1.</span> <span class="nav-text">Collection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">19.1.1.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList"><span class="nav-number">19.1.1.1.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector"><span class="nav-number">19.1.1.2.</span> <span class="nav-text">Vector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList"><span class="nav-number">19.1.1.3.</span> <span class="nav-text">LinkedList</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue"><span class="nav-number">19.1.1.4.</span> <span class="nav-text">Queue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">19.2.</span> <span class="nav-text">Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap"><span class="nav-number">19.2.1.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap"><span class="nav-number">19.2.2.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">19.2.3.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashTable"><span class="nav-number">19.2.4.</span> <span class="nav-text">HashTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">19.2.5.</span> <span class="nav-text">LinkedHashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakHashMap"><span class="nav-number">19.2.6.</span> <span class="nav-text">WeakHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentCache"><span class="nav-number">19.2.6.1.</span> <span class="nav-text">ConcurrentCache</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">19.3.</span> <span class="nav-text">容器中的设计模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="nav-number">20.</span> <span class="nav-text">使用线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">20.1.</span> <span class="nav-text">实现 Runnable 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">20.2.</span> <span class="nav-text">实现 Callable 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB"><span class="nav-number">20.3.</span> <span class="nav-text">继承 Thread 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3-VS-%E7%BB%A7%E6%89%BF-Thread"><span class="nav-number">20.4.</span> <span class="nav-text">实现接口 VS 继承 Thread</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6"><span class="nav-number">21.</span> <span class="nav-text">基础线程机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor"><span class="nav-number">21.1.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Darmon"><span class="nav-number">21.2.</span> <span class="nav-text">Darmon</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep"><span class="nav-number">21.3.</span> <span class="nav-text">sleep()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield"><span class="nav-number">21.4.</span> <span class="nav-text">yield()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">22.</span> <span class="nav-text">中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InterruptedException"><span class="nav-number">22.1.</span> <span class="nav-text">InterruptedException</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupted"><span class="nav-number">22.2.</span> <span class="nav-text">interrupted()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%93%8D%E4%BD%9C"><span class="nav-number">22.3.</span> <span class="nav-text">Executor 的中断操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="nav-number">23.</span> <span class="nav-text">互斥同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">23.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">23.2.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E8%BE%83"><span class="nav-number">23.3.</span> <span class="nav-text">比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9"><span class="nav-number">23.4.</span> <span class="nav-text">使用选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%8D%8F%E4%BD%9C"><span class="nav-number">24.</span> <span class="nav-text">线程间协作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#join"><span class="nav-number">24.1.</span> <span class="nav-text">join()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-notify-notifyAll"><span class="nav-number">24.2.</span> <span class="nav-text">wait() &amp; notify() &amp; notifyAll()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#await-signal-signalAll"><span class="nav-number">24.3.</span> <span class="nav-text">await() &amp; signal() &amp; signalAll()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">25.</span> <span class="nav-text">线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA-NEW"><span class="nav-number">25.1.</span> <span class="nav-text">新建 NEW</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%90%AF%E5%8A%A8-RUNABLE"><span class="nav-number">25.2.</span> <span class="nav-text">可启动 RUNABLE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E-BLOCKED"><span class="nav-number">25.3.</span> <span class="nav-text">阻塞 BLOCKED</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85-WAITING"><span class="nav-number">25.4.</span> <span class="nav-text">无限期等待 WAITING</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%90%E6%9C%9F%E7%AD%89%E5%BE%85-TIMED-WAITING"><span class="nav-number">25.5.</span> <span class="nav-text">限期等待 TIMED_WAITING</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1-TERMINATED"><span class="nav-number">25.6.</span> <span class="nav-text">死亡 TERMINATED</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#J-U-C-AQS"><span class="nav-number">26.</span> <span class="nav-text">J.U.C - AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">26.1.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">26.2.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">26.3.</span> <span class="nav-text">Semaphore</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#J-U-C-%E5%85%B6%E5%AE%83%E7%BB%84%E4%BB%B6"><span class="nav-number">27.</span> <span class="nav-text">J.U.C - 其它组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FutureTask"><span class="nav-number">27.1.</span> <span class="nav-text">FutureTask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">27.2.</span> <span class="nav-text">BlockingQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ForkJoin"><span class="nav-number">27.3.</span> <span class="nav-text">ForkJoin</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">28.</span> <span class="nav-text">线程不安全示例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">29.</span> <span class="nav-text">Java 内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="nav-number">29.1.</span> <span class="nav-text">主内存与工作内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-number">29.2.</span> <span class="nav-text">内存间交互操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">29.3.</span> <span class="nav-text">内存模型三大特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99"><span class="nav-number">29.4.</span> <span class="nav-text">先行发生原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAS-%E6%9C%BA%E5%88%B6"><span class="nav-number">30.</span> <span class="nav-text">CAS 机制</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bling"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Bling</p>
  <div class="site-description" itemprop="description">绳锯木断，水滴石穿</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-01 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bling</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
