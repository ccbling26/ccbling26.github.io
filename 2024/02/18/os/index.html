<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="操作系统相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2024/02/18/os/index.html">
<meta property="og:site_name" content="随笔">
<meta property="og:description" content="操作系统相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/os/%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E4%B8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="http://example.com/images/os/%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E4%B8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="http://example.com/images/os/32%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="http://example.com/images/os/64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="http://example.com/images/os/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80.png">
<meta property="og:image" content="http://example.com/images/os/Linux%20%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83.png">
<meta property="og:image" content="http://example.com/images/os/32%E4%BD%8DLinux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png">
<meta property="og:image" content="http://example.com/images/os/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%AD%97%E6%AE%B5.png">
<meta property="og:image" content="http://example.com/images/os/%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E7%8A%B6%E6%80%81.jpg">
<meta property="og:image" content="http://example.com/images/os/TCP%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E7%9A%84Socket%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="http://example.com/images/os/UDP%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E7%9A%84Socket%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B.jpg">
<meta property="og:image" content="http://example.com/images/os/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png">
<meta property="og:image" content="http://example.com/images/os/%E5%9D%97%E7%BB%84.png">
<meta property="og:image" content="http://example.com/images/os/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png">
<meta property="og:image" content="http://example.com/images/os/mmap_write%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png">
<meta property="og:image" content="http://example.com/images/os/sendfile%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png">
<meta property="og:image" content="http://example.com/images/os/SG_DMA%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png">
<meta property="og:image" content="http://example.com/images/os/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/images/os/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/images/os/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/images/os/Proactor.png">
<meta property="article:published_time" content="2024-02-18T05:57:02.000Z">
<meta property="article:modified_time" content="2024-02-18T06:03:25.614Z">
<meta property="article:author" content="Bling">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/os/%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E4%B8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F.png">

<link rel="canonical" href="http://example.com/2024/02/18/os/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统 | 随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/02/18/os/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Bling">
      <meta itemprop="description" content="绳锯木断，水滴石穿">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随笔">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-02-18 13:57:02 / 修改时间：14:03:25" itemprop="dateCreated datePublished" datetime="2024-02-18T13:57:02+08:00">2024-02-18</time>
            </span>

          
            <div class="post-description">操作系统相关知识</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h1><h2 id="冯诺伊曼模型"><a href="#冯诺伊曼模型" class="headerlink" title="冯诺伊曼模型"></a>冯诺伊曼模型</h2><p>运算器、控制器、存储器、输入设备、输出设备</p>
<blockquote>
<p>运算器、控制器是在中央处理器里的</p>
<p>存储单元和输入输出设备通过总线与中央处理器打交道</p>
</blockquote>
<h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>用于 CPU 和内存以及其他设备之间的通信，分为 3 类</p>
<ul>
<li>地址总线，用于指定 CPU 将要操作的内存地址</li>
<li>数据总线，用于读写内存的数据</li>
<li>控制总线，用于发送和接收信号，比如中断、设备复位等信号</li>
</ul>
<p>CPU 要读写内存数据使用到的总线</p>
<ul>
<li>通过「地址总线」来指定内存的地址</li>
<li>通过「控制总线」控制是读或写命令</li>
<li>通过「数据总线」来传输数据</li>
</ul>
<h2 id="程序的-CPU-执行时间"><a href="#程序的-CPU-执行时间" class="headerlink" title="程序的 CPU 执行时间"></a>程序的 CPU 执行时间</h2><p>程序的 CPU 执行时间 &#x3D; 指令数 * CPI * 时钟周期时间</p>
<ul>
<li>指令数：表示执行程序所需要多少条指令，以及哪些指令，通过编译器优化</li>
<li>CPI：每条指令的平均时钟周期数，通过流水线技术减少</li>
<li>时钟周期时间：计算机主频，取决于硬件，可以通过超频优化</li>
</ul>
<h2 id="软件-32-位和-64-位的区别"><a href="#软件-32-位和-64-位的区别" class="headerlink" title="软件 32 位和 64 位的区别"></a>软件 32 位和 64 位的区别</h2><p>64 位和 32 位软件，实际上代表指令是 64 位还是 32 位的</p>
<h2 id="32-64-位操作系统能在-64-32-位机器上运行吗"><a href="#32-64-位操作系统能在-64-32-位机器上运行吗" class="headerlink" title="32&#x2F;64 位操作系统能在 64&#x2F;32 位机器上运行吗"></a>32&#x2F;64 位操作系统能在 64&#x2F;32 位机器上运行吗</h2><p>32 位指令在 64 位机器上执行：可以，需要一套兼容机制就可以做到兼容运行</p>
<p>64 位指令在 32 位机器上执行：不能，因为 32 位的寄存器存不下 64 位的指令</p>
<h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><blockquote>
<p>每一层存储器只能和相邻的存储器打交道</p>
</blockquote>
<p><strong>寄存器</strong></p>
<p><strong>CPU Cache</strong>：使用 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片，有电就能保持数据存在，断电数据就丢失。可以分为：L1-Cache，L2-Cache，L3-Cache 三层</p>
<p><strong>内存</strong>：使用 DRAM （Dynamic Random Access Memory，动态随机存取存储器） 的芯片，数据存在电容中，需要不断刷新才能存储数据</p>
<p><strong>SSD&#x2F;HDD 硬盘</strong>：断电后数据存在</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断是系统用来<strong>响应硬件设备请求</strong>的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序（中断请求的响应程序）来响应请求</p>
<p>中断处理程序在响应中断时，可能会关中断，即在当前中断处理程序执行完前，系统中其他的中断请求都无法被响应，这可能会导致中断丢失</p>
<p>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了<strong>硬中断和软中断</strong>两个阶段</p>
<ul>
<li>硬中断：直接处理硬件请求，主要是负责耗时短的工作，特点是快速执行</li>
<li>软中断：由内核触发，主要是负责硬中断未完成的工作，通常都是耗时比较长的事情，特点是延迟执行</li>
</ul>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>32 位 CPU、64 位 CPU 中的 32 位和 64 位指的是 CPU 的位宽，代表 CPU 一次可以计算的数据量</p>
<p>CPU 内部还有一些组件，常见的有寄存器、控制单元和逻辑运算单元等。</p>
<ul>
<li>控制单元负责控制 CPU 工作</li>
<li>逻辑运算单元负责计算</li>
<li>寄存器主要作用是存储计算时的数据<ul>
<li>通用寄存器，用来存放需要进行运算的数据</li>
<li>程序计数器，用来存储 CPU 要执行<strong>下一条指令所在的内存地址</strong>，注意不是<strong>下一条要执行的指令</strong>，此时指令还在内存中，程序计数器只是存储了下一条指令的地址</li>
<li>指令寄存器，用来存放当前正在执行的指令</li>
</ul>
</li>
</ul>
<p>64 位 CPU 性能不一定比 32 位 CPU 高，如果计算的数字不超过 32 位，则没啥区别，但是如果超过 32 位，32 位 CPU 需要分两次计算，此时 64 CPU 性能更好</p>
<p>CPU 执行指令过程</p>
<ul>
<li>CPU 从<strong>程序计数器</strong>读取指令的内存地址，由<strong>控制单元</strong>操作<strong>地址总线</strong>指定需要访问的内存空间，通知内存设备准备数据，在数据准备好后通过<strong>数据总线</strong>将指令传给 CPU，并存入<strong>指令寄存器</strong></li>
<li>程序计数器根据 CPU 位宽自增</li>
<li>CPU 分析指令寄存器中的指令，确定指令的类型和参数，如果为计算类型的指令，则交给逻辑运算单元运算，如果是存储类型的指令，则交给控制单元执行</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>以 MIPS 指令为例，主要分为 3 种</p>
<ul>
<li>R 指令：用于算术和逻辑操作</li>
<li>I 指令：用于数据传输、条件分支等</li>
<li>J 指令：用于跳转，7～32 位为跳转地址</li>
</ul>
<p>指令周期</p>
<ul>
<li>Fetch：CPU 的控制器通过程序计数器读取对应内存地址的指令</li>
<li>Decode：CPU 的控制器对指令进行解码</li>
<li>Execution：CPU 的运算器执行指令</li>
<li>Store：CPU 的运算器将计算结果存回寄存器或者将寄存器的值存入内存</li>
</ul>
<p>从功能对指令进行划分</p>
<ul>
<li>数据传输类型：比如 <code>store/load</code> 是寄存器与内存间数据传输的指令，<code>mov</code> 是将一个内存地址的数据移动到另一个内存地址的指令</li>
<li>运算类型：比如加减乘除、位运算、比较大小等，它们最多只能处理两个寄存器中的数据</li>
<li>跳转类型：通过修改程序计数器的值来达到跳转执行指令的过程，比如编程中常见的 <code>if-else</code>、<code>switch-case</code>、函数调用等</li>
<li>信号类型：比如发生中断的指令 <code>trap</code></li>
<li>闲置类型：比如指令 <code>nop</code>，执行后 CPU 会空转一个周期；</li>
</ul>
<h2 id="CPU-缓存一致性"><a href="#CPU-缓存一致性" class="headerlink" title="CPU 缓存一致性"></a>CPU 缓存一致性</h2><p>在多核心 CPU 中，每个核心有各自的 L1&#x2F;L2 Cache，L3-Cache 是所有核心共享的</p>
<p>CPU Cache 由很多个 Cache Line 组成，CPU Line 是 CPU 从内存读取数据的基本单位，CPU Line 由各种标志（Tag）+ 数据块（Data Blook） 组成</p>
<p>Cache 写入数据到内存的方式</p>
<ul>
<li>写直达：把数据同时写入内存和 Cache 中</li>
<li>写回：先写到 Cache 中，并标记为脏，当块被替换出去后才更新到内存</li>
</ul>
<p>不同核心的缓存一致性</p>
<ul>
<li>写传播：某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache<ul>
<li>常见的实现方式是总线嗅探，每个核心监听总线上的广播事件，缺点是增加了总线的负载</li>
</ul>
</li>
<li>事务的串行化：某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的<ul>
<li>MESI 协议<ul>
<li>Modified，已修改</li>
<li>Exclusive，独占。数据是干净的，但只有一个核心独有</li>
<li>Shared，共享。数据是干净的，但是有多个核心都有，更新时需要广播给其他核心，将该数据标记为已失效</li>
<li>Invalidated，已失效</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="为什么需要虚拟内存"><a href="#为什么需要虚拟内存" class="headerlink" title="为什么需要虚拟内存"></a>为什么需要虚拟内存</h2><blockquote>
<p>单片机是没有操作系统的，需要借助工具将程序烧录进单片机，程序才能运行。单片机的 CPU 是直接操作内存的物理地址的，因此无法同时运行两个程序（会进行覆盖，否则会访问同一个地址时会发生冲突）</p>
</blockquote>
<p><strong>隔离进程所使用的地址，解决多进程之间的地址冲突问题，使操作系统能够运行多个程序</strong>：操作系统为每个进程分配<strong>独立</strong>的虚拟地址（引入虚拟内存）。进程不能直接访问物理地址，虚拟地址与物理地址的映射机制由操作系统提供</p>
<p><strong>进程可以使用超过物理内存大小的运行内存</strong>：主要利用局部性原理，将不经常使用的内存替换到硬盘上</p>
<blockquote>
<p>进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存</p>
</blockquote>
<h2 id="虚拟地址和物理地址的映射机制"><a href="#虚拟地址和物理地址的映射机制" class="headerlink" title="虚拟地址和物理地址的映射机制"></a>虚拟地址和物理地址的映射机制</h2><h3 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h3><blockquote>
<p>程序由若干个逻辑分段组成，如可由代码段、数据段、栈段、堆段组成</p>
</blockquote>
<img src="/images/os/分段管理下虚拟地址和物理地址的映射方式.png" alt="img" style="zoom:50%;" />

<p>在此机制下，虚拟地址由<strong>段选择因子和段内偏移量</strong>组成</p>
<blockquote>
<p>段选择因子保存在段寄存器里，最重要的是段号，用作段表的索引</p>
</blockquote>
<p>这种方式存在以下不足</p>
<ul>
<li><p>可以根据段的大小分配内存，<strong>不会出现内部内存碎片</strong>；但由于每个段的长度不固定，多个段未必能恰好使用所有的内存空间，会产生多个不连续的小物理内存，导致新的程序无法被装载，<strong>会出现外部内存碎片</strong></p>
</li>
<li><p>内存交换（将程序从内存写入到硬盘，再重新写回内存）可以解决内存碎片问题，但由于硬盘（相比内存）速度慢，且如果程序占内存空间很大时，系统会变得十分卡顿</p>
</li>
</ul>
<blockquote>
<p>在 Linux 里，内存交换空间就是 Swap 空间，用于内存与硬盘的空间交换</p>
</blockquote>
<h3 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h3><blockquote>
<p>将整个虚拟内存空间和物理内存空间按照固定尺寸进行切割，每个单位称为<strong>页</strong>。在 Linux 中，每一页的大小为 4KB</p>
</blockquote>
<p>在此机制下，虚拟地址与物理地址之间通过<strong>页表</strong>进行映射（由 MMU 负责），页表存储在内存里。</p>
<blockquote>
<p>当进程访问的虚拟地址在页表中不存在时，系统会产生<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行</p>
</blockquote>
<img src="/images/os/分页管理下虚拟地址和物理地址的映射方式.png" alt="img" style="zoom:50%;" />

<p>这种方式存在以下优点</p>
<ul>
<li><p>页相对段来说小很多，因此当内存空间不足需要进行内存交换时，只需要换出和换入少数的几个页，相比更换整个段来说，效率大幅提高</p>
<blockquote>
<p>换出：Swap Out，将内存里的数据写入到硬盘中</p>
<p>换入：Swap In，将硬盘里的数据加载到内存中</p>
</blockquote>
</li>
<li><p>在加载程序时，不需要一次性将整个程序加载到内存中</p>
</li>
</ul>
<p>但页存在以下不足</p>
<ul>
<li>页与页之间是紧密排序的，不会出现外部内存碎片；但由于内存分配的最小单位为页，即使程序不足一页大小，也只能分配一个页，就会出现内存浪费，出现内部内存碎片。</li>
</ul>
<h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><blockquote>
<p>在 32 位和页大小 4KB 的环境下，一个进程的页表需要装下 $2^{20}$ 个页表项，并且每个页表项占用 4 个字节，因此每个页表占用 4MB 大小的空间。如果有 100 个进程，则需要 400 MB 的内存来存储页表，这消耗非常大的内存。</p>
</blockquote>
<p>如果将单级页表再分页（将一级页表分为 1024 个二级页表，每个二级页表包含 1024 个页表项），则映射 4GB 地址空间就需要 4 KB + 4 MB</p>
<img src="/images/os/32位系统虚拟地址格式.png" alt="32位系统虚拟地址格式" style="zoom:50%;" />

<p>虽然二级分页的占用空间比单级分页的占用空间大，但进程一般不会使用到所有的物理内存，因此存在部分页表项是空的，其对应的二级分页也无需分配；由于<strong>局部性原理</strong>，在程序初始化阶段不用创建所有二级页面，可以在需要时再分配，而且在内存紧张时，也可以将页面换出到硬盘中</p>
<blockquote>
<p>在 64 位的系统中是四级分页，分别是：全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）、页表项 PTE（Page Table Entry）</p>
<img src="/images/os/64位系统虚拟地址格式.png" alt="64位系统虚拟地址格式" style="zoom: 67%;" />
</blockquote>
<p>多级分页解决了空间上的问题，但虚拟地址和物理地址的转换开销增加，由于<strong>局部性原理</strong>，把最常用的页表项存储到访问速度更快的硬件（即 <strong>TLB</strong>，Translation Lookaside Buffer，通常称为页表缓存、转址旁路缓存、快表）。因此 CPU 在寻址时，会先查 TLB，如果没找到再查找常规的页表</p>
<h3 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h3><blockquote>
<p>先将程序划分为多个有逻辑意义的段，再把每个段划分为多个固定大小的页</p>
</blockquote>
<p>在此机制下，虚拟地址由<strong>段选择因子、段内页号和页内位移</strong>组成</p>
<h2 id="逻辑地址和虚拟地址（线性地址）"><a href="#逻辑地址和虚拟地址（线性地址）" class="headerlink" title="逻辑地址和虚拟地址（线性地址）"></a>逻辑地址和虚拟地址（线性地址）</h2><blockquote>
<p>页式内存管理的作用是在由段式内存管理所映射而成的地址上再加上一层地址映射</p>
</blockquote>
<p><img src="/images/os/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80.png" alt="img"></p>
<blockquote>
<p>在 32 位 Linux 系统中，每个段都是从 0 地址开始的整个 4 GB虚拟空间，即所有段的起始地址是一样的。这意味着 Linux 系统中的代码面对的地址空间都是线性地址空间，屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护</p>
</blockquote>
<h2 id="Linux-虚拟地址空间分布"><a href="#Linux-虚拟地址空间分布" class="headerlink" title="Linux 虚拟地址空间分布"></a>Linux 虚拟地址空间分布</h2><p>在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间</strong>和<strong>用户空间</strong>两部分，不同位数的系统，地址空间的范围也不同</p>
<img src="/images/os/Linux 虚拟地址空间分布.png" alt="img" style="zoom:50%;" />

<p>当进程在用户态时，只能访问用户空间内存，只有进入内核态后，才可以访问内核空间内存</p>
<p>虽然每个进程都各自有独立的虚拟内存，但其实<strong>每个虚拟内存中的内核地址关联的都是相同的物理内存</strong>。这样进程切换到内核态后，就可以很方便地访问内核空间内存</p>
<h3 id="用户空间分布情况"><a href="#用户空间分布情况" class="headerlink" title="用户空间分布情况"></a>用户空间分布情况</h3><blockquote>
<p>32 位 Linux 系统为例，64 位中内核空间和用户空间均为 128T</p>
</blockquote>
<img src="/images/os/32位Linux进程的内存布局.png" alt="32位Linux进程的内存布局" style="zoom: 67%;" />

<p>栈段：包括局部变量和函数调用的上下文等（栈的大小是固定的，一般是 8 MB）</p>
<p>文件映射段：包括动态分配的内存(<strong>动态链接库、共享内存</strong>等)，比如使用 C 标准库的 <code>mmap()</code>。从低地址开始向上增长（这种布局限制了堆只有 1 GB 的虚拟地址空间可用，内核 2.6.7 之后发生修改）</p>
<p>堆段：包括动态分配的内存，比如使用 C 标准库的 <code>malloc()</code>。从低地址开始向上增长</p>
<p>BSS 段：包括<strong>未初始化</strong>的<strong>静态变量和全局变量</strong></p>
<p>数据段：包括<strong>已初始化</strong>的<strong>静态常量和全局变量</strong></p>
<p>代码段：包括二进制可执行代码</p>
<p>保留区：代码段下面的一段不可访问的内存，在大多数的系统里，比较小数值的地址被认为不是一个合法地址，例如 C 代码里会将无效的指针赋值为 NULL</p>
<h2 id="malloc-是如何分配内存的"><a href="#malloc-是如何分配内存的" class="headerlink" title="malloc 是如何分配内存的"></a>malloc 是如何分配内存的</h2><p>malloc 不是系统调用，而是 C 库里的函数，用于动态分配内存（分配的是<strong>虚拟内存</strong>，并且<strong>会预分配更大的空间</strong>作为内存池）</p>
<p>malloc 申请内存时，有两种方式向操作系统申请堆内存</p>
<ul>
<li>通过 <code>brk()</code> 系统调用从<strong>堆</strong>分配内存</li>
<li>通过 <code>mmap()</code> 系统调用中的<strong>私有匿名映射</strong>方式，在<strong>文件映射区域</strong>分配内存</li>
</ul>
<blockquote>
<p>malloc() 源码里默认定义了一个阈值</p>
<ul>
<li><p>分配的内存小于 128 KB，使用 <code>brk()</code></p>
</li>
<li><p>分配的内存大于 128 KB，使用 <code>mmap()</code></p>
</li>
</ul>
<p>不同的 glibc 版本定义的阈值也是不同的</p>
</blockquote>
<h2 id="free-是如何释放内存的"><a href="#free-是如何释放内存的" class="headerlink" title="free 是如何释放内存的"></a>free 是如何释放内存的</h2><p>如果 <code>malloc()</code> 是通过 <code>brk()</code> 方式申请的内存，不会把内存归还给操作系统，而是缓存在 malloc 的内存池中</p>
<p>如果 <code>malloc()</code> 是通过 <code>mmap()</code> 方式申请的内存，会把内存归还给操作系统，内存得到真正的释放</p>
<blockquote>
<p><code>brk()</code> 和 <code>mmap()</code> 都是系统调用，在申请内存时都需要进入内核态。又 <code>mmap()</code> 申请的内存在每次 <code>free</code> 时都会还给操作系统，在下次申请内存时需要重新进行一次系统调用，如果只使用 <code>mmap()</code> 来申请内存的话，CPU 的消耗较大；但如果只用 <code>brk()</code> 申请，由于内存会缓存在 <code>malloc</code> 的内存池中，而下次申请更大的内存时需要重新进行一次系统调用，而没有释放的内存造成了内存泄漏现象</p>
</blockquote>
<p>malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节，这 16 个字节保存的是该内存块的描述信息（如内存块大小），因此在执行 free 函数时，只需要将传入的内存地址左移 16 个字节，分析出该内存块的大小，则可以得知需要释放的内存大小</p>
<h2 id="物理内存是如何分配的"><a href="#物理内存是如何分配的" class="headerlink" title="物理内存是如何分配的"></a>物理内存是如何分配的</h2><p>当进程读写某块虚拟内存时，CPU 会访问这块虚拟内存，如果该虚拟内存没有映射到物理内存，则 CPU 会产生<strong>缺页中断</strong>，进程会从用户态切换到内核态，并将缺页中断交由缺页中断函数（Page Fault Handler）处理</p>
<p>1、如果有空闲的物理内存，直接分配，并建立虚拟内存和物理内存的映射关系</p>
<p>2、如果没有，则开始进行内存回收工作，有两种方式</p>
<ul>
<li><p>后台内存回收：唤醒 kswapd 内核线程来回收内存，<strong>异步的，不会阻塞进程</strong></p>
</li>
<li><p>直接内存回收：当后台异步回收跟不上进程内存申请的速度时则会开始直接回收，<strong>同步的，会阻塞进程</strong></p>
<blockquote>
<p>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会触发 OOM （Out of Memory）机制。OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</p>
</blockquote>
</li>
</ul>
<h2 id="哪些内存可以被回收"><a href="#哪些内存可以被回收" class="headerlink" title="哪些内存可以被回收"></a>哪些内存可以被回收</h2><p>文件页（File-backed Page）：如果文件页是干净页，则直接释放内存，否则（脏页）需要先写回磁盘后再释放内存</p>
<blockquote>
<p>内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Cache）都叫作文件页</p>
</blockquote>
<p>匿名页（Anonymous Page）：这部分内存没有实际载体，如堆、栈数据等，这部分内存很可能还要被再访问，不能直接释放内存，而是通过 Linux 的 Swap 机制，将不常访问的内存写到磁盘中，再释放这些内存，等下次访问时再重新读入内存</p>
<p>文件页和匿名页的回收都是基于 LRU 算法。LRU 回收算法实际上维护着 <code>active</code> 和 <code>inactive</code> 两个<strong>链表</strong>，越接近链表尾部，就表示内存页越不常访问</p>
<h2 id="如何保护一个进程不被-OOM-杀掉"><a href="#如何保护一个进程不被-OOM-杀掉" class="headerlink" title="如何保护一个进程不被 OOM 杀掉"></a>如何保护一个进程不被 OOM 杀掉</h2><p>当系统空闲的内存不能满足进程的申请时，系统会对内存进行回收，如果回收后的空闲内存依旧不能满足，则会触发 OOM 机制，内核就会根据算法选择进程杀死。选择的标准由 Linux 内核中的 <code>oom_bedness()</code> 函数决定，它会把系统中可以被杀掉的进程扫描一遍，并对每个进程打分，得分最高的进程就会被首先杀掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// points: 打分的结果</span></span><br><span class="line"><span class="comment">// process_pages: 进程已经使用的物理内存页面数</span></span><br><span class="line"><span class="comment">// oom_score_adj: OOM 校准值</span></span><br><span class="line"><span class="comment">// totalpages: 系统总的可用页面数</span></span><br><span class="line">points = process_pages + oom_score_adj * totalpages / <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>每个进程的 <code>oom_score_adj</code> 默认值都为 <code>0</code>，所以最终得分跟进程自身消耗的内存有关，消耗的内存越大越容易被杀掉。如果某个进程无论如何都不能被杀掉，可以将 <code>oom_score_adj</code> 配置为 <code>-1000</code></p>
<h2 id="在一个-4GB-物理内存的机器上申请-8GB-内存会怎么样"><a href="#在一个-4GB-物理内存的机器上申请-8GB-内存会怎么样" class="headerlink" title="在一个 4GB 物理内存的机器上申请 8GB 内存会怎么样"></a>在一个 4GB 物理内存的机器上申请 8GB 内存会怎么样</h2><p>如果是 32 位系统，进程理论上最多只能申请 3GB 大小的虚拟内存空间，会申请失败</p>
<p>如果是 64 位系统，进程理论上最多能申请 128TB 大小的虚拟内存空间，申请 8GB 内存是没有问题的。如果这块虚拟内存被访问了，而系统没有 Swap 分区，则进程会由于物理内存空间不足，出现 OOM，进程被杀掉；而如果有 Swap 分区，则进程可以正常运行（如果有足够的 Swap 空间进行页面替换）</p>
<h2 id="如何避免预读失效和缓存污染问题"><a href="#如何避免预读失效和缓存污染问题" class="headerlink" title="如何避免预读失效和缓存污染问题"></a>如何避免预读失效和缓存污染问题</h2><blockquote>
<p>Linux 的 Page Cache 和 MySQL Innodb 存储引擎的 Buffer Pool 起到缓存作用</p>
<p>传统的 LRU 算法无法避免<strong>预读失效和缓存污染</strong>导致缓存命中率下降的问题</p>
<p>预读机制指的是根据空间局部性原理，提前多读一些数据到缓存中，以便应对未来可能的访问</p>
<p>预读失效指的是预读进来的数据并没有被访问过，预读工作无效</p>
<p>缓存污染指的是系统将不常用的数据加载到缓存中，导致热点数据被挤出缓存，降低了缓存命中率</p>
</blockquote>
<p>Redis 没有预读机制，不会出现预读失效，而缓存淘汰算法则是通过实现 LFU 算法来避免缓存污染</p>
<p>为了避免预读失效，Linux 和 MySQL 对传统的 LRU 链表做了改进</p>
<ul>
<li><p>Linux 操作系统实现两个 LRU 链表：<code>active list</code> 和 <code>inactive list</code></p>
</li>
<li><p>MySQL Innodb 存储引擎是在一个 LRU 链表上划分 2 个区域：<code>young</code> 和 <code>old</code></p>
</li>
</ul>
<p>在进行预读时会将页面加到 <code>inactive list/old 区域</code>链表的头部，只有数据被访问了才会被加入到 <code>active list/young 区域</code>链表的头部</p>
<p>但这样依旧存在缓存污染问题，因此 Linux 和 MySQL Innodb 存储引擎分别提高了升级为热点数据的门槛</p>
<ul>
<li>Linux：在内存页被访问第二次时，才将页从 <code>inactive list</code> 升级到 <code>active list</code> 里</li>
<li>MySQL Innodb：在内存页被访问第二次时，需要根据页面停留在 <code>old 区域</code>的时间来判断是否升级到 <code>young 区域</code>（默认 1 秒内的停留时间不会升级）</li>
</ul>
<h2 id="内存页面置换算法"><a href="#内存页面置换算法" class="headerlink" title="内存页面置换算法"></a>内存页面置换算法</h2><blockquote>
<p>缺页中断与一般中断的主要区别</p>
<ul>
<li>缺页中断在指令执行<strong>期间</strong>产生和处理中断信号，而一般中断在一条指令执行<strong>完成</strong>后检查和处理中断信号</li>
<li>缺页中断返回到该指令的开始重新执行<strong>该指令</strong>，而一般中断返回回到该指令的<strong>下一个指令</strong>执行</li>
</ul>
</blockquote>
<p>页表项通常有以下几个字段</p>
<p><img src="/images/os/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%AD%97%E6%AE%B5.png" alt="页表项字段"></p>
<p>状态位：表示该页是否存在物理内存中</p>
<p>访问字段：记录该页在一段时间被访问的次数</p>
<p>修改位：表示该页在调入内存后是否有被修改过。内存存放的数据是磁盘数据的副本，如果没有修改，则在置换该页时不需要写回到磁盘中，减少系统开销；如果有修改过，则需要将该页重写到磁盘上，以保证磁盘中所保留的始终是最新的副本</p>
<p>硬盘地址：指出该页在硬盘上的地址，通常是物理块号，供调入该页时使用</p>
<h3 id="常见的页面置换算法"><a href="#常见的页面置换算法" class="headerlink" title="常见的页面置换算法"></a>常见的页面置换算法</h3><p>1、最佳页面置换算法（OPT）</p>
<p>2、先进先出置换算法（FIFO）</p>
<p>3、最近最久未使用置换算法（LRU）</p>
<p>4、时钟页面置换算法（Lock）：把所有页面维护在一个环形链表中，表指针指向最老的页面。当发生缺页中断时，算法首先先判断表指针指向的页面，如果该页面的访问位为 0 则淘汰该页面，并将指针前移一个位置；否则则清除访问位，并将指针前移一个位置，直到找到访问位为 0 的页面</p>
<p>5、最不常用置换算法（LFU）</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>磁盘通常有多个盘片，每个盘片都有自己的磁头</p>
<p>每个盘片分为多个磁道，每个磁道分为多个扇区，每个扇区是 512 字节</p>
<p>多个具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面</p>
<p>寻道时间是磁盘访问最耗时的部分</p>
<h3 id="常见的磁盘调度算法"><a href="#常见的磁盘调度算法" class="headerlink" title="常见的磁盘调度算法"></a>常见的磁盘调度算法</h3><p>1、先来先服务算法</p>
<p>2、最短寻道时间优先算法：可能会出现饥饿现象（即磁头只在一小块区域里来回移动）</p>
<p>3、扫描算法：磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上最后的磁道，才调换方向</p>
<p>4、循环扫描算法：只响应某个特定方向上的请求。复位磁头时（快速移动至最靠边缘的磁道）不处理任何请求</p>
<p>5、LOOK：扫描算法的优化，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中会响应请求</strong></p>
<p>6、C-LOOK 算法：循环扫描算法的优化，磁头在每个方向上仅仅移动到最远的请求位置，然后立即反向移动，而不需要移动到磁盘的最始端或最末端，<strong>反向移动的途中不会响应请求</strong></p>
<h2 id="内核如何管理进程虚拟内存空间"><a href="#内核如何管理进程虚拟内存空间" class="headerlink" title="内核如何管理进程虚拟内存空间"></a>内核如何管理进程虚拟内存空间</h2><p>内核通过 <code>task_struct</code> 结构描述进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;                  <span class="comment">// 进程 id</span></span><br><span class="line">    <span class="type">pid_t</span> tgid;                 <span class="comment">// 用于标识线程所属的进程 pid</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">// 进程打开的文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>       <span class="comment">// 每个进程唯一的内存描述符，用于表示进程的虚拟地址空间</span></span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们调用 <code>fork()</code> 函数创建进程时，表示进程地址空间的 <code>mm_struct</code> 结构会随着进程描述符 <code>task_struct</code> 的创建而创建</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> _do_fork(</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span><br><span class="line">    <span class="type">int</span> __user *parent_tidptr,</span><br><span class="line">    <span class="type">int</span> __user *child_tidptr,</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pid</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">    <span class="comment">// 创建 task_struct 结构</span></span><br><span class="line">    p = copy_process(clone_flags, stack_start, stack_size, child_tidptr, <span class="literal">NULL</span>, trace, tls, NUMA_NO_NODE);</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用 <code>copy_process</code> 函数创建 <code>task_struct</code> 结构，用父进程的资源填充。可以看出<strong>子进程的虚拟内存空间和父进程的虚拟内存空间一样</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __latent_entropy <span class="keyword">struct</span> task_struct *<span class="title function_">copy_process</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> clone_flags,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> stack_start,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> stack_size,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> __user *child_tidptr,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> pid *pid,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> trace,</span></span><br><span class="line"><span class="params">    <span class="type">unsigned</span> <span class="type">long</span> tls,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">    p = dup_task_struct(current, node); <span class="comment">// 创建 task_struct 结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化子进程*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承拷贝父进程资源</span></span><br><span class="line">    retval = copy_files(clone_flags, p);      <span class="comment">// 父进程打开的文件描述符</span></span><br><span class="line">    retval = copy_fs(clone_flags, p);         <span class="comment">// 父进程所属的文件系统</span></span><br><span class="line">    retval = copy_sighand(clone_flags, p);    <span class="comment">// 父进程注册的信号处理函数</span></span><br><span class="line">    retval = copy_signal(clone_flags, p);     <span class="comment">// 父进程注册的信号</span></span><br><span class="line">    retval = copy_mm(clone_flags, p);         <span class="comment">// 父进程的虚拟内存空间</span></span><br><span class="line">    retval = copy_namespaces(clone_flags, p); <span class="comment">// 父进程的 namespaces</span></span><br><span class="line">    retval = copy_io(clone_flags, p);         <span class="comment">// 父进程的 IO 信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line"></span><br><span class="line">    retval = sched_fork(clone_flags, p);              <span class="comment">// 分配 CPU</span></span><br><span class="line">    pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns_for_children); <span class="comment">// 分配 pid</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成子进程虚拟内存空间的 <code>mm_struct</code> 结构的创建和初始化。如果通过 <code>vfork</code> 或者 <code>clone</code> 系统调用创建出的子进程，则子进程的虚拟内存空间由父进程直接赋值，即父子进程共享虚拟内存空间，相当于线程。</p>
<blockquote>
<p>是否共享地址空间几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span> <span class="comment">// 子进程、父进程的虚拟内存空间</span></span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line"></span><br><span class="line">    tsk-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    tsk-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">    oldmm = current-&gt;mm; <span class="comment">// 获取父进程虚拟内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (!oldmm)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 vfork 或者 clone 系统调用创建出的子进程（线程）和父进程共享虚拟内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_VM)</span><br><span class="line">    &#123;</span><br><span class="line">        mmget(oldmm); <span class="comment">// 增加父进程虚拟地址空间的引用计数</span></span><br><span class="line">        mm = oldmm;   <span class="comment">// 直接将父进程的虚拟内存空间赋值给子进程（线程）, 线程共享其所属进程的虚拟内存空间</span></span><br><span class="line">        <span class="keyword">goto</span> good_mm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    <span class="comment">// 如果是 fork 系统调用创建出的子进程，则将父进程的虚拟内存空间以及相关页表拷贝到子进程中的 mm_struct 结构中。</span></span><br><span class="line">    mm = dup_mm(tsk);</span><br><span class="line">    <span class="keyword">if</span> (!mm)</span><br><span class="line">        <span class="keyword">goto</span> fail_nomem;</span><br><span class="line"></span><br><span class="line">good_mm:</span><br><span class="line">    tsk-&gt;mm = mm; <span class="comment">// 将拷贝出来的父进程虚拟内存空间 mm_struct 赋值给子进程</span></span><br><span class="line">    tsk-&gt;active_mm = mm;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核线程和用户态线程的区别就是<strong>内核线程没有相关的内存描述符 <code>mm_struct</code></strong> ，内核线程对应的 <code>task_struct</code> 结构中的 <code>mm_struct</code> 指向 <code>Null</code>，所以<strong>内核线程之间调度是不涉及地址空间切换</strong>的。</p>
<p>当一个内核线程被调度时，它会发现自己的虚拟地址空间为 <code>Null</code>，内核线程<strong>只会访问内核内存</strong>，因此内核可以<strong>将调度之前的上一个用户态进程的虚拟内存空间 <code>mm_struct</code> 直接赋值给内核线程进行复用</strong>，避免<strong>为内核线程分配 <code>mm_struct</code> 和相关页表的开销</strong>以及<strong>内核线程之间调度时地址空间的切换开销</strong>。</p>
<p>可以发现，父子进程的区别、进程与线程的区别，以及内核线程与用户态线程的区别都是围绕 <code>mm_struct</code> 展开的</p>
<h3 id="内核如何划分用户态和内核态虚拟内存空间"><a href="#内核如何划分用户态和内核态虚拟内存空间" class="headerlink" title="内核如何划分用户态和内核态虚拟内存空间"></a>内核如何划分用户态和内核态虚拟内存空间</h3><p>在进程的内存描述符 <code>mm_struct</code> 中，有一个 <code>task_size</code> 变量，用于定义用户态地址空间和内核态地址空间之间的分界线。默认情况下，32 位系统的分界线为 <code>0xC000 0000</code>，而 64 位系统的分界线为 <code>0x0000 7FFF FFFF F000</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> task_size;</span><br><span class="line">    <span class="comment">// 代码段的起始位置和结束位置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code;</span><br><span class="line">    <span class="comment">// 数据段的起始位置和结束位置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_data, end_data;</span><br><span class="line">    <span class="comment">// 堆的起始位置、堆当前的结束位置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk;</span><br><span class="line">	<span class="comment">// 内存映射区的起始地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mmap_base;</span><br><span class="line">    <span class="comment">// 栈的起始位置，在 RBP 寄存器中存储。栈的结束位置（栈顶指针 stack pointer）在 RSP 寄存器中存储</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_stack;</span><br><span class="line">    <span class="comment">// 参数列表和环境变量的位置，位于栈中的最高地址处</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="comment">// 进程虚拟内存空间中总共与物理内存映射的页的总数（只代表建立关联关系，不一定分配了内存）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm;</span><br><span class="line">    <span class="comment">// 被锁定不能换出的内存页总数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> locked_vm;</span><br><span class="line">    <span class="comment">// 既不能换出，也不能移动的内存页总数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> pinned_vm;</span><br><span class="line">    <span class="comment">// 数据段中映射的内存页数目</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data_vm;</span><br><span class="line">    <span class="comment">// 代码段中存放可执行文件的内存页数目</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> exec_vm;</span><br><span class="line">    <span class="comment">// 栈中所映射的内存页数目</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> stack_vm;</span><br><span class="line">    <span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="内核如何管理虚拟内存区域"><a href="#内核如何管理虚拟内存区域" class="headerlink" title="内核如何管理虚拟内存区域"></a>内核如何管理虚拟内存区域</h3><p>内核通过 <code>vm_area_struct</code> 结构体描述虚拟内存区域（VMA，virtual memory area）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 分别指向 VMA 节点所在双向链表中的后继节点和前驱节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span></span><br><span class="line">    <span class="comment">// 红黑树中的节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> </span><br><span class="line">	<span class="comment">// 归属的进程描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span></span><br><span class="line">    <span class="comment">// 虚拟内存区域的起始地址（最低地址），vm_start 本身包含在这块虚拟内存区域内</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_start;</span><br><span class="line">    <span class="comment">// 虚拟内存区域的结束地址（最高地址），vm_end 本身包含在这块虚拟内存区域之外</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_end;</span><br><span class="line">	<span class="comment">// 虚拟内存区域的访问权限和行为规范</span></span><br><span class="line">	<span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_flags;	</span><br><span class="line">	<span class="comment">// 匿名映射，映射到物理内存上</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span></span><br><span class="line">    <span class="comment">// 文件映射，可以为空</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span></span><br><span class="line">    <span class="comment">// 映射进虚拟内存中的文件内容，在文件中的偏移</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;</span><br><span class="line">    <span class="comment">// 用于存储 VMA 中的私有数据</span></span><br><span class="line">	<span class="type">void</span> * vm_private_data;</span><br><span class="line">	<span class="comment">// 用来指向针对虚拟内存区域 VMA 的相关操作的函数指针</span></span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当指定的虚拟内存区域被加入到进程虚拟内存空间中时调用</span></span><br><span class="line">	<span class="type">void</span> (*open)(<span class="keyword">struct</span> vm_area_struct * area);</span><br><span class="line">    <span class="comment">// 当虚拟内存区域 VMA 从进程虚拟内存空间中被删除时调用</span></span><br><span class="line">	<span class="type">void</span> (*close)(<span class="keyword">struct</span> vm_area_struct * area);</span><br><span class="line">    <span class="comment">// 缺页异常时调用</span></span><br><span class="line">    <span class="type">vm_fault_t</span> (*fault)(<span class="keyword">struct</span> vm_fault *vmf);</span><br><span class="line">    <span class="comment">// 当一个只读的页面将要变为可写时调用</span></span><br><span class="line">    <span class="type">vm_fault_t</span> (*page_mkwrite)(<span class="keyword">struct</span> vm_fault *vmf);</span><br><span class="line">	<span class="comment">/*省略*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程的状态有哪些"><a href="#进程的状态有哪些" class="headerlink" title="进程的状态有哪些"></a>进程的状态有哪些</h2><img src="/images/os/进程的七种状态.jpg" alt="进程的七种状态" style="zoom:50%;" />

<h3 id="导致进程挂起的原因有哪些"><a href="#导致进程挂起的原因有哪些" class="headerlink" title="导致进程挂起的原因有哪些"></a>导致进程挂起的原因有哪些</h3><p>1、内存空间不足，操作系统暂停某些进程并替换到硬盘中以释放内存空间</p>
<p>2、定时任务，比如通过 <code>sleep</code> 让进程间歇性挂起</p>
<p>3、用户希望挂起一个程序的执行，比如在 Linux 中用 <code>Ctrl+Z</code> 挂起进程</p>
<h2 id="进程控制块包含哪些内容"><a href="#进程控制块包含哪些内容" class="headerlink" title="进程控制块包含哪些内容"></a>进程控制块包含哪些内容</h2><blockquote>
<p>进程控制块（Process Control Block，PCB），描述进程存在的唯一标识</p>
</blockquote>
<p>进程描述信息（进程标识符、用户标识符等）</p>
<p>进程控制和管理信息（进程当前状态、进程优先级等）</p>
<p>资源分配清单（有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息）</p>
<p>CPU 相关信息（CPU 中各个寄存器的值等）</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是进程当中的一条执行流程</p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，以确保线程的控制流是相对独立的</p>
<h2 id="进程与线程的差异"><a href="#进程与线程的差异" class="headerlink" title="进程与线程的差异"></a>进程与线程的差异</h2><p>1、进程是资源分配的单位，线程是 CPU 调度的单位</p>
<p>2、进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈</p>
<p>3、线程相比进程能减少并发执行的空间和时间开销</p>
<ul>
<li>线程的创建比进程快，进程需要资源管理信息，而线程是直接共享</li>
<li>线程的销毁比进程快，线程需要释放的资源相比进程少很多</li>
<li>同一个进程内的线程切换比进程切换快，因为同一个进程的线程共享同一个虚拟内存地址空间，在切换是不需要切换页表，而进程需要切换页表</li>
<li>同一个进程的线程在数据传递时，不需要经过内核</li>
</ul>
<h2 id="孤儿进程-VS-僵尸进程"><a href="#孤儿进程-VS-僵尸进程" class="headerlink" title="孤儿进程 VS. 僵尸进程"></a>孤儿进程 VS. 僵尸进程</h2><p>在 Linux 环境中，通过 <code>fork</code> 函数来创建子进程。创建完毕后，父子进程独立运行，父进程无法预知子进程什么时候结束。通常情况下，子进程退出后，父进程会使用 wait 或 waitpid 函数回收子进程资源，并获得子进程的终止状态。但如果父进程先于子进程结束，则子进程成为了<strong>孤儿进程</strong>，孤儿进程被 init 进程（进程号为 1）领养，并由 init 进程对孤儿进程完成状态收集工作。而如果子进程先于父进程退出，同时父进程太忙了，无瑕回收子进程的资源，子进程残留资源（PCB）存放于内核中，变成<strong>僵尸进程</strong></p>
<h2 id="线程有哪几种实现方式"><a href="#线程有哪几种实现方式" class="headerlink" title="线程有哪几种实现方式"></a>线程有哪几种实现方式</h2><p>1、用户线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理</p>
<p>2、内核线程：在内核中实现的线程，是由内核管理的线程</p>
<p>3、轻量级进程：在内核中来支持用户线程</p>
<blockquote>
<p>用户线程和内核线程的对应关系有：一对一、多对一和多对多</p>
</blockquote>
<h3 id="用户线程的优缺点"><a href="#用户线程的优缺点" class="headerlink" title="用户线程的优缺点"></a>用户线程的优缺点</h3><blockquote>
<p>用户线程的线程控制块（TCB）也是由用户态的线程库实现的，操作系统是看不到这个 TCB 的，只能看到进程的 PCB，因此用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等</p>
</blockquote>
<p>优点</p>
<p>1、每个进程都需要有一个私有的 TCB 列表，用于跟踪记录各个线程的状态信息，TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统</p>
<p>2、用户线程的切换由线程库函数来完成的，无需用户态与内核态的切换，速度快</p>
<p>缺点</p>
<p>1、由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行</p>
<p>2、当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行（用户态的线程没有权利打断当前运行中的线程，只有操作系统有，但用户线程不是由操作系统管理的）</p>
<p>3、由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢</p>
<h3 id="内核线程的优缺点"><a href="#内核线程的优缺点" class="headerlink" title="内核线程的优缺点"></a>内核线程的优缺点</h3><blockquote>
<p>内核线程是由操作系统管理的，对应的 TCB 是放在操作系统里</p>
</blockquote>
<p>优点</p>
<p>1、在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行</p>
<p>2、时间片分配给线程，多线程的进程获得更多的 CPU 运行时间</p>
<p>缺点</p>
<p>1、在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB</p>
<p>2、线程的创建、终止和切换都是通过系统调用的方式来进行，对于系统来说，系统开销比较大</p>
<h3 id="轻量级进程的优缺点"><a href="#轻量级进程的优缺点" class="headerlink" title="轻量级进程的优缺点"></a>轻量级进程的优缺点</h3><blockquote>
<p>轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，由内核管理并像普通进程一样被调度</p>
<p>在大多数系统中，LWP 与普通进程的区别也在于它只有一个最小的执行上下文和调度程序所需的统计信息。一般来说，一个进程代表程序的一个实例，而 LWP 代表程序的执行线程</p>
</blockquote>
<p>LWP 与用户线程的对应关系有：一对一、一对多和多对多</p>
<h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><blockquote>
<p>一个线程对应到一个 LWP 再对应到一个内核线程</p>
</blockquote>
<p>优点：实现并行，当一个 LWP 阻塞，不会影响其他 LWP</p>
<p>缺点：每一个用户线程，就产生一个内核线程，创建线程的开销较大</p>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><blockquote>
<p>多个用户线程对应一个 LWP 再对应一个内核线程</p>
</blockquote>
<p>优点：可以开辟多个用户线程，且上下文切换发生用户空间，切换的效率较高</p>
<p>缺点：如果一个用户线程阻塞，则整个进程都将会阻塞，另外在多核 CPU 中，是没办法充分利用 CPU 的</p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><blockquote>
<p>多个用户线程对应到多个 LWP，LWP 再一一对应到内核线程</p>
</blockquote>
<p>优点：综合了前两种优点，大部分的线程上下文发生在用户空间，且多个线程又可以充分利用多核 CPU 的资源</p>
<h2 id="处理机调度层次"><a href="#处理机调度层次" class="headerlink" title="处理机调度层次"></a>处理机调度层次</h2><h3 id="高级调度（作业调度、长程调度）"><a href="#高级调度（作业调度、长程调度）" class="headerlink" title="高级调度（作业调度、长程调度）"></a>高级调度（作业调度、长程调度）</h3><p>调度对象是<strong>作业</strong>，调度周期最长</p>
<p>根据某种算法把<strong>外存</strong>上处于<strong>后备队列</strong>中的作业调入<strong>内存</strong>，为其创建进程并分配必要的资源</p>
<p>每个作业只调入一次，调出一次</p>
<h3 id="中级调度（中程调度）"><a href="#中级调度（中程调度）" class="headerlink" title="中级调度（中程调度）"></a>中级调度（中程调度）</h3><p>调度对象是<strong>进程（内核级线程）</strong>，调度周期介于高级调度和低级调度之间</p>
<p>目的是为了提高内存利用率和系统吞吐量，将暂时不能允许的进程调至外存上等待，此时进程的状态为挂起状态</p>
<p>当这类进程重新具备运行条件或者内存稍有空闲时，会被重新调入内存，进入就绪状态</p>
<h3 id="低级调度（进程调度、短程调度）"><a href="#低级调度（进程调度、短程调度）" class="headerlink" title="低级调度（进程调度、短程调度）"></a>低级调度（进程调度、短程调度）</h3><p>调度对象是<strong>进程（内核级线程）</strong>，调度周期最短</p>
<p>为就绪队列中的某个进程分配处理机，使其能够开始运行</p>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><blockquote>
<p>线程是操作系统的调度单位，这里的进程指的是只有主线程的进程，调度主线程相当于调度了整个进程</p>
</blockquote>
<h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><p>在进程的生命周期中，当进程从一个运行状态到另外一状态变化时，会触发一次调度</p>
<p>如果根据硬件时钟提供的某个频率的周期性中断，调度算法可以分为<strong>非抢占式调度算法</strong>和<strong>抢占式调度算法</strong></p>
<blockquote>
<p>抢占式调度算法挑选一个进程，让该进程只运行某段时间，如果在该时段结束时，该进程仍在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制。</p>
</blockquote>
<h3 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h3><p>调度的目的是为了让进程执行得更快</p>
<p>1、<strong>提高 CPU 利用率</strong>：调度程序应确保 CPU 始终保持匆忙状态（比如一个进程在等待某个 IO 事件的完成，此时 CPU 是处于空闲状态的，调度程序需要从就绪队列中选择一个进程运行）</p>
<p>2、<strong>提高吞吐量</strong>：吞吐量表示的是单位时间内 CPU 完成进程的数量，调度程序需要权衡长作业和短作业</p>
<p>3、<strong>减少周转时间</strong>：周转时间 &#x3D; 进程运行时间 + 进程阻塞时间 + 进程等待时间</p>
<p>4、<strong>减少等待时间</strong>：进程处于就绪队列的时间</p>
<p>5、<strong>提高响应时间</strong>：用户提交请求到系统第一次产生响应所花费的时间</p>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><blockquote>
<p>调度的目的是为了让进程执行得更快，根据这点来判断调度算法是适用于 CPU 繁忙型作业的系统还是 I&#x2F;O 繁忙型作业的系统</p>
</blockquote>
<p>1、<strong>先来先服务</strong>（First Come First Serve, FCFS）</p>
<p>对长作业有利，适用于 CPU 繁忙型作业的系统</p>
<p>2、<strong>最短作业优先</strong>（Shortest Job First, SJF）</p>
<p>对长作业不利</p>
<p>3、<strong>高响应比优先</strong> （Highest Response Ratio Next, HRRN）<br>$$<br>\text{优先权} &#x3D; \frac{\text{等待时间 + 要求服务时间}}{\text{要求服务时间}}<br>$$<br>权衡了短作业和长作业。但这种算法是理想型的调度算法（要求服务时间是不可预估的）</p>
<p>4、<strong>时间片轮转</strong>（Round Robin, RR）</p>
<p>最古老、最简单、最公平且使用最广的算法。每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行</p>
<p>时间片一般为 <code>20~50 ms</code>，过短会造成大量上下文切换，过长会退化成 FCFS 算法</p>
<p>5、<strong>最高优先级</strong>（Highest Priority First，HPF）</p>
<p>从就绪队列中选择最高优先级的进程进行运行</p>
<p>进程的优先级可以分为<strong>静态优先级</strong>和<strong>动态优先级</strong></p>
<ul>
<li>静态优先级：优先级在进程创建时就已经确定</li>
<li>动态优先级：根据进程的动态变化调整优先级</li>
</ul>
<p>该算法也有两种处理优先级高的方法，非抢占式和抢占式</p>
<ul>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行</li>
</ul>
<p>6、<strong>多级反馈队列</strong>（Multilevel Feedback Queue）</p>
<p><strong>时间片轮转</strong>算法和<strong>最高优先级</strong>算法的综合</p>
<p>「多级」表示有多个队列，每个队列优先级从高到低，同时<strong>优先级越高时间片越短</strong></p>
<p>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列</p>
<p>如果进程在上一级队列固规定的时间片里没运行完成，则会放入下一级队列的末尾</p>
<h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><blockquote>
<p>每个进程的用户地址空间都是独立的，一般而言是不能互相访问的，但内核空间是每个进程都共享的，所以进程之间要通信必须通过内核</p>
</blockquote>
<h3 id="常规状态下"><a href="#常规状态下" class="headerlink" title="常规状态下"></a>常规状态下</h3><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道就是内核里的一串缓存，管道传输的数据是无格式的流且大小受限</p>
<p>传输数据是<strong>单向的</strong>，遵循<strong>先进先出</strong>原则</p>
<p>管道的通信效率低，不适合进程间频繁地交换数据</p>
<p>管道可以分为<strong>匿名管道</strong>和<strong>命名管道</strong>两种</p>
<p>1、匿名管道</p>
<blockquote>
<p>特殊的文件，只存在于内存，不存于文件系统中。常见使用方式：<code>ps -ef | grep mysql</code></p>
</blockquote>
<p>通信范围是存在父子关系的进程，用完就销毁</p>
<p>匿名管道通过调用系统调用 <code>int pipe(int fd[2])</code> 创建，返回两个描述符（读取端描述符 <code>fd[0]</code> 和写入端描述符 <code>fd[1]</code>）</p>
<p>创建子进程时会复制父进程的文件描述符，即两个进程都各自拥有读取端和写入端描述符，通过写入或读取同一个管道文件实现跨进程通信</p>
<p>2、命名管道</p>
<p>提前创建了一个<strong>类型为管道</strong>的设备文件，可以在不相关的进程间也能相互通信</p>
<p>通过 <code>mkfifo</code> 创建，如 <code>mkfifo myPipe</code></p>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列是<strong>保存在内核中</strong>的消息链表。数据会按照双方约定好的数据类型生成固定大小的消息体，消息体被进程读取后会被内核删除</p>
<p>消息队列的生命周期随内核，如果<strong>没有释放消息队列或没有关闭操作系统</strong>，消息队列会一直存在</p>
<p>消息队列<strong>不适合大数据的传输</strong>，且存在<strong>用户态与内核态之间的数据拷贝开销</strong></p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>拿出一块虚拟地址空间来，映射到相同的物理内存里</p>
<p>这种方式容易在多个进程同时进行读写操作时产生冲突现象</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量其实是一个<strong>整型的计数器</strong>，主要用于实现<strong>进程间的互斥与同步</strong>，而不是用于缓存进程间通信的数据</p>
<p>信号量表示资源的数量，控制信号量的方式有两种原子操作</p>
<ul>
<li>P 操作：把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行</li>
<li>V 操作：把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程</li>
</ul>
<h3 id="异常情况下"><a href="#异常情况下" class="headerlink" title="异常情况下"></a>异常情况下</h3><h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><ul>
<li>可以通过 <code>kill -l</code> 命令，查看所有的信号</li>
<li>可以通过键盘输入某些组合键的时候，给进程发送信号<ul>
<li><code>Ctrl+C</code> 产生 <code>SIGINT</code> 信号，表示终止该进程</li>
<li><code>Ctrl+Z</code> 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束</li>
</ul>
</li>
<li>信号是进程间通信机制中唯一的异步通信机制</li>
<li>用户进程对信号的处理方式<ul>
<li>执行默认操作：Linux 对每种信号都规定了默认操作</li>
<li>捕捉信号：可以为信号定义一个信号处理函数。当信号发生时就执行相应的信号处理函数</li>
<li>忽略信号：有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程</li>
</ul>
</li>
</ul>
<h3 id="跨网络-主机通信"><a href="#跨网络-主机通信" class="headerlink" title="跨网络&#x2F;主机通信"></a>跨网络&#x2F;主机通信</h3><h4 id="Socket（套接字）"><a href="#Socket（套接字）" class="headerlink" title="Socket（套接字）"></a>Socket（套接字）</h4><p>创建 Socket 的系统调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocal)</span>;</span><br><span class="line"><span class="comment">// domain: 指定协议族，比如 AF_INET 用于 IPV4; AF_INET6 用于 IPV6; AF_LOCAL/AF_UNIX 用于本机</span></span><br><span class="line"><span class="comment">// type：指定通信特性，SOCK_STREAM 表示的是字节流，对应 TCP; SOCK_DGRAM 表示的是数据报，对应 UDP; SOCK_RAW 表示的是原始套接字</span></span><br><span class="line"><span class="comment">// protocal：指定通信协议，现在基本废弃，一般写成 0 即可</span></span><br></pre></td></tr></table></figure>

<p>TCP 协议通信的 socket 编程模型</p>
<blockquote>
<p>监听的 socket 和真正用来传送数据的 socket，是两个 socket，分别叫作：<strong>监听 socket</strong> 和<strong>已完成连接 socket</strong></p>
</blockquote>
<img src="/images/os/TCP协议通信的Socket编程模型.png" alt="image-20240108192924289" style="zoom:50%;" />

<p>UDP 协议通信的 socket 编程模型</p>
<img src="/images/os/UDP协议通信的Socket编程模型.jpg" alt="img" style="zoom:50%;" />



<h2 id="多线程冲突"><a href="#多线程冲突" class="headerlink" title="多线程冲突"></a>多线程冲突</h2><blockquote>
<p>临界资源：共享资源</p>
<p>临界区：访问临界资源的代码片段</p>
<p>进入区：临界区前面增加的一段<strong>用于进行临界资源检查的代码</strong></p>
<p>退出区：临界区后面增加的一段<strong>用于恢复临界资源状态的代码</strong></p>
<p>剩余区：除了进入区、临界区、退出区之外的代码</p>
</blockquote>
<p>限制一次仅允许一个进程进入临界区，能够解决冲突问题；为了防止饥饿现象的发生，需要限制进程进入临界区的时间，并且如果进程无法进入临界区，应该让出 CPU</p>
<p>在进程&#x2F;线程并发执行过程中，进程&#x2F;线程之间存在协作关系，如同步、互斥</p>
<ul>
<li>同步：并发进程&#x2F;线程在一些关键点上需要互相等待与互通消息</li>
<li>互斥：并发进程&#x2F;线程不能同一时刻执行</li>
</ul>
<p>进程&#x2F;线程之间的同步&#x2F;互斥主要通过<strong>锁</strong>或<strong>信号量（PV 操作）</strong>实现</p>
<p>根据锁的实现方式，可以分为<strong>忙等待锁（自旋锁）</strong>和<strong>无忙等待锁</strong></p>
<ul>
<li>忙等待锁：也叫自旋锁，即在获取不到锁时，进程&#x2F;线程会一直循环等待</li>
<li>无忙等待锁：当没获取到锁时，把当前进程&#x2F;线程放入到锁的等待队列，然后执行调度程序，让出 CPU</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或者两个以上的进程在执行过程中，由于资源竞争而造成相互等待的情况，如果没有外力作用，它们均无法正常推进，此时称系统处于死锁状态</p>
<blockquote>
<p>活锁：某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取</p>
</blockquote>
<h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><ul>
<li>互斥：每个资源在任一时刻只能被一个进程所占用</li>
<li>持有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不可剥夺：进程已获得的资源，在没有使用完之前，不能被其他进程抢占</li>
<li>循环等待：若干个进程形成了一种头尾相接的循环等待资源关系链</li>
</ul>
<h3 id="如何处理死锁问题"><a href="#如何处理死锁问题" class="headerlink" title="如何处理死锁问题"></a>如何处理死锁问题</h3><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><p>破坏四个条件中任意一个</p>
<ul>
<li>破坏资源互斥条件</li>
<li>破坏占有且等待条件：实行资源预分配策略，进程在运行之前，必须一次性获取所有的资源。缺点：在很多情况下，无法预知进程执行前所需的全部资源，因为进程是动态执行的，同时也会降低资源利用率，导致降低了进程的并发性</li>
<li>破坏不可剥夺条件：允许进程强行从占有者那里夺取某些资源。当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着进程已经占有的资源会被暂时被释放，或者说被抢占了</li>
<li>破坏循环等待条件：实行资源有序分配策略，对所有资源排序编号，按照顺序获取资源，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><ul>
<li>死锁预防通过约束资源请求，防止4个必要条件中至少一个的发生，可以通过直接或间接预防方法，但是都会导致低效的资源使用和低效的进程执行</li>
<li>死锁避免是允许前三个条件，但需要动态检测资源分配状态，保证循环等待条件不成立，确保系统处于安全状态（系统能按某个顺序为每个进程分配资源（不超过其最大值）），比如银行家算法</li>
</ul>
<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>死锁避免策略是十分保守的，通过限制访问资源和在进程上强加约束来解决死锁的问题</p>
<p>死锁检测则是相反的，它不限制资源访问或约束进程行为，只要有可能，被请求的资源就被授权给进程。但系统会周期性地检测是否出现循环等待（判断是否存在环）</p>
<ul>
<li>如果进程资源分配图中无环路，说明没有死锁</li>
<li>如果进程资源分配图中有环路，且每个资源类中只有一个资源，则系统发生死锁</li>
<li>如果进程资源分配图中有环路，且所涉及的资源类有多个资源，则不一定会发生死锁</li>
</ul>
<h4 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h4><p>常用方法就是终止进程和资源抢占</p>
<ul>
<li><p>终止进程：有两种终止方式：1）终止所有死锁进程；2）一次只终止一个进程，直到死锁循环解除为止</p>
</li>
<li><p>资源抢占：从一个或者多个死锁进程那里抢占一个或多个资源</p>
</li>
</ul>
<h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><p>假装没发生死锁</p>
<h2 id="一个进程最多可以创建多少个线程"><a href="#一个进程最多可以创建多少个线程" class="headerlink" title="一个进程最多可以创建多少个线程"></a>一个进程最多可以创建多少个线程</h2><p>32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程</p>
<p>64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制</p>
<h2 id="线程崩溃了会导致进程崩溃吗"><a href="#线程崩溃了会导致进程崩溃吗" class="headerlink" title="线程崩溃了会导致进程崩溃吗"></a>线程崩溃了会导致进程崩溃吗</h2><p>一般情况下，操作系统为了保证系统安全，针对非法内存访问会发送一个 SIGSEGV 信号，而操作系统一般会调用默认的信号处理函数（即一般会让相关进程崩溃）</p>
<p>但进程也可以选择定义一个信号处理函数，捕获并处理这类信号，这种情况下进程是不会跟着崩溃的</p>
<blockquote>
<p>SIGKILL 和 SIGSTOP 不能被捕获</p>
</blockquote>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><blockquote>
<p>文件系统是操作系统中负责管理持久数据的子系统。在 Linux 中，一切皆文件，无论是普通的文件和目录，还是块设备、管道、socket 等，都统一交给文件系统管理</p>
</blockquote>
<p>Linux 系统为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry）</p>
<ul>
<li><p>索引节点：即 inode，<strong>用于记录文件的元信息</strong>（inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等）。索引节点是文件的<strong>唯一标识</strong>，与文件一一对应，存储在硬盘中，<strong>会占用磁盘空间</strong></p>
</li>
<li><p>目录项：即 dentry，<strong>用于记录文件名称、索引节点指针以及与其他目录项的层次关联关系</strong>。多个目录项关联起来，会形成目录结构。<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong></p>
</li>
</ul>
<blockquote>
<p>目录项和索引节点的关系是多对一，即一个文件可以有多个别名。比如硬链接的实现就是多个目录项中的索引节点指向同一个文件</p>
<p>目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件</p>
</blockquote>
<h2 id="文件数据是如何存储在磁盘里的"><a href="#文件数据是如何存储在磁盘里的" class="headerlink" title="文件数据是如何存储在磁盘里的"></a>文件数据是如何存储在磁盘里的</h2><p>磁盘读写的最小单位是<strong>扇区</strong>，扇区的大小只有 <code>512B</code>。为了提高读写效率，文件系统<strong>把多个扇区组成了一个逻辑块</strong>，每次读写的最小单位就是逻辑块（数据块）</p>
<blockquote>
<p>Linux 中的逻辑块大小为 4KB，即一次性读写 8 个扇区</p>
</blockquote>
<p>磁盘进行格式化时，会被分成三个存储区域</p>
<ul>
<li>超级块：用来存储文件系统的详细信息，比如块个数、块大小、空闲块等</li>
<li>索引节点区，用来存储索引节点</li>
<li>数据块区，用来存储文件或目录数据</li>
</ul>
<p>这三个存储区域加载进内存的时机</p>
<ul>
<li>超级块：当文件系统挂载时进入内存</li>
<li>索引节点区：当文件被访问时进入内存</li>
</ul>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>用户层和文件系统层的中间层，操作系统给用户提供的统一接口，方便使用不同种类的文件系统</p>
<p>在 Linux 文件系统中，用户空间、系统调用、虚拟文件系统、缓存、文件系统以及存储之间的关系图</p>
<img src="/images/os/虚拟文件系统.png" alt="虚拟文件系统" style="zoom:50%;" />

<p>根据存储位置的不同可以将 Linux 支持的文件系统分为三类</p>
<ul>
<li>磁盘的文件系统：数据存储在磁盘中，比如 Ext 2&#x2F;3&#x2F;4、XFS 等</li>
<li>内存的文件系统：数据存储在物理内存，比如 <code>/proc</code> 和 <code>/sys</code>，读写这类文件，实际上是读写内核中相关的数据</li>
<li>网络的文件系统：用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等</li>
</ul>
<p>文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>操作系统维护一个打开文件表，用于跟踪进程打开的所有文件。文件表里的每一项代表文件描述符，包含打开文件的状态和信息</p>
<ul>
<li>文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的</li>
<li>文件打开计数器：跟踪打开某个文件的进程数量。文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，因此只有计数为 0 时，系统才能关闭文件，删除该条目</li>
<li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取</li>
<li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I&#x2F;O 请求</li>
</ul>
<h2 id="文件的存储方式"><a href="#文件的存储方式" class="headerlink" title="文件的存储方式"></a>文件的存储方式</h2><h3 id="连续空间存储方式"><a href="#连续空间存储方式" class="headerlink" title="连续空间存储方式"></a>连续空间存储方式</h3><p>这种模式下，文件的数据都是紧密相连，<strong>读写效率很高</strong>，因为一次磁盘寻道就可以读出整个文件。</p>
<p>使用连续存放的方式需要提前知道文件的大小，这样文件系统才会根据文件大小在磁盘上找到一块连续的空间分配给文件，因此，文件头（如 Linux 的 inode）里需要指定<strong>起始块位置</strong>和<strong>长度</strong></p>
<p>但这种方式也有缺点，即磁盘空间碎片问题和文件长度不易扩展问题</p>
<h3 id="非连续空间存储方式"><a href="#非连续空间存储方式" class="headerlink" title="非连续空间存储方式"></a>非连续空间存储方式</h3><h4 id="链表方式"><a href="#链表方式" class="headerlink" title="链表方式"></a>链表方式</h4><p>链表方式存放是离散的，解决了磁盘空间碎片问题和文件长度不易扩展问题</p>
<p>根据实现方式的不同，可以分为隐式链表和显式链接</p>
<p>1、隐式链表</p>
<ul>
<li>文件头要包含表头和表尾的位置，并且每个数据块里面留出一个指针空间，用来存放下一个数据块</li>
<li>这种方式无法直接访问数据块，只能通过指针顺序访问文件，以及数据块指针消耗了一定的存储空间</li>
<li>隐式链接分配的稳定性较差，系统在运行过程中由于软件或者硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失</li>
</ul>
<p>2、显式链接</p>
<ul>
<li>把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，这张表称为文件分配表（File Allocation Table，FAT），在整个磁盘仅设置一张</li>
<li>查找记录的过程是在内存中进行的，提高了检索速度，并减少了访问磁盘的次数</li>
<li>不适用于大磁盘</li>
</ul>
<h4 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h4><p>为每个文件创建一个<strong>索引数据块</strong>，里面存放的是指向文件数据块的指针列表。因此文件头需要包含指向索引数据块的指针</p>
<p>这种方式的优点有：1）文件的创建、增大、缩小很方便；2）不会有碎片的问题；3）支持顺序读写和随机读写</p>
<p>但也有缺点：1）只能顺序查找，查询效率低；2）如果文件很小，也依旧需要额外分配一块数据块来存放索引数据，会带来额外的存储开销</p>
<h4 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h4><p>链表+索引：链式索引块，在索引数据块留出一个存放下一个索引数据块的指针。但是存在一个问题，如果某个指针损坏了，后面的数据就无法读取了</p>
<p>索引+索引：多级索引块，通过一个索引块来存放多个索引数据块（套娃）</p>
<blockquote>
<p>早期 Unix 文件系统是组合了前面的文件存放方式的优点，它是根据文件的大小，存放的方式会有所变化</p>
<ul>
<li>如果存放文件所需的数据块小于 10 块，则采用直接查找的方式</li>
<li>如果存放文件所需的数据块超过 10 块，则采用一级间接索引方式</li>
<li>如果前面两种方式都不够存放大文件，则采用二级间接索引方式</li>
<li>如果二级间接索引也不够存放大文件，这采用三级间接索引方式</li>
</ul>
<p>因此文件头（Inode）就需要包含 13 个指针</p>
<ul>
<li>前 10 个指向数据块的指针</li>
<li>第 11 个指向索引块的指针</li>
<li>第 12 个指向二级索引块的指针</li>
<li>第 13 个指向三级索引块的指针</li>
</ul>
<p>解决大文件的存储，但对于大文件的访问，需要大量的查询，效率比较低</p>
</blockquote>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>为所有空闲空间建立一张表，表内容包括<strong>空闲区的第一个块号和该空闲区的块个数</strong>，这个方式是<strong>连续分配</strong>的</p>
<p>当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域为止</p>
<p>当用户撤销一个文件时，系统回收文件空间，并顺序扫描空闲表，寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中</p>
<p>当存储空间中有着大量的小的空闲区，空闲表变得很大，查询效率很低</p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>每个空闲块里有一个指针指向下一个空闲块</p>
<p>这种方式只需要在主存里存放一个指向第一个空闲块的指针，实现十分简单；但这种方式无法做到随机访问，工作效率低，每次在链上增加或移动空闲块时需要很多 IO 操作，并且需要消耗存储空间存放数据块的指针</p>
<p>不适合用于大型文件系统，空闲链表会很大</p>
<h3 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h3><p>磁盘上所有的盘块都有一个二进制位与之对应，0 表示空闲</p>
<h2 id="块组"><a href="#块组" class="headerlink" title="块组"></a>块组</h2><blockquote>
<p>假设数据块的位图是存放在一个块里，一个块 4K，则可以表示 <code>4 * 1024 * 8</code> 个空闲块，即 <code>128MB</code> 的空间</p>
</blockquote>
<p>在 Linux 文件系统中，提供一个<strong>块组</strong>的结构，通过 N 个块组来表示 N 大的文件</p>
<p>如 Linux Ext2 文件系统</p>
<p><img src="/images/os/%E5%9D%97%E7%BB%84.png" alt="块组"></p>
<ul>
<li>引导块：在系统启动时用于启用引导</li>
<li>超级块：包含文件系统的重要信息，如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等</li>
<li>块组描述符：包含文件系统中各个块组的状态，如块组中空闲块和 inode 的数目等，每个块组都包含了文件系统中<strong>所有块组的组描述符信息</strong></li>
<li>数据位图和 inode 位图：用于表示对应的数据块或 inode 是否空闲</li>
<li>inode 列表：包含块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据</li>
<li>数据块：包含文件的有用数据</li>
</ul>
<p>每个块组里有很多重复的信息，如超级块和块组描述符表，这两个都是全局信息，而且非常的重要，重复的原因</p>
<ul>
<li>如果系统崩溃破坏了超级块或块组描述符，有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本，该信息是可能恢复的</li>
<li>通过使文件和管理数据尽可能接近，减少了磁头寻道和旋转，这可以提高文件系统的性能</li>
</ul>
<blockquote>
<p>Ext2 的后续版本采用了稀疏技术。超级块和块组描述符表不再存储到文件系统的每个块组中，而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中</p>
</blockquote>
<h2 id="目录的存储"><a href="#目录的存储" class="headerlink" title="目录的存储"></a>目录的存储</h2><blockquote>
<p>普通文件的块里面保存的是文件数据，而目录文件的块里面保存的是目录里面一项一项的文件信息</p>
</blockquote>
<p>最简单的保存格式是<strong>列表</strong>，即一项一项地将目录下的文件信息（如文件名、文件 inode、文件类型等）列在表里</p>
<p>但如果一个目录里有很多文件，在此目录下查找文件就需要逐个查找，效率不高</p>
<p>因此，保存目录的格式改成<strong>哈希表</strong>，对文件名进行哈希计算，把哈希值保存起来。这种方式在查找、增删方面效率很高，但需要一些预备措施来<strong>避免哈希冲突</strong></p>
<p>为了减少 I&#x2F;O 操作，把当前使用的文件目录缓存在内存，降低了磁盘操作次数，提高了文件系统的访问速度</p>
<h2 id="哈希冲突解决方法"><a href="#哈希冲突解决方法" class="headerlink" title="哈希冲突解决方法"></a>哈希冲突解决方法</h2><h3 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h3><p>一旦发生了冲突，就按照某种规则寻找一个空的散列地址</p>
<p>若发生第 i 次冲突，试探的下一个地址将增加 $d_i$。$d_i$ 决定了不同的解决冲突方案</p>
<ul>
<li>线性探测：$d_i&#x3D;i$</li>
<li>平方探测：$d_i&#x3D;\pm i^2$</li>
<li>双散列：$d_i&#x3D;i*h_2(key)$</li>
</ul>
<h3 id="再散列函数法"><a href="#再散列函数法" class="headerlink" title="再散列函数法"></a>再散列函数法</h3><p>提供多个散列函数，每当发生一个散列地址冲突时，换另一个散列函数计算。缺点是计算时间开销大</p>
<h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>具有相同散列地址的关键字的值存放在一个单链表中。长度超过一定长度后，可以转换成红黑树</p>
<h3 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h3><p>建立一个公共的溢出区来存放所有冲突的关键字记录。在查找时，先与基本表相应位置的值对比，如果相等则查找成功，否则顺序遍历公共溢出区。适用于冲突数据较少的场景</p>
<h2 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h2><p>硬链接：多个目录项中的索引节点指向一个文件</p>
<ul>
<li>inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是<strong>不可用于跨文件系统的</strong></li>
<li>由于多个目录项都是指向一个 inode，<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件</strong></li>
</ul>
<p>软链接：相当于重新创建一个文件，有独立的 inode，只不过内容是另外一个文件的路径</p>
<ul>
<li>访问软链接时相当于访问到了另外一个文件</li>
<li>可以跨文件系统，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已</li>
</ul>
<h2 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I&#x2F;O"></a>文件 I&#x2F;O</h2><h3 id="缓冲与非缓冲-I-O"><a href="#缓冲与非缓冲-I-O" class="headerlink" title="缓冲与非缓冲 I&#x2F;O"></a>缓冲与非缓冲 I&#x2F;O</h3><blockquote>
<p>根据是否利用标准库缓冲划分</p>
</blockquote>
<p>缓冲 I&#x2F;O：利用<strong>标准库的缓存</strong>实现文件的加速访问，而标准库再通过系统调用访问文件</p>
<p>非缓冲 I&#x2F;O：直接通过系统调用访问文件，不经过标准库缓存</p>
<blockquote>
<p>很多程序遇到换行时才真正输出，而换行前的内容被标准库暂时缓存了起来，这样可以减少系统调用的次数，减少 CPU 上下文切换的开销</p>
</blockquote>
<h3 id="直接与非直接-I-O"><a href="#直接与非直接-I-O" class="headerlink" title="直接与非直接 I&#x2F;O"></a>直接与非直接 I&#x2F;O</h3><blockquote>
<p>根据是否利用操作系统的缓存划分</p>
</blockquote>
<p>直接 I&#x2F;O：不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘</p>
<p>非直接 I&#x2F;O：读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘</p>
<blockquote>
<p>在使用文件操作类的系统调用函数时，默认是非直接 I&#x2F;O，可以指定 <code>O_DIRECT</code> 标志，表示使用直接 I&#x2F;O</p>
</blockquote>
<p>非直接 I&#x2F;O 进行写数据操作，内核将缓存写回磁盘的时机</p>
<ul>
<li>在调用 <code>write</code> 的最后，当发现内核缓存的数据太多时，内核会把数据写到磁盘上</li>
<li>用户主动调用 <code>sync</code>，内核缓存会刷到磁盘上</li>
<li>当<strong>内存十分紧张</strong>，无法再分配页面时，也会把内核缓存的数据刷到磁盘上</li>
<li>内核缓存的数据的缓存时间<strong>超过某个时间</strong>时，也会把数据刷到磁盘上</li>
</ul>
<h3 id="阻塞与非阻塞-I-O-VS-同步与异步-I-O"><a href="#阻塞与非阻塞-I-O-VS-同步与异步-I-O" class="headerlink" title="阻塞与非阻塞 I&#x2F;O VS. 同步与异步 I&#x2F;O"></a>阻塞与非阻塞 I&#x2F;O VS. 同步与异步 I&#x2F;O</h3><p>阻塞 I&#x2F;O：当用户程序执行 <code>read</code> ，线程会被阻塞，一直等到<strong>内核数据准备好</strong>，并把<strong>数据从内核缓冲区拷贝到应用程序的缓冲区中</strong>，当拷贝过程完成，<code>read</code> 才会返回</p>
<p>非阻塞 I&#x2F;O：<code>read</code> 请求在数据未准备好时可以立即返回继续往下执行，此时应用程序<strong>不断轮询内核</strong>，直到数据准备好，<strong>等待内核将数据拷贝到应用程序缓冲区</strong>，<code>read</code> 调用才可以获取到结果</p>
<blockquote>
<p>访问管道或 socket 时，默认是阻塞 I&#x2F;O，如果设置了 <code>O_NONBLOCK</code> 标志，则表示使用的是非阻塞 I&#x2F;O</p>
</blockquote>
<p>使用 I&#x2F;O 多路复用技术替换轮询方式，得到基于非阻塞 I&#x2F;O 的多路复用技术。它是通过 I&#x2F;O 事件分发，当内核数据准备好时，再以事件通知应用程序进行操作。这大大提升了 CPU 的利用率，当调用了 I&#x2F;O 多路复用接口时，如果没有事件发生，那么当前线程就会发生阻塞，CPU 会切换其他线程执行任务；等内核发现有事件到来时，会唤醒阻塞在 I&#x2F;O 多路复用接口的线程，然后用户可以进行后续的事件处理</p>
<p>I&#x2F;O 多路复用接口最大的优势在于，用户可以在一个线程内同时处理多个 socket 的 IO 请求。用户可以注册多个 socket，然后不断地调用 I&#x2F;O 多路复用接口读取被激活的 socket，即可达到在同一个线程内同时处理多个 IO 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的</p>
<p>无论是<strong>阻塞 I&#x2F;O、非阻塞 I&#x2F;O，还是基于非阻塞 I&#x2F;O 的多路复用</strong>都是<strong>同步调用</strong>。因为在 read 调用需要等待<strong>内核将数据从内核空间拷贝到应用程序空间</strong></p>
<p>异步 I&#x2F;O：<code>aio_read</code> 不需要等待<strong>内核数据准备好</strong>和<strong>数据从内核态拷贝到用户态</strong>这两个过程</p>
<h2 id="进程写文件时崩溃了，已写入的数据会丢失吗"><a href="#进程写文件时崩溃了，已写入的数据会丢失吗" class="headerlink" title="进程写文件时崩溃了，已写入的数据会丢失吗"></a>进程写文件时崩溃了，已写入的数据会丢失吗</h2><p>不会的。进程在执行 <code>write</code> 系统调用时，实际上是将文件数据写入到内核的 Page Cache（文件系统中用于缓存文件数据的缓冲），因此即便进程崩溃了，文件数据还是保留在内核的 Page Cache，读数据时也是从内核的 Page Cache 中读取，因此依然读的进程崩溃前写入的数据</p>
<p>内核会找一个合适的时机将 Page Cache 中的数据持久化到磁盘中，如果 Page Cache 在持久化之前丢失了文件数据（比如系统崩溃），那这部分的数据就丢失了</p>
<p>当然我们也可以在程序中调用 <code>fsync</code> 函数，在写文件时立刻把数据持久化到磁盘</p>
<h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><h3 id="Page-Cache-与文件持久化的一致性和可靠性"><a href="#Page-Cache-与文件持久化的一致性和可靠性" class="headerlink" title="Page Cache 与文件持久化的一致性和可靠性"></a>Page Cache 与文件持久化的一致性和可靠性</h3><blockquote>
<p>文件数据包含数据和元数据。元数据用来描述文件的各种属性（文件大小、创建时间、访问时间、属主、属组等），必须存储在磁盘上。因此文件一致性包含数据一致性和元数据一致性</p>
</blockquote>
<p>Linux 有两种方式实现文件一致性</p>
<ul>
<li><p>Write Through（写穿）：向用户层提供特定接口，应用程序可<strong>主动调用</strong>接口来保证文件一致性。这种方式以牺牲系统 I&#x2F;O 吞吐量为代价，确保数据落盘不会丢失。</p>
</li>
<li><p>Write Back（写回）：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块（Linux 默认方案）。这种方式在系统宕机时无法确保数据已经落盘，存在数据丢失风险。不过如果是程序挂了，操作系统还是会确保 Page Cache 中的数据落盘</p>
</li>
</ul>
<p>上述两种方法最终都依赖于系统调用，主要分为以下三种</p>
<ul>
<li><code>fsync(int fd)</code>：将 fd 代表的文件的脏数据和脏元数据全部刷新至磁盘中</li>
<li><code>fdatasync(int fd)</code>：将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中</li>
<li><code>sync()</code>：对系统中所有的脏的文件数据元数据刷新至磁盘中</li>
</ul>
<p>上述三种系统调用可以分别由用户进程与内核进程发起</p>
<p>创建的针对回写任务的内核线程数由系统中持久存储设备决定，为每个存储设备创建单独的刷新线程</p>
<p>关于多线程的架构问题，Linux 内核采取了 Lighthttp 的做法，即系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）</p>
<ul>
<li>管理线程：监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写</li>
<li>刷新线程：负责将设备中的脏页面回写至持久存储设备中</li>
</ul>
<p>刷新线程刷新设备上脏页面</p>
<ul>
<li>每个设备保存脏文件链表，每个节点为该设备上存储的脏文件的 inode 节点</li>
<li>系统中存在多个回写时机<ul>
<li>应用程序主动调用回写接口（fsync，fdatasync 以及 sync 等）</li>
<li>管理线程周期性地唤醒设备上的回写线程进行回写</li>
<li>某些应用程序&#x2F;内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写</li>
</ul>
</li>
</ul>
<h3 id="Page-Cache-的优劣势"><a href="#Page-Cache-的优劣势" class="headerlink" title="Page Cache 的优劣势"></a>Page Cache 的优劣势</h3><p>优势</p>
<p>1、内存访问比磁盘访问快，因此加快了数据的访问速度</p>
<p>2、由于 Page Cache 的缓存以及预读能力，减少 I&#x2F;O 次数，提高系统磁盘 I&#x2F;O 吞吐量</p>
<p>劣势</p>
<p>1、需要占用额外物理内存空间，当物理内存不足时会导致频繁的 swap 操作，最终导致系统的磁盘 I&#x2F;O 负载上升</p>
<p>2、对应用层并没有提供很好的管理 API，几乎是透明管理。应用层即使想优化 Page Cache 的使用策略也很难进行。因此一些应用选择在用户空间实现自己的 page 管理，而不使用 page cache，例如 MySQL InnoDB 存储引擎以 16KB 的页进行管理</p>
<p>3、在某些应用场景下比 Direct I&#x2F;O（不经过 Page Cache，直接和磁盘交互）多一次磁盘读 I&#x2F;O 以及磁盘写 I&#x2F;O</p>
<h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><blockquote>
<p>所谓的零拷贝并不是不拷贝，而是减少不必要的用户态与内核态之间的数据拷贝，减少上下文切换次数</p>
</blockquote>
<h3 id="传统的文件传输"><a href="#传统的文件传输" class="headerlink" title="传统的文件传输"></a>传统的文件传输</h3><p><img src="/images/os/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="传统文件传输"></p>
<ul>
<li><p>经历了 4 次用户态和内核态的上下文切换（发生了两次系统调用，<code>read()</code> 和 <code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态）</p>
</li>
<li><p>发送了 4 次数据拷贝</p>
<ul>
<li><p>具体</p>
<ul>
<li>把磁盘上的数据拷贝到操作系统<strong>内核缓冲区</strong>里，由 <strong>DMA</strong> 完成</li>
<li>把内核缓冲区的数据拷贝到<strong>用户缓冲区</strong>里，由 <strong>CPU</strong> 完成的</li>
<li>把<strong>用户缓冲区</strong>里的数据，拷贝到<strong>内核的 socket 缓冲区</strong>里，由 <strong>CPU</strong> 完成</li>
<li>把<strong>内核的 socket 缓冲区</strong>里的数据拷贝到<strong>网卡缓冲区</strong>里，由 <strong>DMA</strong> 完成</li>
</ul>
</li>
<li><p>评价</p>
<ul>
<li>过多的数据拷贝消耗大量 CPU 资源，大大降低了系统性能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="优化传输"><a href="#优化传输" class="headerlink" title="优化传输"></a>优化传输</h3><blockquote>
<p>目标：减少<strong>用户态与内核态的上下文切换</strong>和<strong>内存拷贝</strong>的次数</p>
</blockquote>
<ul>
<li><p>mmap + write</p>
<blockquote>
<p>mmap() 系统调用函数会直接把内核缓冲区里的数据映射到用户空间，这样操作系统内核与用户空间就不需要再进行任何的数据拷贝操作</p>
</blockquote>
<p><img src="/images/os/mmap_write%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="mmap_write文件传输"></p>
<ul>
<li>具体过程<ul>
<li>应用进程调用了 <code>mmap()</code> 后，<strong>DMA</strong> 会把磁盘的数据拷贝到<strong>内核缓冲区</strong>里。应用进程跟操作系统内核<strong>共享</strong>这个缓冲区</li>
<li>应用进程再调用 <code>write()</code>，操作系统直接将<strong>内核缓冲区</strong>的数据拷贝到 <strong>socket 缓冲区</strong>中。发生在内核态，由 CPU 完成</li>
<li>把内核的 <strong>socket 缓冲区</strong>里的数据，拷贝到<strong>网卡缓冲区</strong>里，由 <strong>DMA</strong> 完成</li>
</ul>
</li>
<li>评价<ul>
<li>仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里</li>
<li>仍然需要 4 次上下文切换，因为系统调用还是 2 次（mmap 和 write）</li>
</ul>
</li>
</ul>
</li>
<li><p>sendfile（要求 Linux 内核版本 2.1 以上）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">param out_fd: 目的端的文件描述符</span></span><br><span class="line"><span class="comment">param in_fd: 源端的文件描述符</span></span><br><span class="line"><span class="comment">param offset: 源端的偏移量</span></span><br><span class="line"><span class="comment">param count: 复制数据的长度</span></span><br><span class="line"><span class="comment">return: 实际复制数据的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span> *offset, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/os/sendfile%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="sendfile文件传输"></p>
<ul>
<li><p>评价</p>
<ul>
<li><code>sendfile()</code> 替代 <code>read()</code> 和 <code>write()</code>，减少了一次系统调用（2 次上下文切换）的开销</li>
<li><code>sendfile()</code>  直接把<strong>内核缓冲区</strong>里的数据拷贝到 <strong>socket 缓冲区</strong>里，不再拷贝到用户态，只有 3 次数据拷贝</li>
</ul>
</li>
<li><p>补充：如果网卡支持 SG-DMA 技术，可以实现 2 次数据拷贝</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网卡是否支持 scatter-gather 特性</span></span><br><span class="line">ethtool -k eth0 | grep scatter-gather</span><br><span class="line">scatter-gather: on</span><br></pre></td></tr></table></figure>

<p><img src="/images/os/SG_DMA%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="SG_DMA文件传输"></p>
<ul>
<li><strong>DMA</strong> 将磁盘上的数据拷贝到<strong>内核缓冲区</strong>里</li>
<li><strong>缓冲区描述符</strong>和<strong>数据长度</strong>传到 <strong>socket 缓冲区</strong>，网卡的 <strong>SG-DMA 控制器</strong>直接将<strong>内核缓冲区</strong>中的数据拷贝到<strong>网卡缓冲区</strong>里，减少了 1 次数据拷贝</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="I-O-多路复用实现方式"><a href="#I-O-多路复用实现方式" class="headerlink" title="I&#x2F;O 多路复用实现方式"></a>I&#x2F;O 多路复用实现方式</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>将已连接的 Socket 都放到一个文件描述符集合，然后调用 select 函数将文件描述符集合<strong>拷贝到内核</strong>里，让内核通过<strong>遍历</strong>文件描述符集合的方式来检查是否有网络事件产生。当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝回用户态里</strong>，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket</p>
<blockquote>
<p>进行了 2 次文件描述符集合遍历，2 次文件描述符集合拷贝</p>
</blockquote>
<p>select 使用<strong>固定长度的 BitsMap</strong> 表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 <code>FD_SETSIZE</code> 限制， 默认最大值为 <code>1024</code>，只能监听 <code>0~1023</code> 的文件描述符</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>使用<strong>动态数组</strong>存储所关注的文件描述符，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 的用法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(s, ...);</span><br><span class="line">listen(s, ...);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">// 将所有需要监听的 socket 添加到 epfd 中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">int</span> n = epoll_wait(...); <span class="comment">// 源码里调用了 __put_user 函数，将数据从内核态复制到用户空间</span></span><br><span class="line">    <span class="keyword">for</span>(接收到数据的 socket)  &#123;</span><br><span class="line">        <span class="comment">// 处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll 如何解决 select&#x2F;poll 的问题</p>
<ul>
<li>在<strong>内核里</strong>使用<strong>红黑树</strong>来跟踪进程所有待检测的文件描述字，每次操作只需要<strong>传入一个待检测的 socket</strong>，减少了内核和用户空间大量的<strong>数据拷贝和内存分配</strong></li>
<li>使用<strong>事件驱动</strong>的机制，<strong>内核里</strong>维护了一个<strong>链表</strong>来<strong>记录就绪事件</strong>，当某个 socket 有事件发生时，通过<strong>回调函数</strong>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率</li>
</ul>
<p>epoll 支持的<strong>两种事件触发模式</strong></p>
<ul>
<li>水平触发（Level Triggered，LT）：默认方式，当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong></li>
<li>边缘触发（Edge Triggered，ET）：当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong></li>
</ul>
<blockquote>
<p>对比</p>
<p>1、select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区</p>
<p>2、select 的性能比 poll 要好，但是 poll 能支持更多的连接</p>
<p>3、epoll 不需要轮询 fd，而是通过监听事件触发，效率高</p>
<p>应用场景</p>
<p>1、select 适合应用在实时性要求高的场景</p>
<p>2、poll 适合应用在实时性要求不高并且连接不是特别多的场景下</p>
<p>3、epoll 适合应用在大量连接的情况下，并发度高的场景</p>
</blockquote>
<h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p>Reactor 模式主要由 <strong>Reactor</strong> 和<strong>资源处理池</strong>组成</p>
<ul>
<li>Reactor：负责监听和分发事件（包括连接事件、读写事件）</li>
<li>处理资源池：负责处理事件</li>
</ul>
<p>Reactor 模式是比较灵活的，主要体现在</p>
<ul>
<li>Reactor 的数量可以是一个或多个</li>
<li>处理资源池可以是单进程&#x2F;线程，或多进程&#x2F;线程</li>
</ul>
<blockquote>
<p>Java 一般使用线程，如 Netty</p>
<p>C 进程线程都可以，如 Nginx 使用的是进程，Memcache 使用的是线程</p>
</blockquote>
<h3 id="单-Reactor-单进程-线程"><a href="#单-Reactor-单进程-线程" class="headerlink" title="单 Reactor 单进程&#x2F;线程"></a>单 Reactor 单进程&#x2F;线程</h3><p>一般来说，C 语言实现的是单 Reactor 单进程，因为 C 编写的程序，运行后就是一个独立的进程；而 Java 实现的是单 Reactor 单线程，因此 Java 程序是运行在 JVM 这个进程上的</p>
<img src="/images/os/单Reactor单进程.png" alt="单Reactor单进程" style="zoom:50%;" />

<p>其中，Reactor 对象负责监听和分发事件；Acceptor 对象负责获取连接；Handler 对象负责处理业务；对象中的select、accept、read、send 是系统调用函数，dispatch（分发事件操作）和业务处理是需要完成的操作</p>
<p>Reactor 对象通过 select（IO 多路复用接口） 监听事件，dispatch 收到事件后根据事件类型进行分发（给 Acceptor 对象或 Handler 对象）</p>
<p>这种方案所有工作都在一个进程里完成，实现简单，不用考虑进程间通信和多进程竞争，但也存在缺点</p>
<ul>
<li>无法充分利用多核 CPU 的性能</li>
<li>Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就造成响应的延迟</li>
</ul>
<p>因此这种方案不适用计算机密集型的场景，只适用于业务处理非常快速的场景</p>
<h3 id="单-Reactor-多进程-线程"><a href="#单-Reactor-多进程-线程" class="headerlink" title="单 Reactor 多进程&#x2F;线程"></a>单 Reactor 多进程&#x2F;线程</h3><img src="/images/os/单Reactor多线程.png" alt="单Reactor多线程" style="zoom:50%;" />

<p>Handler 对象的工作发生变化，Handler 对象只负责数据的接收和发送，业务处理交由子线程的 Processor 对象完成</p>
<p>这种方案能够充分利用多核 CPU，但也带来了多线程竞争资源的问题，因此在操作共享资源前需要加上互斥锁来解决</p>
<blockquote>
<p>单 Reactor 多进程的实现比较复杂，需要考虑父子进程的双向通信问题，而且父进程需要知道子进程将数据发送给哪个客户端，而多线程间可以共享数据，虽然要额外考虑并发问题，但远比进程间通信的复杂度低得多，因此实际应用中也看不到单 Reactor 多进程的模式</p>
</blockquote>
<p>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，因此这种方案在瞬间高并发的场景里容易遇到性能瓶颈</p>
<h3 id="多-Reactor-多进程-线程"><a href="#多-Reactor-多进程-线程" class="headerlink" title="多 Reactor 多进程&#x2F;线程"></a>多 Reactor 多进程&#x2F;线程</h3><blockquote>
<p>多 Reactor 单进程&#x2F;线程实现方案相比单 Reactor 单进程&#x2F;线程方案，不仅复杂而且也没有性能优势，因此实际中并没有应用</p>
<p>Netty 和 Memcache 采用多 Reactor 多线程方案，Nginx 采用多 Reactor 多进程方案（与标准的多 Reactor 多进程方案有些差异，主要体现在：主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过<strong>锁</strong>来控制<strong>一次只有一个子进程进行 accept（防止出现惊群现象）</strong>，子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程）</p>
</blockquote>
<img src="/images/os/主从Reactor多线程.png" alt="主从Reactor多线程" style="zoom:50%;" />

<ul>
<li>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程</li>
<li>子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件</li>
<li>如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应，由 Handler 对象完成完整的业务流程</li>
</ul>
<p>多 Reactor 多线程方案比单 Reactor 多线程方案在实现上更加简单，原因</p>
<ul>
<li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理</li>
<li>主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程<strong>无须返回数据</strong>，直接就可以在子线程将处理结果发送给客户端</li>
</ul>
<h2 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h2><blockquote>
<p>Reactor 是非阻塞同步网络模式，Proactor 是异步网络模式</p>
</blockquote>
<img src="/images/os/Proactor.png" alt="Proactor" style="zoom:50%;" />

<p>Reactor 和 Proactor 的区别</p>
<ul>
<li>Reactor 是非阻塞同步网络模式，感知的是就绪可读写事件，需要应用进程主动调用 read 方法来完成数据的读取</li>
<li>Proactor 是异步网络模式， 感知的是已完成的读写事件，在发起异步读写请求时，需要传入数据缓冲区的地址（用来存放结果数据）等信息</li>
</ul>
<p>在 Linux 下的异步 I&#x2F;O 是不完善的， aio 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的</p>
<p>Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 IOCP，是由操作系统级别实现的异步 I&#x2F;O，真正意义上异步 I&#x2F;O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案</p>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><blockquote>
<p>在对数据进行缓存的时候，通过负载均衡可以很均匀地分配到各个缓存服务器上。在获取缓存数据的时候，如果采用轮询，其查询效率很低，可以使用 Hash 算法，对缓存数据计算 hash key，并对服务器数量取模，得到存放位置。这种做法能够实现 O(1) 的查询效率，但是当服务器数量发生变化时（扩容、服务器失效），所有缓存位置大概率需要发生改动，可能会出现缓存雪崩现象</p>
</blockquote>
<ul>
<li>解决的是在分布式 Hash 表里动态伸缩的问题</li>
<li>针对上述问题，一致性 hash 算法不对服务器数据取模，而是对 $2^{32} - 1$ 取模。</li>
<li>所有的缓存位置构成一个 <strong>hash 环</strong>，每个服务器的位置可以根据 ip 地址进行 hash 计算得到相应的位置。而根据缓存数据计算出来的 hash 值，可以找到下一个最近的服务器，缓存数据存放在这台服务器上。<ul>
<li>在服务器数量发生改变时，只会造成部分缓存失效。比如增加一个服务器节点，这个节点前的数据会到新的服务器查询，会出现未命中现象；删除一个服务器节点，这个节点前的数据会到下一个服务器节点查询，会出现未命中现象；而其他节点的数据不受影响</li>
</ul>
</li>
<li>Hash 环倾斜 &#x2F; 虚拟节点<ul>
<li>服务器的位置可能分布的不是很均匀，这会导致每个服务器的负载不均衡，为了引入了<strong>虚拟节点</strong>的概念。添加虚拟节点可以使服务器均匀分配，虚拟节点上的数据会存放在其对应的真实服务器上。</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/">小林coding - 图解系统</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/23/redis/" rel="prev" title="Redis">
      <i class="fa fa-chevron-left"></i> Redis
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/02/18/network/" rel="next" title="计算机网络">
      计算机网络 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">硬件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">冯诺伊曼模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF"><span class="nav-number">1.2.</span> <span class="nav-text">总线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84-CPU-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="nav-number">1.3.</span> <span class="nav-text">程序的 CPU 执行时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6-32-%E4%BD%8D%E5%92%8C-64-%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.</span> <span class="nav-text">软件 32 位和 64 位的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-64-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%83%BD%E5%9C%A8-64-32-%E4%BD%8D%E6%9C%BA%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8C%E5%90%97"><span class="nav-number">1.5.</span> <span class="nav-text">32&#x2F;64 位操作系统能在 64&#x2F;32 位机器上运行吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.</span> <span class="nav-text">存储器层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD"><span class="nav-number">1.7.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU"><span class="nav-number">1.8.</span> <span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">1.9.</span> <span class="nav-text">指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.10.</span> <span class="nav-text">CPU 缓存一致性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">2.1.</span> <span class="nav-text">为什么需要虚拟内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">2.2.</span> <span class="nav-text">虚拟地址和物理地址的映射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">分段管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.2.</span> <span class="nav-text">分页管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">多级页表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="nav-number">2.2.3.</span> <span class="nav-text">段页式管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%EF%BC%88%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">逻辑地址和虚拟地址（线性地址）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83"><span class="nav-number">2.4.</span> <span class="nav-text">Linux 虚拟地址空间分布</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%88%86%E5%B8%83%E6%83%85%E5%86%B5"><span class="nav-number">2.4.1.</span> <span class="nav-text">用户空间分布情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#malloc-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84"><span class="nav-number">2.5.</span> <span class="nav-text">malloc 是如何分配内存的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#free-%E6%98%AF%E5%A6%82%E4%BD%95%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%9A%84"><span class="nav-number">2.6.</span> <span class="nav-text">free 是如何释放内存的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E7%9A%84"><span class="nav-number">2.7.</span> <span class="nav-text">物理内存是如何分配的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%86%85%E5%AD%98%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="nav-number">2.8.</span> <span class="nav-text">哪些内存可以被回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8A%A4%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%A2%AB-OOM-%E6%9D%80%E6%8E%89"><span class="nav-number">2.9.</span> <span class="nav-text">如何保护一个进程不被 OOM 杀掉</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AA-4GB-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%8A%E7%94%B3%E8%AF%B7-8GB-%E5%86%85%E5%AD%98%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><span class="nav-number">2.10.</span> <span class="nav-text">在一个 4GB 物理内存的机器上申请 8GB 内存会怎么样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88%E5%92%8C%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93%E9%97%AE%E9%A2%98"><span class="nav-number">2.11.</span> <span class="nav-text">如何避免预读失效和缓存污染问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.12.</span> <span class="nav-text">内存页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.12.1.</span> <span class="nav-text">常见的页面置换算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.13.</span> <span class="nav-text">磁盘调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">2.13.1.</span> <span class="nav-text">常见的磁盘调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-number">2.14.</span> <span class="nav-text">内核如何管理进程虚拟内存空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-number">2.14.1.</span> <span class="nav-text">内核如何划分用户态和内核态虚拟内存空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">2.14.2.</span> <span class="nav-text">内核如何管理虚拟内存区域</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">进程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.1.</span> <span class="nav-text">进程的状态有哪些</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%BC%E8%87%B4%E8%BF%9B%E7%A8%8B%E6%8C%82%E8%B5%B7%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.1.1.</span> <span class="nav-text">导致进程挂起的原因有哪些</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%86%85%E5%AE%B9"><span class="nav-number">3.2.</span> <span class="nav-text">进程控制块包含哪些内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-number">3.4.</span> <span class="nav-text">进程与线程的差异</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-VS-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.5.</span> <span class="nav-text">孤儿进程 VS. 僵尸进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">线程有哪几种实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.6.1.</span> <span class="nav-text">用户线程的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.6.2.</span> <span class="nav-text">内核线程的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.6.3.</span> <span class="nav-text">轻量级进程的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="nav-number">3.6.3.1.</span> <span class="nav-text">一对一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E5%A4%9A"><span class="nav-number">3.6.3.2.</span> <span class="nav-text">一对多</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="nav-number">3.6.3.3.</span> <span class="nav-text">多对多</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1"><span class="nav-number">3.7.</span> <span class="nav-text">处理机调度层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E3%80%81%E9%95%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="nav-number">3.7.1.</span> <span class="nav-text">高级调度（作业调度、长程调度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88%E4%B8%AD%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="nav-number">3.7.2.</span> <span class="nav-text">中级调度（中程调度）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E3%80%81%E7%9F%AD%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="nav-number">3.7.3.</span> <span class="nav-text">低级调度（进程调度、短程调度）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">3.8.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="nav-number">3.8.1.</span> <span class="nav-text">调度时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99"><span class="nav-number">3.8.2.</span> <span class="nav-text">调度原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.8.3.</span> <span class="nav-text">调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">3.9.</span> <span class="nav-text">进程间通信方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E7%8A%B6%E6%80%81%E4%B8%8B"><span class="nav-number">3.9.1.</span> <span class="nav-text">常规状态下</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%A1%E9%81%93"><span class="nav-number">3.9.1.1.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">3.9.1.2.</span> <span class="nav-text">消息队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">3.9.1.3.</span> <span class="nav-text">共享内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.9.1.4.</span> <span class="nav-text">信号量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B"><span class="nav-number">3.9.2.</span> <span class="nav-text">异常情况下</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">3.9.2.1.</span> <span class="nav-text">信号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E7%BD%91%E7%BB%9C-%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1"><span class="nav-number">3.9.3.</span> <span class="nav-text">跨网络&#x2F;主机通信</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Socket%EF%BC%88%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%89"><span class="nav-number">3.9.3.1.</span> <span class="nav-text">Socket（套接字）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%B2%E7%AA%81"><span class="nav-number">3.10.</span> <span class="nav-text">多线程冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">3.11.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.11.1.</span> <span class="nav-text">死锁的必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">3.11.2.</span> <span class="nav-text">如何处理死锁问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-number">3.11.2.1.</span> <span class="nav-text">死锁预防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="nav-number">3.11.2.2.</span> <span class="nav-text">死锁避免</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="nav-number">3.11.2.3.</span> <span class="nav-text">死锁检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="nav-number">3.11.2.4.</span> <span class="nav-text">死锁解除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%B8%B5%E9%B8%9F%E7%AD%96%E7%95%A5"><span class="nav-number">3.11.2.5.</span> <span class="nav-text">鸵鸟策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.12.</span> <span class="nav-text">一个进程最多可以创建多少个线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B4%A9%E6%BA%83%E4%BA%86%E4%BC%9A%E5%AF%BC%E8%87%B4%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E5%90%97"><span class="nav-number">3.13.</span> <span class="nav-text">线程崩溃了会导致进程崩溃吗</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%9C%A8%E7%A3%81%E7%9B%98%E9%87%8C%E7%9A%84"><span class="nav-number">4.1.</span> <span class="nav-text">文件数据是如何存储在磁盘里的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.2.</span> <span class="nav-text">虚拟文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="nav-number">4.2.1.</span> <span class="nav-text">文件描述符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">文件的存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.1.</span> <span class="nav-text">连续空间存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.2.</span> <span class="nav-text">非连续空间存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">链表方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">索引方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">组合方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="nav-number">4.4.</span> <span class="nav-text">空闲空间管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="nav-number">4.4.1.</span> <span class="nav-text">空闲表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="nav-number">4.4.2.</span> <span class="nav-text">空闲链表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E5%9B%BE%E6%B3%95"><span class="nav-number">4.4.3.</span> <span class="nav-text">位图法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9D%97%E7%BB%84"><span class="nav-number">4.5.</span> <span class="nav-text">块组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-number">4.6.</span> <span class="nav-text">目录的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">4.7.</span> <span class="nav-text">哈希冲突解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="nav-number">4.7.1.</span> <span class="nav-text">开放定址法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%B3%95"><span class="nav-number">4.7.2.</span> <span class="nav-text">再散列函数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="nav-number">4.7.3.</span> <span class="nav-text">链地址法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA%E6%B3%95"><span class="nav-number">4.7.4.</span> <span class="nav-text">公共溢出区法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="nav-number">4.8.</span> <span class="nav-text">软链接和硬链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6-I-O"><span class="nav-number">4.9.</span> <span class="nav-text">文件 I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%86%B2-I-O"><span class="nav-number">4.9.1.</span> <span class="nav-text">缓冲与非缓冲 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5-I-O"><span class="nav-number">4.9.2.</span> <span class="nav-text">直接与非直接 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E-I-O-VS-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5-I-O"><span class="nav-number">4.9.3.</span> <span class="nav-text">阻塞与非阻塞 I&#x2F;O VS. 同步与异步 I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%86%99%E6%96%87%E4%BB%B6%E6%97%B6%E5%B4%A9%E6%BA%83%E4%BA%86%EF%BC%8C%E5%B7%B2%E5%86%99%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%90%97"><span class="nav-number">4.10.</span> <span class="nav-text">进程写文件时崩溃了，已写入的数据会丢失吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Page-Cache"><span class="nav-number">4.11.</span> <span class="nav-text">Page Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Page-Cache-%E4%B8%8E%E6%96%87%E4%BB%B6%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">4.11.1.</span> <span class="nav-text">Page Cache 与文件持久化的一致性和可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Page-Cache-%E7%9A%84%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="nav-number">4.11.2.</span> <span class="nav-text">Page Cache 的优劣势</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.</span> <span class="nav-text">网络系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">5.1.</span> <span class="nav-text">零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="nav-number">5.1.1.</span> <span class="nav-text">传统的文件传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E4%BC%A0%E8%BE%93"><span class="nav-number">5.1.2.</span> <span class="nav-text">优化传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">I&#x2F;O 多路复用实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#select"><span class="nav-number">5.2.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#poll"><span class="nav-number">5.2.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll"><span class="nav-number">5.2.3.</span> <span class="nav-text">epoll</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor-%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">Reactor 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95-Reactor-%E5%8D%95%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">单 Reactor 单进程&#x2F;线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95-Reactor-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">单 Reactor 多进程&#x2F;线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A-Reactor-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.3.</span> <span class="nav-text">多 Reactor 多进程&#x2F;线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proactor"><span class="nav-number">5.4.</span> <span class="nav-text">Proactor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">5.5.</span> <span class="nav-text">一致性哈希</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bling"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Bling</p>
  <div class="site-description" itemprop="description">绳锯木断，水滴石穿</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-01 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bling</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
