<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Redis 相关知识">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2024/01/23/Redis/index.html">
<meta property="og:site_name" content="随笔">
<meta property="og:description" content="Redis 相关知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="http://example.com/images/Redis/Redis%E5%AE%9E%E7%8E%B0%E9%94%AE%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E5%BC%8F.png">
<meta property="og:image" content="http://example.com/images/Redis/SDS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/images/Redis/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.png">
<meta property="og:image" content="http://example.com/images/Redis/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.png">
<meta property="og:image" content="http://example.com/images/Redis/quicklist%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="http://example.com/images/Redis/listpack%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1.png">
<meta property="og:image" content="http://example.com/images/Redis/%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5.png">
<meta property="og:image" content="http://example.com/images/Redis/%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6.png">
<meta property="og:image" content="http://example.com/images/Redis/Redis%E4%BA%8B%E5%8A%A1.png">
<meta property="article:published_time" content="2024-01-23T02:01:24.000Z">
<meta property="article:modified_time" content="2024-02-19T07:29:04.925Z">
<meta property="article:author" content="Bling">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png">

<link rel="canonical" href="http://example.com/2024/01/23/Redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis | 随笔</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">随笔</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/23/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Bling">
      <meta itemprop="description" content="绳锯木断，水滴石穿">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="随笔">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-23 10:01:24" itemprop="dateCreated datePublished" datetime="2024-01-23T10:01:24+08:00">2024-01-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-19 15:29:04" itemprop="dateModified" datetime="2024-02-19T15:29:04+08:00">2024-02-19</time>
              </span>

          
            <div class="post-description">Redis 相关知识</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>Redis 数据结构并不是指 String、List、Hash、Set、Zset 等对象，这些是 Redis 键值对中值的数据类型，即数据的保存形式，这些对象底层实现的方式才是数据结构</p>
<p><img src="/images/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png" alt="数据类型和底层数据结构关系"></p>
<h2 id="Redis-是如何实现键值对数据库的？"><a href="#Redis-是如何实现键值对数据库的？" class="headerlink" title="Redis 是如何实现键值对数据库的？"></a>Redis 是如何实现键值对数据库的？</h2><p><img src="/images/Redis/Redis%E5%AE%9E%E7%8E%B0%E9%94%AE%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E5%BC%8F.png" alt="Redis实现键值对数据库方式"></p>
<p><code>redisDb</code> 结构：Redis 数据库结构，存放了指向 <code>dict</code> 结构的指针</p>
<p><code>dict</code> 结构：存放了两张哈希表，正常情况下使用 <code>ht[0]</code>，<code>ht[1] </code>在 rehash 时使用</p>
<p><code>dictht</code> 结构：哈希表结构，存放了哈希表数组，数组中每个元素是指向一个哈希表节点结构（<code>dictEntry</code>）的指针</p>
<p><code>dictEntry</code> 结构：哈希表节点结构，存放了 <code>void *key</code> 和 <code>void *value</code> 指针，指向 Redis 对象</p>
<p><code>redisObject</code>：Redis 对象结构，成员变量包含 <code>type</code>、<code>encoding</code>、<code>ptr</code>，分别用于表示对象类型、表示对象使用的底层数据结构类型和指向底层数据结构的指针</p>
<h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><h3 id="SDS-与-C-的原生字符串的区别"><a href="#SDS-与-C-的原生字符串的区别" class="headerlink" title="SDS 与 C 的原生字符串的区别"></a>SDS 与 C 的原生字符串的区别</h3><ul>
<li>SDS 不仅可以存放文本数据，还可以存放二进制数据（图片、音频、视频、压缩文件等）。这是因为 SDS 使用 <code>len</code> 属性的值而不是空字符 <code>\0</code> 来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。</li>
<li>SDS 获取字符串长度的时间复杂度是 O(1)。这是因为 SDS 使用 <code>len</code> 属性记录了字符串长度</li>
<li>Redis 的 SDS API 是安全的，这是因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，不会导致缓冲区溢出问题</li>
</ul>
<h3 id="SDS-数据结构（Redis-5-0）"><a href="#SDS-数据结构（Redis-5-0）" class="headerlink" title="SDS 数据结构（Redis 5.0）"></a>SDS 数据结构（Redis 5.0）</h3><img src="/images/Redis/SDS数据结构.png" alt="SDS数据结构" style="zoom:50%;" />

<p>flags 用于表示不同类型的 SDS</p>
<ul>
<li><p>一共 5 种，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64</p>
</li>
<li><p>这些类型的区别是数据结构中的 <code>len</code> 和 <code>alloc</code> 成员变量的数据类型不同</p>
</li>
<li><p>能灵活保存不同大小的字符串，有效节省内存空间</p>
</li>
</ul>
<blockquote>
<p>除了设计不同类型的结构体，Redis 在编程上还使用了专门的编译优化来节省内存空间，即在 struct 声明了 <code>__attribute__ ((packed)) </code>，告诉编译器取消结构体在编译过程中的优化对齐，按照实际占用字节数进行对齐。</p>
</blockquote>
<h3 id="SDS-扩容规则"><a href="#SDS-扩容规则" class="headerlink" title="SDS 扩容规则"></a>SDS 扩容规则</h3><p>1、如果剩余的空间足够，则无需扩容</p>
<p>2、否则，获取修改后的 SDS 长度 <code>new_len</code>，如果 <code>new_len</code> 小于 <code>SDS_MAX_PREALLOC</code>（1MB），则按照 <code>new_len</code> 倍数扩容；否则为 <code>new_len</code> + <code>SDS_MAX_PREALLOC</code></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表节点结构设计"><a href="#链表节点结构设计" class="headerlink" title="链表节点结构设计"></a>链表节点结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="type">void</span> *value; <span class="comment">// 节点的值</span></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<h3 id="链表结构设计"><a href="#链表结构设计" class="headerlink" title="链表结构设计"></a>链表结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head; <span class="comment">// 链表头节点</span></span><br><span class="line">    listNode *tail; <span class="comment">// 链表尾节点</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr); <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr); <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key); <span class="comment">// 节点值比较函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len; <span class="comment">// 链表节点数量</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>链表节点结构中存在前后节点的指针，获取某个节点的前后节点的时间复杂度为 <code>O(1)</code>；这两个指针都能指向 <code>NULL</code>，链表是无环链表</p>
</li>
<li><p>链表结构提供了头尾节点指针，获取表头和表尾节点的时间复杂度为 <code>O(1)</code></p>
</li>
<li><p>链表结构保存了链表节点数量，获取链表长度的时间复杂度为 <code>O(1)</code></p>
</li>
<li><p>链表节点结构使用 <code>void*</code> 指针保存节点值，且可以通过链表结构的 <code>dup</code>、<code>free</code>、<code>match</code> 函数指针为节点设置该节点类型特定的函数，因此链表节点可以保存各种不同类型的值</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>链表每个节点之间的内存都是不连续的，无法很好利用 CPU 缓存</li>
<li>保存一个链表节点的值都需要一个链表节点结构头的分配，内存开销较大</li>
</ul>
<blockquote>
<p>Redis 3.0 的 List 对象在数据量比较少的时候，会使用<strong>压缩列表</strong>作为底层数据结构的实现，但压缩列表存在性能问题，因此在 Redis 3.2 的时候改用 <strong>quicklist</strong> 实现</p>
</blockquote>
<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>最大的特点是被设计成一种<strong>内存紧凑型</strong>的数据结构，占用一块连续的内存空间，可以利用 CPU 缓存，也可以根据不同长度的数据采用不同的编码方式，有效节省内存开销</p>
<p>但是也存在一些缺陷</p>
<ul>
<li>不能保存过多的元素，否则查询效率会降低</li>
<li>新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题</li>
</ul>
<h3 id="压缩列表结构设计"><a href="#压缩列表结构设计" class="headerlink" title="压缩列表结构设计"></a>压缩列表结构设计</h3><img src="/images/Redis/压缩列表结构设计.png" alt="压缩列表结构设计" style="zoom:50%;" />

<ul>
<li><code>zlbytes</code>：整个压缩列表占用大小（字节数）</li>
<li><code>zltail</code>：压缩列表尾部节点的偏移量</li>
<li><code>zllen</code>：压缩列表节点数</li>
<li><code>prevlen</code>：前一个节点的长度，实现从后向前遍历</li>
<li><code>encoding</code>：当前节点实际数据的类型和长度，类型主要有两种：字符串和整数</li>
<li><code>data</code>：当前节点的实际数据</li>
<li><code>zlend</code>：压缩列表的结束点，固定值 <code>0xFF</code>（255）</li>
</ul>
<p>查找压缩列表头尾节点的时间复杂度为 <code>O(1)</code>，其他的为 <code>O(N)</code></p>
<h3 id="压缩列表为什么节省内存"><a href="#压缩列表为什么节省内存" class="headerlink" title="压缩列表为什么节省内存"></a>压缩列表为什么节省内存</h3><p>压缩列表会根据数据类型（字符串还是整数）和数据大小进行不同的空间大小分配。其中 <code>prevlen</code> 和 <code>encoding</code> 用来保存<strong>前一个节点的长度</strong>和<strong>当前节点实际数据的类型和长度</strong></p>
<p><code>prevlen</code> 属性空间大小由前一个节点的长度决定</p>
<ul>
<li>如果长度小于 254 字节，则使用 1 字节空间保存</li>
<li>否则需要使用 5 字节空间保存</li>
</ul>
<p><code>encoding</code> 属性空间大小由数据类型和字符串长度（如果类型是字符串）决定</p>
<ul>
<li>如果数据类型是整数，则使用 1 字节的空间进行编码；数据的长度由数据类型决定</li>
<li>如果数据类型是字符串，根据字符串的长度大小，使用 1&#x2F;2&#x2F;5 字节的空间进行编码。<code>encoding</code> 编码的前两个 <code>bit</code> 表示数据的类型，剩余的 <code>bit</code> 表示数据的实际长度</li>
</ul>
<h3 id="造成连锁更新的原因"><a href="#造成连锁更新的原因" class="headerlink" title="造成连锁更新的原因"></a>造成连锁更新的原因</h3><p>连锁更新指的是压缩列表在某些特殊情况下，发生了连续多次空间扩展操作。造成这现象的主要原因与 <code>prevlen</code> 属性有关。当压缩列表新增某个元素或修改某个元素时，如果空间不够，则需要重新分配压缩列表占用的内存空间。当新插入的元素较大时，可能会导致后续元素的 <code>prevlen</code> 占用空间都发生变化，从而导致每个元素的空间都要重新分配，引起连锁更新问题。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表实际上是数组，能够通过索引值快速查询到数据，时间复杂度为 <code>O(1)</code>；但在哈希表大小固定的情况下，随着数据不断增多，哈希冲突的可能性也会越高</p>
<p>Redis 采用了<strong>链式哈希</strong>来解决哈希冲突。链式哈希也存在局限性，随着链表长度的增加，查询这一位置上的时间复杂度可能会退化成 <code>O(N)</code>，为了解决这个问题，Redis 通过 rehash 解决</p>
<h3 id="哈希表结构设计"><a href="#哈希表结构设计" class="headerlink" title="哈希表结构设计"></a>哈希表结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table; <span class="comment">// 哈希表数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size; <span class="comment">// 哈希表大小  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used; <span class="comment">// 哈希表已有的节点数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表节点结构设计"><a href="#哈希表节点结构设计" class="headerlink" title="哈希表节点结构设计"></a>哈希表节点结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val; <span class="comment">// 指向实际值的指针</span></span><br><span class="line">        <span class="type">uint64_t</span> u64; <span class="comment">// 无符号的 64 位整数</span></span><br><span class="line">        <span class="type">int64_t</span> s64; <span class="comment">// 有符号的 64 位整数</span></span><br><span class="line">        <span class="type">double</span> d; <span class="comment">// double 类型的值</span></span><br><span class="line">    &#125; v; <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个哈希表节点，形成链表</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<h3 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3><p>在实际使用哈希表时，Redis 定义一个 dict 结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line">    dictht ht[<span class="number">2</span>]; <span class="comment">// 两个Hash表，交替使用，用于 rehash 操作</span></span><br><span class="line">	<span class="comment">// 省略</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>负载因子：哈希表中单向链表的平均长度</p>
</blockquote>
<p>随着增删操作的进行，Redis 通过 rehash 操作将负载因子维持在一个合理范围内</p>
<p>rehash 操作分为两种</p>
<ul>
<li>扩展：当负载因子较大时，应该扩大哈希表长度以降低平均长度，加快查询进度</li>
<li>收缩：当负载因子较小时，应该缩小哈希表长度以减少对内存的浪费</li>
</ul>
<p>rehash 过程</p>
<ul>
<li>为字典的 <code>ht[1]</code> 哈希表分配空间，空间的大小取决于要执行的操作和 <code>ht[0]</code> 使用的大小<ul>
<li>扩展：<code>ht[1]</code> 的大小为最小的且不小于 <code>ht[0].used</code> * 2 的 $2^n$</li>
<li>收缩：<code>ht[1]</code> 的大小为最小的且不小于 <code>ht[0].used</code> 的 $2^n$</li>
</ul>
</li>
<li>将 <code>ht[0]</code> 中所有键值对根据 <code>ht[1]</code> 重新计算 hash 并移动到 <code>ht[1]</code>，然后将键值对从 <code>ht[0]</code> 中删除</li>
<li>当 <code>ht[0]</code> 中所有键值对移动后 <code>ht[1]</code> 后开始执行清理工作，释放 <code>ht[0]</code> 占用的内存，将 <code>ht[1]</code> 赋值给 <code>ht[0]</code>，为 <code>ht[1]</code> 分配一个空的哈希表，为下次 rehash 做准备</li>
</ul>
<h3 id="渐进式-Rehash"><a href="#渐进式-Rehash" class="headerlink" title="渐进式 Rehash"></a>渐进式 Rehash</h3><p>如果键值对过多，一次性移动所有键值对会导致 Redis 在一段时间内无法对外提供服务，这个时候就需要引进渐进式 Rehash 的概念</p>
<p>渐进式 rehash 是在 rehash 的基础上，增加一个 <code>rehashidx</code> 参数，该参数初始值为 0，表示 rehash 工作正式开始。在 rehash 进行期间，每对字典进行增删改查操作时，程序在执行指定操作外，还会将 <code>ht[0]</code> 在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code>，然后将 <code>rehashidx</code> 的值加 1</p>
<p>随着字典操作的不断执行，<code>ht[0]</code> 的所有键值对最终会全部移动到 <code>ht[1]</code>，此时程序会将 <code>rehashidx</code> 设为 -1，表示 rehash 操作已完成。</p>
<blockquote>
<p>特别的，在渐进式 rehash 操作过程中，因为同时存在两个哈希表，所以字典的<strong>删除，查找，更新</strong>操作会在两个哈希表上进行。程序会先尝试在 <code>ht[0]</code> 中寻找目标键值对，如果没有找到则会在 <code>ht[1]</code> 再次进行寻找，然后进行具体操作。但是<strong>新增</strong>操作只会在 <code>ht[1]</code> 上进行，这保证了 <code>ht[0]</code> 中的已经被清空的单向链表不会新增元素</p>
</blockquote>
<h3 id="触发-rehash-的条件"><a href="#触发-rehash-的条件" class="headerlink" title="触发 rehash 的条件"></a>触发 rehash 的条件</h3><p>1、当负载因子大于等于 1 且 Redis 没有执行 <code>bgsave</code> 命令（RDB 快照）或 <code>bgrewriteaof</code> 命令（AOF 重写）时<br>2、当负载因子大于等于 5 时，强制进行 rehash 操作</p>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><h3 id="整数集合结构设计"><a href="#整数集合结构设计" class="headerlink" title="整数集合结构设计"></a>整数集合结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> length; <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[]; <span class="comment">// 保存元素的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>encoding</code>：有三种，分别是 <code>INTSET_ENC_INT16</code>、<code>INTSET_ENC_INT32</code>  和 <code>INTSET_ENC_INT64</code></li>
<li><code>contents</code>：虽然定义为 <code>int8_t</code>，但实际上并不保存任何 <code>int8_t</code> 类型的元素，真正的数据类型取决于 <code>encoding</code> 属性的值</li>
</ul>
<h3 id="整数集合的升级操作"><a href="#整数集合的升级操作" class="headerlink" title="整数集合的升级操作"></a>整数集合的升级操作</h3><p>当新加入的元素比集合中现有的元素要长时，需要先对集合中的元素进行升级（需要维持集合的有序性），再加入新的元素</p>
<p>在进行升级操作过程中，并不会重新分配一个新类型的数组，而是在原有的基础上进行空间扩展，再将每个元素按间隔类型大小分割</p>
<blockquote>
<p>不支持降级操作</p>
</blockquote>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>在链表的基础上，增加了多级索引，通过多级索引位置的转跳，实现快速查找</p>
<h3 id="跳表节点结构设计"><a href="#跳表节点结构设计" class="headerlink" title="跳表节点结构设计"></a>跳表节点结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele; <span class="comment">// Zset 对象的元素值</span></span><br><span class="line">    <span class="type">double</span> score; <span class="comment">// 元素权重值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 后向指针，指向前一个节点，方便倒序查找</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的 level 数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 前向指针，指向下一个跳表节点</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span; <span class="comment">// 跨度，两个跳表节点之间的距离</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<h3 id="跳表结构设计"><a href="#跳表结构设计" class="headerlink" title="跳表结构设计"></a>跳表结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// 跳表的头尾节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length; <span class="comment">// 跳表的长度</span></span><br><span class="line">    <span class="type">int</span> level; <span class="comment">// 跳表的最大层数</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Redis/3%E5%B1%82%E8%B7%B3%E8%A1%A8-%E8%B7%A8%E5%BA%A6.png" alt="3层跳表-跨度"></p>
<h3 id="跳表节点查询过程"><a href="#跳表节点查询过程" class="headerlink" title="跳表节点查询过程"></a>跳表节点查询过程</h3><p>从头节点的最高层开始，逐层遍历。在遍历到某一层的跳表节点时，会根据跳表节点中的 SDS 类型的元素和元素的权重来进行判断</p>
<ul>
<li>当<strong>当前节点的权重小于要查找的权重</strong>或<strong>当前节点的权重等于要查找的权重且当前节点的 SDS 类型数据小于要查找的数据</strong>时，跳表会访问该层的下一个节点</li>
<li>当上述两个条件不满足或该层的下一个节点为空，跳表则会跳到当前节点的下一层接着查找</li>
</ul>
<h3 id="跳表节点层数设置"><a href="#跳表节点层数设置" class="headerlink" title="跳表节点层数设置"></a>跳表节点层数设置</h3><p>跳表的相邻两层的节点数量最理想的比例是 <code>2:1</code>，查找复杂度可以降低到 <code>O(logN)</code></p>
<p>但在增删节点时，如果通过调整跳表节点来维持比例，会带来额外的开销</p>
<p>因此 Redis 采用一种巧妙的方法：跳表在创建节点的时候，随机生成每个节点的层数（在创建节点时生成一个范围为 0-1 的随机数，如果随机数小于等于 0.25，则层数加 1，然后继续生成下一个随机数，直到随机数大于 0.25）。</p>
<blockquote>
<p><code>ZSKIPLIST_MAXLEVEL</code> 定义最高层数。Redis 7.0 定义为 32，Redis 5.0 定义为 64，Redis 3.0 定义为 32</p>
</blockquote>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>双向链表和压缩列表的组合</p>
<p>压缩列表存在连锁更新的问题，而 quicklist 通过<strong>控制每个链表节点中的压缩列表的元素个数</strong>，来规避这个问题</p>
<p><img src="/images/Redis/quicklist%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="quicklist数据结构"></p>
<h3 id="quicklist-结构设计"><a href="#quicklist-结构设计" class="headerlink" title="quicklist 结构设计"></a>quicklist 结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head; <span class="comment">// 表头</span></span><br><span class="line">    quicklistNode *tail; <span class="comment">// 表尾</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count; <span class="comment">// 所有压缩列表中的总元素个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;  <span class="comment">// quicklistNodes 个数</span></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<h3 id="quicklistNode-结构设计"><a href="#quicklistNode-结构设计" class="headerlink" title="quicklistNode 结构设计"></a>quicklistNode 结构设计</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span> <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span> <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl; <span class="comment">// quicklistNode 指向的压缩列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz; <span class="comment">// 压缩列表的的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; <span class="comment">// 压缩列表的元素个数</span></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>

<p>在向 quicklist 添加一个元素时，不会直接新建一个链表节点，而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存，否则需要新建一个新的 quicklistNode 结构</p>
<h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p>quicklist 一定程度上减少了连锁更新带来的性能影响，但并没有完全解决</p>
<p>listpack 中每个节点不再记录前一个节点的长度，而是记录当前节点 <code>encoding</code> 和 <code>data</code> 的长度，这样避免了因为某个节点的更新而导致连锁更新的发生</p>
<img src="/images/Redis/listpack结构设计.png" alt="listpack结构设计" style="zoom:50%;" />



<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串 String"></a>字符串 String</h2><p>最基本的 key-value 结构，key 是唯一标识，value 是具体的值</p>
<blockquote>
<p>value 可以是字符串、数字（整数或浮点数），最多可以容纳 <code>512M</code> 的数据长度</p>
</blockquote>
<p>底层数据结构主要是 <code>int</code> 和 <code>SDS</code>（简单动态字符串）</p>
<p>字符串对象的内部编码有三种 <code>int</code>、 <code>embstr</code> 和 <code>raw</code></p>
<blockquote>
<p>编码方式选择</p>
<ul>
<li><code>int</code>：保存对象是整数值，且可以用 long 类型表示，整数值保存在字符串对象结构的 <code>ptr</code> 属性里面（将 <code>void*</code> 转换成 <code>long</code>）</li>
<li><code>embstr</code>：保存对象是长度小于等于 32 字节（redis 2.*）的字符串（redis 3.0-4.0 是 39 字节，5.0 是 44 字节），使用 <code>SDS</code> 保存</li>
<li><code>raw</code>：保存对象是长度大于 32 字节（redis 2.*）的字符串（redis 3.0-4.0 是 39 字节，5.0 是 44 字节），使用 <code>SDS</code> 保存</li>
</ul>
</blockquote>
<blockquote>
<p><code>embstr</code> 和 <code>raw</code> 的区别</p>
<ul>
<li><code>embstr</code> 会通过一次内存分配函数来分配一块连续的内存空间来保存 <code>redisObject</code> 和 <code>SDS</code>，而 <code>raw</code> 编码会通过调用两次内存分配函数来分别分配两块空间来保存 <code>redisObject</code> 和 <code>SDS</code>。</li>
</ul>
</blockquote>
<blockquote>
<p><code>embstr</code> 只进行一次内存分配的优缺点</p>
<ul>
<li>在字符串对象创建和释放时，只需要调用一次内存分配&#x2F;释放</li>
<li>数据都存放在一块连续的内存里，根据局部性原理，可以更好地利用 CPU 缓存，提升性能</li>
<li>当字符串长度增加时，整个 <code>redisObject</code> 和 <code>SDS</code> 需要重新分配空间，因此 <code>embstr</code> 编码的字符串对象实际上是只读的。在对 <code>embstr</code> 编码的字符串进行修改时，实际上是先转换成 <code>raw</code> 再修改</li>
</ul>
</blockquote>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>基本操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET key <span class="comment"># 获取 key 对应的 value</span></span><br><span class="line">SET key value <span class="comment"># 设置 key-value</span></span><br><span class="line">EXISTS key <span class="comment"># 判断 key 是否存在</span></span><br><span class="line">STRLEN key <span class="comment"># 获取 key 对应的 value 的长度</span></span><br><span class="line">DEL key	<span class="comment"># 删除 key</span></span><br></pre></td></tr></table></figure>

<p>批量操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MSET key1 value1 key2 value2 <span class="comment"># 批量设置</span></span><br><span class="line">MGET key1 key2 <span class="comment"># 批量获取</span></span><br></pre></td></tr></table></figure>

<p>计数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INCR number <span class="comment"># 数字自增</span></span><br><span class="line">INCRBY number x <span class="comment"># 数字增加 x</span></span><br><span class="line">DECR number <span class="comment"># 数字自减</span></span><br><span class="line">DECRBY number x <span class="comment"># 数字增加 x</span></span><br></pre></td></tr></table></figure>

<p>过期</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE number 60 <span class="comment"># 设置过期时间</span></span><br><span class="line">TTL number <span class="comment"># 查看多久过期</span></span><br><span class="line">SET key value EX 60 <span class="comment"># 设置值和过期时间（EX 单位为秒，PX 单位为毫秒）</span></span><br><span class="line">SETEX key value	<span class="comment"># 设置值和过期时间（EX 单位为秒，PX 单位为毫秒）</span></span><br></pre></td></tr></table></figure>

<p>不存在就插入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value	<span class="comment"># 不存在就插入</span></span><br></pre></td></tr></table></figure>



<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、缓存对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET user:1 <span class="string">&#x27;&#123;&quot;name&quot;:&quot;john&quot;, &quot;age&quot;:25&#125;&#x27;</span> <span class="comment"># 直接缓存整个对象的 JSON</span></span><br><span class="line">MSET user:1:name john user:1:age 25 <span class="comment"># 将 key 进行分离</span></span><br></pre></td></tr></table></figure>

<p>2、计数：如计算访问次数、点赞、转发、库存数量等</p>
<p>3、分布式锁：SET 命令的 <code>NX</code> 参数实现，通过是否插入成功来表示是否加锁成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET KEY VALUE NX PX 10000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解锁时需要保证执行操作的客户端就是加锁的客户端，才能将 key 删除。这是两个操作，为了保证解锁的原子性，可以通过 Lua 脚本以原子性方式执行</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, key) == value <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, key)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>4、共享 Session 信息</p>
<h2 id="哈希-Hash"><a href="#哈希-Hash" class="headerlink" title="哈希 Hash"></a>哈希 Hash</h2><p>一个键值对集合，value 的形式为：<code>value = [&#123;field1, value1&#125;, ..., &#123;fieldN, valueN&#125;]</code></p>
<p>Hash 类型的底层数据结构是由<strong>压缩列表</strong>或<strong>哈希表</strong>实现的（Redis 7.0 中，压缩列表被 <code>listpack</code> 替换）</p>
<blockquote>
<p>压缩列表：当元素个数小于 512 个且每个元素的值小于 64 字节（分别由 <code>hash-max-ziplist-entries</code> 和 <code>hash-max-ziplist-value</code> 配置）</p>
<p>哈希表：不满足上述任一条件</p>
</blockquote>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value <span class="comment"># 存储一个哈希表 key 的键值</span></span><br><span class="line">HMSET key field value [field value ...] <span class="comment"># 批量存储一个哈希表 key 的多个键值</span></span><br><span class="line"></span><br><span class="line">HGET key field <span class="comment"># 获取一个哈希表 key 对应的 field 的值</span></span><br><span class="line">HGET key field [field ...] <span class="comment"># 批量获取一个哈希表 key 对应的多个 field 的值</span></span><br><span class="line"></span><br><span class="line">HLEN key <span class="comment"># 返回哈希表 key 中 field 的数量</span></span><br><span class="line">HGETALL key <span class="comment"># 返回哈希表 key 中所有的键值</span></span><br><span class="line"></span><br><span class="line">HINCRBY key field n <span class="comment"># 为哈希表 key 中 field 键的值加上增量 n</span></span><br></pre></td></tr></table></figure>



<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、缓存对象：比如用户的详细信息、商品的详细信息</p>
<blockquote>
<p>String + Json 也是存储对象的一种方式。一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储</p>
</blockquote>
<h2 id="列表-List"><a href="#列表-List" class="headerlink" title="列表 List"></a>列表 List</h2><p>简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素</p>
<p>在 3.2 版本之前，底层数据结构是由<strong>双向链表</strong>或<strong>压缩列表</strong>实现的，在 3.2 版本之后只由 <strong>quicklist</strong> 实现</p>
<ul>
<li>压缩列表：当<strong>列表元素小于 512 个</strong>且<strong>列表每个元素的值小于 64 字节</strong>（分别由 <code>list-max-ziplist-entries</code> 和 <code>list-max-ziplist-value</code> 配置）</li>
<li>双向链表：只要不满足上述任一条件</li>
<li>quicklist：压缩列表和双向链表的混合体，它将双向链表按段切分，每一段使用压缩列表来紧凑存储，多个压缩列表之间使用双向指针串接起来</li>
</ul>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key value [value ...] <span class="comment"># 将一个或多个 value 插入到 key 列表的表头，最后面的 value 在最前面</span></span><br><span class="line">RPUSH key value [value ...] <span class="comment"># 将一个或多个 value 插入到 key 列表的表尾巴，最后面的 value 在最后面</span></span><br><span class="line"></span><br><span class="line">LRANGE key begin end <span class="comment"># 返回指定区间的数据，从 0 开始</span></span><br><span class="line"></span><br><span class="line">LPOP key <span class="comment"># 移除并返回表头的元素</span></span><br><span class="line">RPOP key <span class="comment"># 移除并返回表尾的元素</span></span><br><span class="line">BLPOP key [key ...] <span class="built_in">timeout</span> <span class="comment"># 从表头移除一个元素，如果没有则阻塞 timeout 秒，timeout 为 0 表示一直阻塞</span></span><br><span class="line">BRPOP key [key ...] <span class="built_in">timeout</span> <span class="comment"># 从表尾移除一个元素，如果没有则阻塞 timeout 秒，timeout 为 0 表示一直阻塞</span></span><br></pre></td></tr></table></figure>



<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、消息队列</p>
<ul>
<li>消息保序：使用 <code>LPUSH</code> 和 <code>RPOP</code>（或反过来）。生产者在往 List 中写入数据时，List 并不会主动地通知消费者，如果消费者一直轮询 <code>RPOP</code> 命令，则消耗了大量不必要的 CPU 性能。因此 Redis 提供了 <code>BRPOP</code>（阻塞式读取）命令，即消费者在没有读到数据时会自动阻塞，直到有新的数据写入，再开始读取。</li>
<li>消息不重复处理：需要为每个消息添加一个全局的 ID，消费者需要记录已经处理过的消息 ID</li>
<li>消息可靠性：List 类型提供了 <code>BRPOPLPUSH</code> 命令，其作用是让消费者程序从一个 List 中读取消息，同时把这个消息再插入到备份 List 里</li>
<li><strong>缺陷</strong>：不支持消费组的实现，因此不支持多个消费者消费同一条消息</li>
</ul>
<h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 Set"></a>集合 Set</h2><p>一个无序并唯一的键值集合，存储顺序与插入顺序无关</p>
<blockquote>
<p>概念和数学中个的集合基本类似，可以交集，并集，差集等</p>
<ul>
<li>但计算复杂度较高，在数据量较大的情况下执行可能会导致 Redis 实例阻塞（可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计）</li>
</ul>
</blockquote>
<blockquote>
<p>Set 类型与 List 类型的区别</p>
<ul>
<li>List 类型可以存储重复元素，Set 类型只能存储非重复数据</li>
<li>List 类型时按照元素的先后顺序进行存储，Set 是无序存储</li>
</ul>
</blockquote>
<p>底层数据结构是由<strong>哈希表</strong>或<strong>整数集合</strong>实现的</p>
<blockquote>
<p>整数集合：集合中元素个数不超过 512 个（由 <code>set-maxintset-entries</code> 配置）</p>
<p>哈希表：不满足上述条件</p>
</blockquote>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><p>常用操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...] <span class="comment"># 往集合 key 中存入元素，元素存在则忽略，若 key 不存在则新建</span></span><br><span class="line"></span><br><span class="line">SMEMBERS key <span class="comment"># 获取集合 key 中所有元素</span></span><br><span class="line">SCARD key <span class="comment"># 获取集合 key 中的元素个数</span></span><br><span class="line"></span><br><span class="line">SISMEMBER key member <span class="comment"># 判断 member 元素是否存在于集合 key 中</span></span><br><span class="line"></span><br><span class="line">SREM key member [member ...] <span class="comment"># 从集合 key 中删除元素</span></span><br><span class="line">SRANDMEMBER key [count] <span class="comment"># 从集合 key 中随机选出 count 个元素，元素不从 key 中删除</span></span><br><span class="line">SPOP key [count] <span class="comment"># 从集合 key 中随机选出 count 个元素，元素从 key 中删除</span></span><br></pre></td></tr></table></figure>

<p>运算操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...] <span class="comment"># 交集运算</span></span><br><span class="line">SINTERSTORE destination key [key ...] <span class="comment"># 将交集结果存入新集合 destination 中</span></span><br><span class="line"></span><br><span class="line">SUNION key [key ...] <span class="comment"># 并集运算</span></span><br><span class="line">SUNIONSTORE destination key [key ...] <span class="comment"># 将并集结果存入新集合 destination 中</span></span><br><span class="line"></span><br><span class="line">SDIFF key [key ...] <span class="comment"># 差集运算</span></span><br><span class="line">SDIFFSTORE destination key [key ...] <span class="comment"># 将差集结果存入新集合 destination 中</span></span><br></pre></td></tr></table></figure>



<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、点赞</p>
<p>2、共同关注：交集运算</p>
<p>3、抽奖：<code>SRANDMEMBER</code> 实现重复中奖和 <code>SPOP</code> 实现不可重复中奖</p>
<h2 id="有序集合-Zset"><a href="#有序集合-Zset" class="headerlink" title="有序集合 Zset"></a>有序集合 Zset</h2><p>相比于 Set 类型多了一个排序属性 <code>score</code>，但没有差集运算</p>
<blockquote>
<p>每个存储元素由两个值组成：有序集合的元素值和排序值。集合里的元素不能重复，排序值可以重复</p>
</blockquote>
<p>底层数据结构主要由<strong>压缩列表</strong>或<strong>跳表</strong>实现。在 Redis 7.0 中，压缩列表被 <code>listpack</code> 替换</p>
<blockquote>
<p>还包括哈希表，主要用于常数复杂度获取元素权重</p>
</blockquote>
<ul>
<li><p>压缩列表：元素个数小于 128 个且每个元素的值小于 64 字节</p>
</li>
<li><p>跳表：不满足上述任一条件时</p>
</li>
</ul>
<h3 id="ZSet-为什么不使用平衡树（如-AVL-数、红黑树等）"><a href="#ZSet-为什么不使用平衡树（如-AVL-数、红黑树等）" class="headerlink" title="ZSet 为什么不使用平衡树（如 AVL 数、红黑树等）"></a>ZSet 为什么不使用平衡树（如 AVL 数、红黑树等）</h3><p>主要是从<strong>内存占用、对范围查找的支持、实现难易程度</strong>考虑</p>
<ul>
<li><p>内存占用：平衡树每个节点包含左右节点 2 个指针，而跳表每个节点包含的指针数目平均为 $\frac{1}{1-p}$</p>
</li>
<li><p>范围查找：平衡树找到指定范围的最小值后，还需要以中序遍历的顺序继续寻找其它不超过最大值的节点，这里中序遍历并不容易实现，而跳表只需要对第 1 层链表进行若干步的遍历就可以实现</p>
</li>
<li><p>实现难度：平衡数的增删操作可能会引起子树的调整，逻辑复杂，而跳表只需要修改相邻节点的指针，操作简单快速</p>
</li>
</ul>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><p>常用操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member [[score member] ...] <span class="comment"># 往有序集合 key 中加入带分值元素</span></span><br><span class="line">ZREM key member [member ...] <span class="comment"># 往有序集合 key 中删除元素</span></span><br><span class="line">ZSCORE key member <span class="comment"># 返回有序集合 key 中元素 member 的分值</span></span><br><span class="line">ZCARD key <span class="comment"># 返回有序集合 key 中元素个数</span></span><br><span class="line">ZINCRBY key increment member <span class="comment"># 为有序集合 key 中元素 member 的分值加上 increment</span></span><br><span class="line"></span><br><span class="line">ZRANGE key start stop [WITHSCORES] <span class="comment"># 正序获取有序集合 key 从 start 下标到 stop 下标的元素</span></span><br><span class="line">ZREVRANGE key start stop [WITHSCORES] <span class="comment"># 倒序获取有序集合 key 从 start 下标到 stop 下标的元素</span></span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] <span class="comment"># 返回有序集合中指定分数区间内的成员，分数由低到高排序</span></span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count] <span class="comment"># 用于分数相同的有序集合中，返回指定成员区间内的成员，按字典正序排列</span></span><br><span class="line">ZREVRANGEBYLEX key max min [LIMIT offset count] <span class="comment"># 用于分数相同的有序集合中，返回指定成员区间内的成员，按字典倒序排列</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运算操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># numberkeys: key 的数量</span></span><br><span class="line"><span class="comment"># WEIGHTS: key 中元素对应分值的权重</span></span><br><span class="line"><span class="comment"># AGGREGATE: 相同元素分数的计算方式</span></span><br><span class="line">ZUNIONSTORE destkey numberkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] <span class="comment"># 并集计算</span></span><br><span class="line">ZINTERSTORE destkey numberkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] <span class="comment"># 交集计算</span></span><br></pre></td></tr></table></figure>



<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、排行榜</p>
<p>2、电话、姓名排序</p>
<h2 id="位图-Bitmap"><a href="#位图-Bitmap" class="headerlink" title="位图 Bitmap"></a>位图 Bitmap</h2><blockquote>
<p>2.2 版新增</p>
</blockquote>
<p>一串连续的二进制数组，可以通过偏移量定位元素</p>
<p>底层数据结构是 String 类型。String 类型会保存为二进制的字节数组，可以把 Bitmap 看作是一个 bit 数组</p>
<h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><p>基本操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SETBIT key offset value <span class="comment"># 设置值，value 只能是 0 和 1</span></span><br><span class="line">GETBIT key offset <span class="comment"># 获取值</span></span><br><span class="line">BITCOUNT key start end <span class="comment"># 获取指定范围内值为 1 的个数，start 和 end 以字节为单位</span></span><br></pre></td></tr></table></figure>

<p>运算操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BITOP [AND|OR|XOR|NOT] [result] [key1 ... keyN] <span class="comment"># BitMap 间的运算</span></span><br><span class="line"><span class="comment"># result 存储计算结果</span></span><br><span class="line"><span class="comment"># key1 … keyN 表示参与运算的 key，空格分割，not 运算只能一个 key</span></span><br><span class="line"><span class="comment"># 在处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0</span></span><br><span class="line"><span class="comment"># 返回值是目标 key 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等</span></span><br><span class="line"></span><br><span class="line">BITPOS [key] [value] <span class="comment"># 返回指定 key 中第一次出现指定 value 的位置，value 只能是 0 和 1</span></span><br></pre></td></tr></table></figure>



<h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、签到统计</p>
<p>2、判断用户登陆态</p>
<p>3、连续签到用户总数</p>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><blockquote>
<p>2.8.9 版新增</p>
</blockquote>
<p>一种用于统计基数（指统计一个集合中不重复的元素个数）的数据集合类型</p>
<p>统计规则是基于概率完成的，不是非常准确</p>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PFADD key element [element ...] <span class="comment"># 添加指定元素到 HyperLogLog 中</span></span><br><span class="line">PFCOUNT key [key ...] <span class="comment"># 返回给定 HyperLogLog 的基数估算值</span></span><br><span class="line">PFMERGE destkey sourcekey [sourcekey ...] <span class="comment"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br></pre></td></tr></table></figure>



<h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、百万级网页 UV 计数（User View）</p>
<h2 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h2><blockquote>
<p>3.2 版新增</p>
</blockquote>
<p>主要用于存储地理位置信息，并对存储的信息进行操作</p>
<p>底层数据结构是 Zset 类型</p>
<blockquote>
<p>使用 GeoHash 编码方法实现了经纬度到 Zset 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Zset 元素的权重分数。这样可以利用 Sorted Set 提供的“<strong>按权重进行有序范围查找</strong>“的特性实现<strong>搜索附近</strong>的需求</p>
</blockquote>
<h3 id="常见命令-1"><a href="#常见命令-1" class="headerlink" title="常见命令"></a>常见命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...] <span class="comment"># 存储一个或多个地理空间位置(经度、纬度、位置名称)添加到指定的 key 中</span></span><br><span class="line">GEOPOS key member [member ...] <span class="comment"># 从给定的 key 里返回所有指定位置名称的位置（经度和纬度），不存在的返回 nil</span></span><br><span class="line">GEODIST key member1 member2 [m|km|ft|mi] <span class="comment"># 返回两个给定位置之间的距离</span></span><br><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key] <span class="comment"># 根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</span></span><br></pre></td></tr></table></figure>



<h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、打车</p>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote>
<p>5.0 版新增</p>
</blockquote>
<p>专门为消息队列设计的数据类型</p>
<ul>
<li>支持消息的持久化</li>
<li>支持自动生成全局唯一 ID</li>
<li>支持 ack 确认消息的模式</li>
<li>支持消费组模式（同一个消费组里的消费者不能消费同一条消息；在创建消费组时，不同消费组指定相同位置，不同消费组的消费者可以消费同一条消息）</li>
</ul>
<blockquote>
<p>基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</p>
</blockquote>
<p>Streams 会自动使用内部队列（PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 <code>XACK</code> 命令通知 Streams 消息已经处理完成。当 Redis 重启后，消费者可以用 <code>XPENDING</code> 命令查看已读取、但尚未确认处理完成的消息。</p>
<blockquote>
<p>Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？</p>
</blockquote>
<p>能不能将 Redis 作为消息队列使用，主要取决于业务场景（当业务场景简单、对数据丢失不敏感、消息积压概率比较小时，可以使用）。一个专业的消息队列需要做到<strong>消息不丢失</strong>和<strong>消息可堆积</strong>两块</p>
<p>消息丢失问题主要考虑生产者、队列中间件和消费者三块。</p>
<ul>
<li><p>生产者会不会丢消息取决于生产者对于异常情况的处理是否合理（只有收到来自中间件的 ack 确认后才算发送成功，否则需要进行消息重发）</p>
</li>
<li><p>消费者不会出现数据丢失，这是因为 Redis 的 Stream 会自动使用内部队列（PENDING List），留存消费者读取但未处理完的消息</p>
</li>
<li><p>Redis 消息中间件可能会丢失消息</p>
<ul>
<li>持久化时丢失：AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时可能会丢失数据</li>
<li>主从复制也是异步的，主从切换时，也存在丢失数据的可能</li>
</ul>
<blockquote>
<p>像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写多个节点（副本），这样即便其中一个节点挂了，也能保证集群的数据不丢失</p>
</blockquote>
</li>
</ul>
<p>Redis 的数据都存储在内存中，一旦发生消息积压，Redis 的内存持续增长，可能面临 OOM 风险。因此 Redis 的 Stream 提供了可以指定队列最大长度的功能，但当队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息，即出现消息丢失问题。但 Kafka、RabbitMQ 专业的消息队列它们的数据都是存储在磁盘上，当消息积压时，无非就是多占用一些磁盘空间</p>
<blockquote>
<p>Redis 发布&#x2F;订阅机制为什么不可以作为消息队列？</p>
</blockquote>
<p>Redis 发布&#x2F;订阅机制存在以下缺点，都与数据丢失有关</p>
<ul>
<li>发布&#x2F;订阅机制没有基于任何数据类型实现，不具备数据持久化能力，当 Redis 宕机重启，发布&#x2F;订阅机制的数据会全部丢失</li>
<li>订阅者离线重连之后不能消费之前的历史消息</li>
<li>当消费端有一定的消息积压时（超过 32M 或者是 60s 内持续保持在 8M 以上，配置文件里设置，<code>client-output-buffer-limit pubsub 32mb 8mb 60</code>），消费端会被强行断开</li>
</ul>
<h3 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XADD key ID field value [field value ...] <span class="comment"># 添加消息，ID 为 * 时表示消息 ID 由 Redis 生成，返回值格式为 1526919030474-55，前者是 Unix 时间（以毫秒为单位），后者是一个序列号，用于区分在同一毫秒内生成的 ID</span></span><br><span class="line">XLEN key <span class="comment"># 返回 key 对应的 Stream 的条目数量</span></span><br><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] <span class="built_in">id</span> [<span class="built_in">id</span> ...] <span class="comment"># 读取消息，可以设定 BLOCK 配置项实现阻塞读</span></span><br><span class="line">XDEL key <span class="built_in">id</span> [<span class="built_in">id</span> ...] <span class="comment"># 根据消息 ID 删除消息</span></span><br><span class="line">DEL key [key ...] <span class="comment"># 删除整个 Stream</span></span><br><span class="line">XRANGE key start end [COUNT count] <span class="comment"># 读取区间消息</span></span><br><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] <span class="built_in">id</span> [<span class="built_in">id</span> ...] <span class="comment"># 按消费组形式读取消息</span></span><br><span class="line">XPENDING key group [[IDLE min-idle-time] start end count [consumer]] <span class="comment"># 用来查询每个消费组内所有消费者已读取、但尚未确认的消息</span></span><br><span class="line">XACK key group <span class="built_in">id</span> [<span class="built_in">id</span> ...] <span class="comment"># 向消息队列确认消息处理已完成</span></span><br></pre></td></tr></table></figure>

<p>消费组模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE key group &lt;<span class="built_in">id</span> | $&gt; [MKSTREAM] [ENTRIESREAD entries-read] <span class="comment"># 创建消费组</span></span><br><span class="line">XGROUP CREATECONSUMER key group consumer <span class="comment"># 创建消费者</span></span><br><span class="line">XGROUP DELCONSUMER key group consumer <span class="comment"># 删除消费者</span></span><br><span class="line">XGROUP DESTROY key group <span class="comment"># 删除消费组</span></span><br><span class="line">XGROUP SETID key group &lt;<span class="built_in">id</span> | $&gt; [ENTRIESREAD entries-read] <span class="comment"># 设置最后传递给消费组的 ID</span></span><br></pre></td></tr></table></figure>



<h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><p>1、消息队列</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 属于内存型数据库，数据都是保存在内存中的，因此一旦数据库出现故障重启，内存中的数据可能会丢失，为了保证数据不会因数据库重启而丢失，因此需要对数据库进行持久化，即将内存中的数据写入到磁盘中</p>
<p>Redis 持久化的方式有三种：</p>
<p>1、AOF：只追加文件</p>
<p>2、RDB：快照（默认的持久化方式）</p>
<p>3、混合持久化机制</p>
<h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><p>AOF 日志文件其实就是普通的文本，可以使用 <code>cat</code> 命令查看内容。只记录写操作命令，不记录读操作命令</p>
<p>默认不开启，通过修改配置文件 <code>redis.conf</code> 开启和指定 aof 文件名称</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly		yes</span><br><span class="line">appendfilename	&quot;appendonly.aof&quot;</span><br></pre></td></tr></table></figure>



<h3 id="AOF-日志内容"><a href="#AOF-日志内容" class="headerlink" title="AOF 日志内容"></a>AOF 日志内容</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3</span><br><span class="line">$3</span><br><span class="line">set</span><br><span class="line">$4</span><br><span class="line">name</span><br><span class="line">$5</span><br><span class="line">bling</span><br></pre></td></tr></table></figure>

<p><code>*3</code> 表示命令有 3 个部分，每个部门都是以 <code>$+数字</code> 开头，后面紧跟着具体的命令、键或值。这里的数字表示这部分中的命令、键或值一共有多少字节</p>
<h3 id="先执行写操作再记录到-AOF-日志的优缺点"><a href="#先执行写操作再记录到-AOF-日志的优缺点" class="headerlink" title="先执行写操作再记录到 AOF 日志的优缺点"></a>先执行写操作再记录到 AOF 日志的优缺点</h3><p>优点</p>
<p>1、先执行命令确保命令的语法正确性，这样 Redis 在进行日志恢复时可以减少额外的检查开销</p>
<p>2、不会阻塞当前写操作命令的执行</p>
<p>缺点</p>
<p>1、执行写操作命令和记录日志是两个过程，存在数据丢失风险</p>
<p>2、在将日志内容写入到硬盘时，如果服务器的硬盘的 I&#x2F;O 压力太大，导致写盘速度很慢，可能会给下一个命令带来阻塞风险</p>
<h3 id="AOF-日志写入流程"><a href="#AOF-日志写入流程" class="headerlink" title="AOF 日志写入流程"></a>AOF 日志写入流程</h3><p>1、Redis 在执行完写操作命令后，将其追加到 <code>server.aof_buf</code> 缓冲区</p>
<p>2、通过 <code>write()</code> 系统调用，将 <code>aof_buf</code> 缓冲区的数据拷贝到内核缓冲区 pageCache</p>
<p>3、内核根据磁盘刷盘策略，再写入到磁盘的 aof 文件里</p>
<h3 id="Redis-提供的硬盘写回策略"><a href="#Redis-提供的硬盘写回策略" class="headerlink" title="Redis 提供的硬盘写回策略"></a>Redis 提供的硬盘写回策略</h3><blockquote>
<p>在 <code>redis.conf</code> 配置文件中的 <code>appendfsync</code> 配置，控制 <code>fsync()</code> 函数的调用时机</p>
</blockquote>
<ul>
<li><code>always</code>：每次写操作都会立马写入硬盘，即每次写入 AOF 文件数据后，就执行 <code>fsync()</code> 函数。这种策略最大程度保证数据不丢失，但严重降低主进程的性能</li>
<li><code>everysec</code>：每秒钟同步一次，即创建一个异步任务来执行 <code>fsync()</code> 函数。这是一种折中的做法，在保证性能的同时，在系统宕机时最多只会丢失一秒之内的数据</li>
<li><code>no</code>：永不主动执行 <code>fsync()</code> 函数，让操作系统决定，写回时机不可预知，如果发生宕机，可能会丢失大量数据</li>
</ul>
<h3 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h3><p>如果采用追加写方式，会导致 AOF 文件过大，带来明显的 IO 性能问题（Redis 重启恢复时，读 AOF 文件的时间开销很大），因此可以利用 AOF 重写机制解决。</p>
<p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到新的 AOF 文件里，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件</p>
<p>之所以先写到新的 AOF 文件再覆盖过去，是为了防止 AOF 重写失败，导致对 AOF 文件造成污染</p>
<h3 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h3><p>AOF 重写是一个耗时的过程，如果放在主进程完成，会阻塞主进程。因此需要开启一个后台子进程 <code>bgrewriteaof</code> 来完成</p>
<blockquote>
<p>为什么使用子进程进行 AOF 重写，而不是线程？</p>
</blockquote>
<p>多线程之间会共享内存，在修改共享内存时需要通过<strong>加锁</strong>保证数据的安全，会影响性能</p>
<p>而子进程虽然也与父进程共享内存数据，但这些数据是<strong>只读</strong>的，当父子进程任意一方修改了共享内存，就会发生<strong>写时复制</strong>，即主进程通过 <code>fork</code> 系统调用生成 <code>bgrewriteaof</code> 子进程时，操作系统会把主进程的<strong>页表</strong>复制一份给子进程（此时是指向相同的物理地址），当发生数据修改时，会触发<strong>写保护中断</strong>，此时才对需要修改的位置进行复制。这样父子进程都有了独立的数据副本，无需加锁</p>
<p>当然操作系统在复制父进程页表时，父进程是阻塞的，不过页表大小相比实际的物理内存小得多，因此通常复制页表的过程是比较快的</p>
<blockquote>
<p>重写过程中还能处理其它用户命令吗，如何保证重写前后的数据一致性？</p>
</blockquote>
<p>重写操作是在子进程完成的，主进程还可以继续处理其它用户操作</p>
<p>在重写过程中，执行的命令会写入到 <strong>AOF 重写缓冲区</strong>和 <strong>AOF 缓冲区</strong>，<strong>保证了重写过程中的数据一致性</strong>。子进程完成 AOF 重写工作后，会向父进程发送一条信号（进程间通信的一种，异步的）</p>
<p>主进程受到信号后，会调用一个信号处理函数。该函数会将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；然后再将新的 AOF 的文件进行改名，并覆盖现有的 AOF 文件</p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>记录的是整个 Redis 数据库在内存里的数据（快照），二进制形式</p>
<p>RDB 文件的加载工作是 Redis 启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令</p>
<h3 id="RDB-持久化的触发方式"><a href="#RDB-持久化的触发方式" class="headerlink" title="RDB 持久化的触发方式"></a>RDB 持久化的触发方式</h3><p>一共有 <code>bgsave</code> 和 <code>save</code> 两种，它们的区别就在于<strong>是否在主线程里执行</strong>。</p>
<ul>
<li><p><code>save</code>：同步快照，如果写入 RDB 文件的时间太长，会阻塞主线程</p>
</li>
<li><p><code>bgsave</code>：异步快照，会创建一个子进程来生成 RDB 文件，可以避免主线程的阻塞</p>
</li>
</ul>
<p><code>bgsave</code> 可以通过配置文件实现定时任务，默认配置为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 <span class="comment"># 900 秒之内，对数据库进行了至少 1 次修改</span></span><br><span class="line">save 300 10 <span class="comment"># 300 秒之内，对数据库进行了至少 10 次修改</span></span><br><span class="line">save 60 10000 <span class="comment"># 60 秒之内，对数据库进行了至少 10000 次修改</span></span><br></pre></td></tr></table></figure>

<p>除此之外，RDB 持久化在主从复制时也会触发</p>
<h3 id="执行-bgsave-时能修改数据吗"><a href="#执行-bgsave-时能修改数据吗" class="headerlink" title="执行 bgsave 时能修改数据吗"></a>执行 bgsave 时能修改数据吗</h3><p>能，RDB 持久化由子进程执行，当主进程发生数据修改时，会利用<strong>写时复制技术</strong>复制多一份需要修改的内存数据，但修改的数据是无法在这次持久化操作中写入到 RDB 文件的</p>
<p>写时复制会出现一个极端情况，即所有共享的内存都发生修改，则 Redis 需要占用原本两倍的内存</p>
<h3 id="RDB-持久化的优缺点"><a href="#RDB-持久化的优缺点" class="headerlink" title="RDB 持久化的优缺点"></a>RDB 持久化的优缺点</h3><p>优点</p>
<p>1、全量备份，适用于备份和恢复</p>
<p>2、采用二进制的压缩文件存储，文件小，恢复速度快</p>
<p>缺点</p>
<p>1、快照是一个比较重的操作，因此频率不能设置得太频繁，这就意味着当 Redis 宕机时会比 AOF 丢失更多数据</p>
<h2 id="RDB-和-AOF-的混合持久化机制"><a href="#RDB-和-AOF-的混合持久化机制" class="headerlink" title="RDB 和 AOF 的混合持久化机制"></a>RDB 和 AOF 的混合持久化机制</h2><blockquote>
<p>4.0 版本之后支持，默认是关闭的，通过配置项 <code>aof-use-rdb-preamble</code> 开启</p>
</blockquote>
<p>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</p>
<p>1、主进程会 <code>fork</code> 出一个重写子进程，先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件</p>
<p>2、主进程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件</p>
<p>3、通知主进程替换旧的 AOF 文件</p>
<h3 id="混合持久化机制的优缺点"><a href="#混合持久化机制的优缺点" class="headerlink" title="混合持久化机制的优缺点"></a>混合持久化机制的优缺点</h3><p>优点</p>
<p>1、混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，有减低了大量数据丢失的风险</p>
<p>缺点</p>
<p>1、AOF 文件中添加了 RDB 格式的内容，使得 AOF 文件的可读性变得很差</p>
<p>2、兼容性差，如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了</p>
<h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><h2 id="Redis-如何判定-Key-已经过期？"><a href="#Redis-如何判定-Key-已经过期？" class="headerlink" title="Redis 如何判定 Key 已经过期？"></a>Redis 如何判定 Key 已经过期？</h2><p>在对一个 Key 设置过期时间时，Redis 会将该 Key 和过期时间存储到一个过期字典中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict; <span class="comment">// 存放着所有的键值对</span></span><br><span class="line">    dict *expires; <span class="comment">// 存放设置了过期时间的 Key 和相应的过期时间</span></span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>过期字典的数据结构</p>
<ul>
<li>key 是一个指针，指向某个键对象</li>
<li>value 是一个 long long 类型整数，存放过期时间</li>
</ul>
<p>当我们查询一个 Key 时，Redis 首先会检查该 Key 是否存放在过期字典中</p>
<ul>
<li>如果不在，则正常读取</li>
<li>如果存在，则会获取该 Key 的过期时间，并与当前系统时间比较，来判断是否过期</li>
</ul>
<h2 id="内存过期策略"><a href="#内存过期策略" class="headerlink" title="内存过期策略"></a>内存过期策略</h2><p>常见的三种过期删除策略</p>
<ul>
<li>定时删除：在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作<ul>
<li>优点：保证过期 key 会被尽快删除，内存可以被尽快地释放，对内存是最友好的</li>
<li>缺点：在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，对 CPU 是不友好的</li>
</ul>
</li>
<li>惰性删除：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key<ul>
<li>优点：只会使用很少的系统资源，对 CPU 时间最友好</li>
<li>缺点：造成了一定的内存空间浪费。对内存是不友好</li>
</ul>
</li>
<li>定期删除：每隔一段时间随机从数据库中取出一定数量的 key 进行检查，并删除其中的过期 key<ul>
<li>优点：通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用</li>
<li>缺点<ul>
<li>内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少</li>
<li>难以确定删除操作执行的时长和频率</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Redis 选择<strong>惰性删除 + 定期删除</strong>这两种策略配合使用</p>
<h2 id="Redis-持久化时，对过期键会如何处理"><a href="#Redis-持久化时，对过期键会如何处理" class="headerlink" title="Redis 持久化时，对过期键会如何处理"></a>Redis 持久化时，对过期键会如何处理</h2><p>RDB 文件</p>
<ul>
<li>文件生成阶段：从内存状态持久化成 RDB 文件时，会对 key 进行过期检查，过期的键不会被保存到新的 RDB 文件中，因此 Redis 中的过期键不会对生成新 RDB 文件产生任何影响</li>
<li>文件加载阶段：<ul>
<li>主服务器：在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键不会被载入到数据库中。所以过期键不会对载入 RDB 文件的主服务器造成影响</li>
<li>从服务器：在载入 RDB 文件时，不论键是否过期都会被载入到数据库中。但由于主从服务器在进行数据同步时，从服务器的数据会被清空。所以一般来说，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
</li>
</ul>
<p>AOF 文件</p>
<ul>
<li>文件写入阶段：如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值。</li>
<li>AOF 重写阶段：执行 AOF 重写时，会对 Redis 中的键值对进行检查，已过期的键不会被保存到重写后的 AOF 文件中，因此不会对 AOF 重写造成任何影响</li>
</ul>
<h2 id="Redis-主从模式中，对过期键会如何处理"><a href="#Redis-主从模式中，对过期键会如何处理" class="headerlink" title="Redis 主从模式中，对过期键会如何处理"></a>Redis 主从模式中，对过期键会如何处理</h2><p>Redis 运行在主从模式下时，<strong>从库不会进行过期扫描，从库对过期的处理是被动的</strong>。从库的过期键处理依靠主服务器控制，主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的 key。</p>
<h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>指内存使用率达到了 <code>maxmemory</code> 的上限时 Redis 的一种内存释放行为（在 64 位系统中，<code>maxmemory</code> 默认为 0，即没有内存大小限制，而 32 位系统默认为 3G）</p>
<p>Redis 内存淘汰策略共有八种，可以分为<strong>不进行数据淘汰</strong>和<strong>进行数据淘汰</strong>两类策略</p>
<ul>
<li>不进行数据淘汰<ul>
<li><code>noeviction</code>：Redis 3.0 之后默认的内存淘汰策略。如果超过最大设置内存时继续写入，会触发 OOM</li>
</ul>
</li>
<li>进行数据淘汰<ul>
<li>在设置了过期时间的数据中淘汰<ul>
<li><code>volatile-random</code>：随机淘汰设置了过期时间的任意键值</li>
<li><code>volatile-ttl</code>：优先淘汰更早过期的键值。</li>
<li><code>volatile-lru</code>：Redis 3.0 之前默认的内存淘汰策略。淘汰所有设置了过期时间的键值中，最久未使用的键值</li>
<li><code>volatile-lfu</code>：Redis 4.0 后新增的内存淘汰策略。淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
</ul>
</li>
<li>在所有数据范围内进行淘汰<ul>
<li><code>allkeys-random</code>：随机淘汰任意键值</li>
<li><code>allkeys-lru</code>：淘汰整个键值中最久未使用的键值</li>
<li><code>allkeys-lfu</code>：Redis 4.0 后新增的内存淘汰策略。淘汰整个键值中最少使用的键值</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>可以通过 <code>config get maxmemory-policy</code> 查看内存淘汰策略</p>
<p>可以通过 <code>config set maxmemory-policy</code> 设置内存淘汰策略，Redis 重启后失效；也可以在配置文件中修改</p>
</blockquote>
<h2 id="为什么需要新增-LFU-内存淘汰算法？"><a href="#为什么需要新增-LFU-内存淘汰算法？" class="headerlink" title="为什么需要新增 LFU 内存淘汰算法？"></a>为什么需要新增 LFU 内存淘汰算法？</h2><p>传统 LRU 算法是基于链表实现的，链表中的元素按操作顺序从前往后排列，最新操作的键会被移动到表头。当需要内存淘汰时，只需要删除链表尾部的元素即可</p>
<p>传统 LRU 算法存在两个缺陷</p>
<ul>
<li>需要用链表管理所有的缓存数据，带来额外的空间开销</li>
<li>当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能</li>
</ul>
<p>Redis 并没有使用这种方式实现 LRU 算法，而是采用一种近似 LRU 算法，以更好的节约内存。它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。当 Redis 进行内存淘汰时，会随机选取 5 个值（可配置），然后淘汰最久没有使用的那个</p>
<p>这种方式的优点</p>
<ul>
<li>不用为所有的数据维护一个大链表，节省了空间占用</li>
<li>不用在每次数据访问时都移动链表项，提升了缓存的性能</li>
</ul>
<p>但也存在缺点，即无法解决缓存污染问题（比如一次性读取大量只读取一次的数据，这些数据会存留在 Redis 缓存中很长一段时间，造成缓存污染）</p>
<p>LFU 算法是根据数据访问次数来淘汰数据的，在 Redis 对象的结构中，存在一个 <code>lru</code> 字段，用于记录数据的访问频次。与 LRU 算法的 <code>lru</code> 字段不同（记录 key 的访问时间戳），LFU 算法的 <code>lru</code> 字段分为两段来存储。其中高 16 bit 为 <code>ldt</code>，用来存储key 的访问时间戳；低 8 bit 为 <code>logc</code>，用来存储 key 的访问频次，随时间推移而衰减，初始值为 5。</p>
<p>在每次 key 被访问时，会先对 <code>logc</code> 做一个衰减操作，然后再按照一定概率增加 <code>logc</code> 的值。Redis 配置文件提供了两个配置项，用于控制 <code>logc</code> 的增长和衰减</p>
<ul>
<li><code>lfu-decay-time</code>：用于调整 <code>logc</code> 的衰减速度，它是一个以分钟为单位的数值，默认值为1，<code>lfu-decay-time</code> 值越大，衰减越慢</li>
<li><code>lfu-log-factor</code>：用于调整 <code>logc</code> 的增长速度，<code>lfu-log-factor</code> 值越大，logc 增长越慢</li>
</ul>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>Redis 提供了主从复制模式，可以保证多台服务器的数据一致性，且主从服务器之间采用的是<strong>读写分离</strong>的方式</p>
<p>主服务器可以进行<strong>读写操作</strong>，当发生写操作时自动将写操作同步给从服务器，而从服务器一般是<strong>只读</strong>，接受并执行主服务器同步过来的写操作命令</p>
<h3 id="主从服务器如何建立第一次同步的"><a href="#主从服务器如何建立第一次同步的" class="headerlink" title="主从服务器如何建立第一次同步的"></a>主从服务器如何建立第一次同步的</h3><p>主从服务器间的第一次同步的过程可分为三个阶段</p>
<img src="/images/Redis/主从服务器第一次同步.png" alt="主从服务器第一次同步" style="zoom:50%;" />

<p>1、建立链接、协商同步</p>
<ul>
<li><p>可以使用 <code>replicaof</code>（Redis 5.0 之前使用 <code>slaveof</code>）形成主从服务器的关系</p>
</li>
<li><p>从服务器建立起连接后，会发送 <code>psync [runID] [offset]</code> 给主服务器。每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己，由于是第一次连接，从服务器还不知道主服务器的 <code>runID</code>，所以将其设置为 <code>?</code>；<code>offset</code> 用于表示复制进度，第一次同步时，值为 <code>-1</code></p>
</li>
<li><p>主服务器接收到 <code>psync</code> 命令后，会发送 <code>FULLRESYNC [runID] [offset]</code> 响应从服务器，告诉从服务器接下来将进行一次全量复制。这里的 <code>runID</code> 和 <code>offset</code> 分别表示主服务器的 <code>runID</code> 和主服务器目前的复制进度 <code>offset</code></p>
</li>
</ul>
<p>2、主服务器同步数据给从服务器</p>
<ul>
<li>主服务器会执行 <code>bgsave</code> 命令异步生成 RDB 文件，并发送给从服务器</li>
<li>从服务器收到 RDB 文件后，会先清空当前的数据，再载入 RDB 文件</li>
</ul>
<p>3、主服务器发送新写操作命令给从服务器</p>
<ul>
<li>在主服务器生成、发送 RDB 文件和从服务器载入 RDB 文件这三个时间间隙，主服务器收到的写操作命令会写入到 <code>replication buffer</code> 缓冲区中，用于保证主从服务器的数据一致性。</li>
<li>从服务器在完成 RDB 文件载入后，会发送给主服务器确认信息。主服务器在收到信息后，会将 <code>replication buffer</code> 缓冲区中的写命令发送给从服务器，让从服务器执行</li>
</ul>
<h3 id="什么是命令传播？"><a href="#什么是命令传播？" class="headerlink" title="什么是命令传播？"></a>什么是命令传播？</h3><p>主从服务器在完成第一次同步后，双方之间就会维护一个<strong>基于长连接的 TCP 连接</strong>，长连接可以避免频繁的 TCP 连接和断开带来的性能开销</p>
<p>这个连接用于后续主从服务器之间的写操作命令的传播，保证第一次同步后的主从服务器的数据一致性。</p>
<p>这个过程被称为<strong>基于长连接的命令传播</strong></p>
<h3 id="如果有多个从服务器，如何减少主服务器的压力"><a href="#如果有多个从服务器，如何减少主服务器的压力" class="headerlink" title="如果有多个从服务器，如何减少主服务器的压力"></a>如果有多个从服务器，如何减少主服务器的压力</h3><p>在主从服务器的第一次数据同步过程中，RDB 文件的生成和传输是十分耗时的。主服务器可以有多个从服务器，但如果从服务器的数量非常多，且都与主服务器进行全量同步的话，会有两个问题</p>
<ul>
<li>由于是通过 <code>bgsave</code> 命令来生成 RDB 文件的，那么主服务器就会忙于使用 <code>fork() </code>创建子进程；如果主服务器的内存数据非大，在执行 <code>fork()</code> 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求</li>
<li>传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响</li>
</ul>
<p>因此，从服务器可以拥有自己的从服务器，这样主服务器需要同步的从服务器数量就会大幅减少</p>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>在 Redis 2.8 之前，如果主从服务器在命令同步时出现网络异常，从服务器需要重新与主服务器进行一次全量复制，这样的开销太大。因此从 Redis 2.8 开始，当网络断开又恢复正常后，主从服务器会采用增量复制的方式继续同步</p>
<img src="/images/Redis/增量复制.png" alt="增量复制" style="zoom:50%;" />

<ul>
<li>从服务器在恢复网络后，发送 <code>psync [runID] [offset]</code> 给主服务器，这里的 <code>offset</code> 不是 <code>-1</code>，而是上次同步的偏移量</li>
<li>主服务器收到该命令后，然后用 <code>CONTINUE</code> 响应命令告诉从服务器接下来采用增量复制的方式同步数据</li>
<li>然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令</li>
</ul>
<h3 id="主服务器怎么知道需要发送哪些增量数据给从服务器？"><a href="#主服务器怎么知道需要发送哪些增量数据给从服务器？" class="headerlink" title="主服务器怎么知道需要发送哪些增量数据给从服务器？"></a>主服务器怎么知道需要发送哪些增量数据给从服务器？</h3><p>在主服务器进行命令传播时，写命令不仅会发送给从服务器，还会写入到<code>repl_backlog_buffer</code> 缓冲区里。这个缓冲区是一个环形缓冲区，主服务器使用 <code>master_repl_offset</code> 记录自己写的位置，从服务器使用 <code>slave_repl_offset</code> 记录自己读的位置。</p>
<p>当网络断开又恢复后，从服务器会通过 <code>psync</code> 命令将自己的 <code>slave_repl_offset</code> 发送给主服务器，主服务器根据自己的 <code>master_repl_offset</code> 和 <code>slave_repl_offset</code> 的距离，来选择同步操作方式。如果从服务器需要读取的数据还在缓冲区中，则采用增量同步方式，否则采用全量同步方式</p>
<p><code>repl_backlog_buffer</code> 缓行缓冲区的默认大小是 1M。由于其是一个环形缓冲区，则缓存区写满时会进行覆盖操作。如果缓冲区大小设置过小，则从服务器在网络恢复后需要同步的数据大概率已经被覆盖，主服务器就需要频繁使用全量复制的方式。因此设置 <code>repl_backlog_buffer</code> 的大小可以根据这个公式估算<br>$$<br>\text{seconds} \times \text{write_size_per_second}<br>$$</p>
<ul>
<li><code>second</code>：从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）</li>
<li><code>write_size_per_second</code>：主服务器平均每秒产生的写命令数据量大小</li>
</ul>
<h3 id="在主从复制架构中，过期-Key-如何处理？"><a href="#在主从复制架构中，过期-Key-如何处理？" class="headerlink" title="在主从复制架构中，过期 Key 如何处理？"></a>在主从复制架构中，过期 Key 如何处理？</h3><p>当主节点处理了一个 Key 或通过淘汰算法淘汰了一个 Key，主节点会模拟一条 <code>del</code> 命令发送给从节点，让从节点删除该 Key</p>
<h3 id="主从复制中-replication-buffer-和-repl-backlog-buffer-的区别"><a href="#主从复制中-replication-buffer-和-repl-backlog-buffer-的区别" class="headerlink" title="主从复制中 replication buffer 和 repl_backlog_buffer 的区别"></a>主从复制中 <code>replication buffer</code> 和 <code>repl_backlog_buffer</code> 的区别</h3><p>1、出现的阶段不同</p>
<ul>
<li><code>repl_backlog_buffer</code> 出现在增量复制阶段，一个主节点只分配一个 <code>repl_backlog_buffer</code></li>
<li><code>replication buffer</code>是在全量复制阶段和增量复制阶段都会出现，主节点会给每个新连接的从节点，分配一个 <code>replication buffer</code></li>
</ul>
<p>2、都有大小限制，但缓冲区满时，进行的操作不同</p>
<ul>
<li><code>repl_backlog_buffer</code> 是一个环形结构，会直接覆盖起始位置数据</li>
<li><code>replication buffer</code> 满时会导致连接断开，删除缓存，从节点重新连接，重新开始全量复制</li>
</ul>
<h3 id="主从切换时如何减少数据丢失"><a href="#主从切换时如何减少数据丢失" class="headerlink" title="主从切换时如何减少数据丢失"></a>主从切换时如何减少数据丢失</h3><p>主从切换过程中，产生数据丢失的情况有两种</p>
<p><strong>1、异步复制同步丢失</strong></p>
<p>Redis 主从节点之间的数据复制是异步的，如果主节点的写操作没有来得及同步给从节点就断电了，主节点内存中的数据就丢失了。</p>
<p>为了减少这种情况的数据丢失，可以在修改配置项 <code>min-slaves-max-lag</code>，即当所有的从节点数据复制和同步的延迟都超过了阈值时，主节点就会拒绝接收任何请求，来减少未来宕机后损失的数据。</p>
<p>对于客户端，如果发现主节点不可用后，可以采取降级措施，将数据暂时写入本地缓存和磁盘中，等主节点恢复后再重新写入；或者将数据写入 Kafka 消息队列，等主节点恢复后再去消费 Kafka 中的数据，重新写入到主节点</p>
<p><strong>2、集群产生脑裂数据丢失</strong></p>
<p>在一主多从的部署方式下，主节点的网络出现了异常，与所有从节点都失联了，但与客户端的网络是正常的；</p>
<p>此时客户端不知道 Redis 内部已经出现了问题，依旧向主节点写数据，这些数据被主节点缓存到缓冲区里，但无法同步给从节点；</p>
<p>哨兵也发现主节点失联了，认为主节点已经挂了，就会从从节点中选举出一个新的主节点，此时 Redis 集群有两个主节点，出现脑裂现象；</p>
<p>当主节点网络恢复后，由于哨兵已经选举出一个新的主节点，旧的主节点就会降级为从节点，并向新的主节点请求数据同步。由于第一次同步是全量复制，会清空本地的数据，这便导致旧主节点网络异常阶段中的数据丢失</p>
<p>因此，可以给主节点的<strong>从节点连接数</strong>和<strong>主从数据复制和同步的延迟</strong>设置阈值，当任意一个参数达到阈值时，主节点就会无法接收客户端的写请求</p>
<h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>Redis 2.8 版本之后提供，实现了主从节点故障转移。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p>
<p>哨兵是一个运行在特殊模式下的 Redis 进程，它主要负责<strong>监控、选主和通知</strong>三件事情</p>
<p>1、监控</p>
<ul>
<li>哨兵每秒都会给每个 Redis 节点发送 <code>PING</code> 命令，如果 Redis 正常返回响应命令，则该节点正常</li>
<li>如果主节点或从节点没有在规定的时间（配置项 <code>down-after-milliseconds</code> 配置）内响应哨兵的 PING 命令，哨兵则会标记它们为<strong>主观下线</strong>。</li>
<li>因为主节点可能由于系统压力比较大或网络发送了拥塞，导致没有在规定时间内响应哨兵的 PING 命令。为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成哨兵集群（最少需要三台机器来部署哨兵集群，哨兵之间也会相互监督），通过多个哨兵节点一起判断，避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况。因此，当一个哨兵判断主节点为<strong>主观下线</strong>后，就会向其他哨兵发起命令，让其他哨兵根据自身和主节点的网络状况，来判断主节点是否下线。如果赞成主节点下线数量达到 <code>quorum</code> 值（通常是 $\frac{\text{哨兵数量}}{2} + 1$），则主节点为<strong>客观下线</strong>。</li>
</ul>
<p>2、选主</p>
<ul>
<li>当主节点被哨兵判断为<strong>客观下线</strong>后，该哨兵就作为进行主从故障转移的候选者。每个哨兵只有一次投票机会，只有候选者可以投给自己，在投票过程中，任何一个候选者，满足<strong>拿到半数以上的赞成票</strong>和<strong>拿到的票数大于等于哨兵配置文件中的 <code>quorum</code> 值</strong>这两个条件，就成为进行主从故障转移的 Leader。</li>
<li>Leader 需要在已下线主节点（旧主节点）属下的所有从节点里，按照网络状况、优先级、复制进度和 ID 号筛选出一个状态良好、数据完整的从节点，并将其转换为主节点。</li>
</ul>
<p>3、通知</p>
<ul>
<li>让已下线主节点属下的所有从节点修改复制目标，修改为复制新主节点</li>
<li>将新主节点的 IP 地址和信息，通过<strong>发布者&#x2F;订阅者机制</strong>通知给客户端</li>
<li>继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点</li>
</ul>
<h3 id="哨兵集群是如何组成的？"><a href="#哨兵集群是如何组成的？" class="headerlink" title="哨兵集群是如何组成的？"></a>哨兵集群是如何组成的？</h3><blockquote>
<p>哨兵节点之间是如何相互发现的？</p>
</blockquote>
<p>通过 Redis 的发布者&#x2F;订阅者机制。在主从集群中，主节点上有一个名为 <code>__sentinel__:hello</code> 的频道，不同哨兵就是通过它来相互发现，实现互相通信的。当哨兵 A 把自己的 IP 地址和端口的信息发布到 <code>__sentinel__:hello</code> 频道上，哨兵 B 和 C 订阅了该频道时，哨兵 B 和 C 就可以从这个频道直接获取哨兵 A 的 IP 地址和端口号。然后与哨兵 A 建立网络连接</p>
<blockquote>
<p>哨兵是如何知道从节点信息的？</p>
</blockquote>
<p>主节点知道所有从节点的信息，因此哨兵每十秒向主节点发送一次 <code>INFO</code> 命令，来获取所有从节点的信息，并与每个从节点建立连接</p>
<h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><p>实现了 Redis 的分布式存储，即每个节点存储不同的数据，实现数据的分片功能</p>
<p>在存储数据时，会对 Key 进行 <code>CRC16</code> 计算，并对 <code>16384</code> 取模。通过 Slot 槽实现数据分片，Slot 的整体取值范围为 <code>[0, 16383]</code>，每个节点会分配一个 Slot 区间</p>
<p>在高可用方面，引入了主从复制模式，一个 Master 节点对应一个或多个 Slave 节点，当 Master 节点挂掉后，会自动从 Slave 节点中选举出一个新的 Master 节点</p>
<p>优点：实现了在线扩容功能</p>
<p>缺点</p>
<ul>
<li>Slave 节点只起到冷备作用，不提供读写分离的功能</li>
<li>Redis 批量操作指令受到限制</li>
</ul>
<h3 id="哨兵集群和-Redis-Cluster-的区别"><a href="#哨兵集群和-Redis-Cluster-的区别" class="headerlink" title="哨兵集群和 Redis Cluster 的区别"></a>哨兵集群和 Redis Cluster 的区别</h3><ul>
<li>Slave 节点的区别：哨兵集群是基于主从集群的，可以提供读写分离的功能，而 Redis Cluster 的 Slave 节点只用于冷备作用</li>
<li>哨兵集群无法实现在线扩容，其并发压力受限于单个服务器资源的配置；而 Redis Cluster 使用 Slot 槽实现了数据分片功能，可以在线扩容</li>
<li>从架构层面，哨兵集群是一主多从，而 Redis Cluster 是多主多从</li>
</ul>
<h3 id="为什么-Redis-Cluster-的最大槽数是-16384"><a href="#为什么-Redis-Cluster-的最大槽数是-16384" class="headerlink" title="为什么 Redis Cluster 的最大槽数是 16384"></a>为什么 Redis Cluster 的最大槽数是 16384</h3><blockquote>
<p>是消息大小和主机持有的平均 Slot 数之间权衡的结果</p>
</blockquote>
<p>1、对于网络通信开销的平衡。Redis 集群中每个节点会发送心跳消息，每个插槽会占用 1 位，采用 16384 个插槽，总占用空间为 2 KB（16384&#x2F;8&#x2F;1024），而采用 65536 个插槽（CRC16 可以产生 $2^{16}$ 个值），总占用空间为 8 KB，消息头过大</p>
<p>2、集群规模的限制。Redis Cluster 不太可能超过 1000 个节点，节点数量过多在导致网络拥堵（大量的心跳消息包）</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>大量缓存数据在<strong>同一时间过期（失效）</strong>或者 <strong>Redis 故障宕机</strong>，原本缓存组件能够扛住的大部分流量全部请求到了数据库，导致数据库压力剧增，造成数据库服务器宕机，从而形成一系列连锁反应，造成整个系统崩溃</p>
<blockquote>
<p>解决措施</p>
</blockquote>
<p>1、大量数据同时过期</p>
<ul>
<li>均匀设置过期时间：在对缓存数据设置过期时间时，给过期时间加上一个随机数，保证数据不会在同一时间过期</li>
<li>互斥锁：当访问的数据不在 Redis 时，需要申请互斥锁（最好设置超时时间），保证同一时间内只有一个请求来构建缓存（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</li>
<li>后台更新缓存：数据不设置有效期，更新缓存的工作由后台线程定时完成</li>
</ul>
<p>2、Redis 故障宕机</p>
<ul>
<li>服务熔断或请求限流机制（缓存雪崩发生后的应对方案）</li>
<li>通过主从节点的方式构建 Redis 缓存高可靠集群</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存中某个热点数据过期，而此时存在大量请求访问了该热点数据，Redis 无法起到缓存作用，请求都会去访问数据库，导致数据库压力剧增，造成数据库服务器宕机，从而形成一系列连锁反应，造成整个系统崩溃</p>
<blockquote>
<p>解决措施</p>
</blockquote>
<p>1、均匀设置过期时间：在对缓存数据设置过期时间时，给过期时间加上一个随机数，保证数据不会在同一时间过期</p>
<p>2、互斥锁：当访问的数据不在 Redis 时，需要申请互斥锁（最好设置超时时间），保证同一时间内只有一个请求来构建缓存（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>查询一个根本不存在的数据，缓存层和存储层都不会命中，无构建缓存数据以服务后续的需求。一旦查询量过大，这些请求都会落到数据库，导致数据库压力剧增，造成数据库服务器宕机，从而形成一系列连锁反应，造成整个系统崩溃</p>
<blockquote>
<p>造成缓存穿透的原因</p>
</blockquote>
<p>1、业务代码有误</p>
<p>2、业务误操作，缓存和数据库中的数据都被误删了</p>
<p>3、黑客恶意攻击，故意大量访问某些读取不存在数据的业务</p>
<blockquote>
<p>缓存穿透的解决办法</p>
</blockquote>
<p>1、非法请求的限制：在 API 入口处判断请求参数是否合理、请求参数是否含有非法值、请求字段是否存在，进而拦截恶意请求</p>
<p>2、缓存空值或者默认值，缺点是增加缓存的存储空间，缓存层和存储层的数据会存在一段时间窗口的不一致</p>
<p>3、使用布隆过滤器拦截，在应用启动时把存在的数据缓存到布隆过滤器中，每次请求需要先经过过滤器，如果数据不存在则无需请求数据库</p>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>由初始值都为 <strong>0 的位图数组</strong>和 <strong>N 个哈希函数</strong>组成，主要作用是用来<strong>检索元素是否在给定的特大集合的数据结构中</strong></p>
<blockquote>
<p> 添加元素</p>
</blockquote>
<ul>
<li>使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值</li>
<li>将 N 个哈希值对位图数组的长度取模</li>
<li>将每个哈希值在位图数组的对应位置的值设置为 1</li>
</ul>
<blockquote>
<p> 查询元素</p>
</blockquote>
<ul>
<li>使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值</li>
<li>将 N 个哈希值对位图数组的长度取模</li>
<li>判断位数组中相应位置的每个元素是否都是 1，只要有一个 0 说明元素不存在，否则有可能存在</li>
</ul>
<h2 id="数据库与缓存如何保证数据一致性"><a href="#数据库与缓存如何保证数据一致性" class="headerlink" title="数据库与缓存如何保证数据一致性"></a>数据库与缓存如何保证数据一致性</h2><blockquote>
<p>引入缓存后，在数据更新时，先更新数据库再更新缓存，或先更新缓存再更新数据库，可以吗？</p>
</blockquote>
<p>不行，都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。</p>
<h3 id="Cache-Aside-策略（旁路缓存策略）"><a href="#Cache-Aside-策略（旁路缓存策略）" class="headerlink" title="Cache Aside 策略（旁路缓存策略）"></a>Cache Aside 策略（旁路缓存策略）</h3><p>在写数据时，先更新数据库，再删除缓存中的数据</p>
<p>在读数据时，先从缓存中读取，如果没有命中，则从数据库中读取，并更新缓存</p>
<blockquote>
<p>在写数据时，为什么不是先删除缓存，再更新数据库？</p>
</blockquote>
<p>会出现数据库数据与缓存的数据不一致现象，在删除缓存和更新数据库操作之间，有另外一个读操作完成了，这就导致缓存中的旧数据依旧存在，而数据库的数据已经发生变更</p>
<blockquote>
<p>在写数据时，先更新数据库，再删除缓存中的数据，就不会出现数据不一致吗？</p>
</blockquote>
<p>其实也会，比如在一次读数据中（读取数据库数据和更新缓存之间），完成了一次写数据操作，这就导致缓存中存在的是数据库的旧数据，与数据库新写入的数据不一致。</p>
<p>但在实际中，这个问题出现的概率并不高，因为缓存的写入通常要远快于数据库的写入。为了确保万无一失，还可以给缓存数据加上过期时间，就算在这期间存在缓存数据不一致，也有过期时间兜底，也能达到最终一致。</p>
<h3 id="延迟双删"><a href="#延迟双删" class="headerlink" title="延迟双删"></a>延迟双删</h3><blockquote>
<p>分布式系统中存储和缓存数据保持一致性的常用策略，但它不是强一致的</p>
</blockquote>
<p>前面讲到，先删除缓存，再更新数据库会造成数据库与缓存数据不一致问题。延迟双删能够解决这个问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_data</span>(<span class="params">key, obj</span>):</span><br><span class="line">    del_cache(key) <span class="comment"># 删除 Redis 缓存数据</span></span><br><span class="line">    update_db(obj) <span class="comment"># 更新数据库数据</span></span><br><span class="line">    logic_sleep(_time) <span class="comment"># 当前请求逻辑延时执行，保证从数据库和缓存能实现数据主从同步</span></span><br><span class="line">    del_cache(key) <span class="comment"># 删除 Redis 缓存数据</span></span><br></pre></td></tr></table></figure>

<h3 id="先更新数据库再删缓存策略中，如何保证第二个操作能执行成功"><a href="#先更新数据库再删缓存策略中，如何保证第二个操作能执行成功" class="headerlink" title="先更新数据库再删缓存策略中，如何保证第二个操作能执行成功"></a>先更新数据库再删缓存策略中，如何保证第二个操作能执行成功</h3><p>1、使用消息队列来重试缓存的删除</p>
<p>2、订阅 MySQL binlog，再操作缓存</p>
<blockquote>
<p>阿里巴巴开源的 Canal 中间件就是基于这个实现的，Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。</p>
</blockquote>
<h1 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h1><h2 id="Redis-是单线程吗"><a href="#Redis-是单线程吗" class="headerlink" title="Redis 是单线程吗"></a>Redis 是单线程吗</h2><blockquote>
<p>Redis 单线程是指<strong>接收客户端请求 $\rightarrow$ 解析请求 $\rightarrow$ 进行数据读写等操作 $\rightarrow$ 发送数据给客户端</strong>这个过程是由一个线程（主线程）来完成的</p>
</blockquote>
<p>Redis 程序不是单线程的，Redis 在启动时，是会启动后台线程（BIO）的</p>
<ul>
<li><p>在 Redis 2.6 版本，会启动 2 个后台线程，分别处理关闭文件、AOF 刷盘这两个任务</p>
</li>
<li><p>在 Redis 4.0 版本之后，新增了一个新的后台线程（<code>lazy free</code> 线程），用来异步释放 Redis 内存。</p>
<blockquote>
<p>例如执行 <code>unlink key</code>、<code>flushdb async</code>、<code>flushall async</code> 等命令，会把这些删除操作交给后台线程来执行</p>
</blockquote>
</li>
</ul>
<p>后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。关闭文件、AOF 刷盘、释放内存这三个任务都有各自的任务队列</p>
<ul>
<li><code>BIO_CLOSE_FILE</code>：关闭文件任务队列。当队列有任务后，后台线程会调用 <code>close(fd)</code>，将文件关闭</li>
<li><code>BIO_AOF_FSYNC</code>：AOF 刷盘任务队列。当 AOF 日志配置成 <code>everysec</code> 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 <code>fsync(fd)</code>，将 AOF 文件刷盘</li>
<li><code>BIO_LAZY_FREE</code>：<code>lazy free</code> 任务队列。当队列有任务后，后台线程会 <code>free(obj)</code> 释放对象、<code>free(dict)</code> 删除数据库所有对象、<code>free(skiplist)</code> 释放跳表对象</li>
</ul>
<h2 id="Redis-单线程模式是怎样的"><a href="#Redis-单线程模式是怎样的" class="headerlink" title="Redis 单线程模式是怎样的"></a>Redis 单线程模式是怎样的</h2><p>在 Redis 初始化时，会做下面几件事</p>
<ul>
<li>调用 <code>epoll_create()</code> 创建一个 epoll 对象和调用 <code>socket()</code> 创建一个服务端 socket</li>
<li>调用 <code>bind()</code> 绑定端口和调用 <code>listen()</code> 监听该 socket</li>
<li>调用 <code>epoll_ctl()</code> 将监听的 socket 加入到 epoll，同时注册<strong>连接事件</strong>处理函数</li>
</ul>
<p>初始化完后，主线程就进入到一个<strong>事件循环函数</strong>，主要会做以下事情</p>
<ul>
<li>首先，先调用<strong>处理发送队列函数</strong>，检查发送队列里是否存在任务，如果存在，则通过 <code>write</code> 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 <code>epoll_wait</code> 发现可写后再处理 </li>
<li>接着，调用 <code>epoll_wait</code> 函数等待事件的到来<ul>
<li>连接事件：调用连接事件处理函数。调用 <code>accpet</code> 获取已连接的 socket $\rightarrow$ 调用 <code>epoll_ctl</code> 将已连接的 socket 加入到 epoll $\rightarrow$ 注册<strong>读事件</strong>处理函数</li>
<li>读事件：调用读事件处理函数。调用 <code>read</code> 获取客户端发送的数据 $\rightarrow$ 解析命令 $\rightarrow$ 处理命令 $\rightarrow$ 将客户端对象添加到发送队列 $\rightarrow$ 将执行结果写到发送缓存区等待发送</li>
<li>写事件：调用<strong>写事件处理</strong>函数。通过 <code>write</code> 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会继续注册写事件处理函数，等待 <code>epoll_wait</code> 发现可写后再处理</li>
</ul>
</li>
</ul>
<h2 id="Redis-采用单线程为什么还这么快"><a href="#Redis-采用单线程为什么还这么快" class="headerlink" title="Redis 采用单线程为什么还这么快"></a>Redis 采用单线程为什么还这么快</h2><p>在 Redis 中，网络 I&#x2F;O 和命令处理都是单线程的，之所以那么快的原因</p>
<ul>
<li>Redis 的大部分操作<strong>都在内存中完成</strong>，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，因此可以采用单线程的解决方案</li>
<li>可以<strong>避免多线程之间的竞争</strong>。多线程切换会带来时间和性能上的额外开销，存在死锁问题</li>
<li>采用 <strong>I&#x2F;O 多路复用机制</strong>处理大量的客户端 Socket 请求</li>
</ul>
<h2 id="在-Redis-6-0-之后为什么引入多线程"><a href="#在-Redis-6-0-之后为什么引入多线程" class="headerlink" title="在 Redis 6.0 之后为什么引入多线程"></a>在 Redis 6.0 之后为什么引入多线程</h2><p>单线程的程序是无法利用服务器的多核 CPU 的。在 Redis 6.0 之前，CPU 并不是制约 Redis 性能表现的瓶颈所在，更多情况下是受到内存大小和网络 I&#x2F;O 的限制，所以 Redis 核心网络模型使用单线程并没有什么问题。</p>
<p>使用单线程的可维护性高，多线程模型虽然在某些方面表现优异，但它却引入了<strong>程序执行顺序的不确定性</strong>，带来了并发读写的一系列问题，<strong>增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗</strong>。</p>
<blockquote>
<p>如果要使用多核 CPU，可以在一台服务器上启动多个节点或者采用分片集群的方式</p>
</blockquote>
<p>而随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I&#x2F;O 的处理上，因此在 Redis 6.0 版本之后，也采用了多个 I&#x2F;O 线程来处理网络请求。默认情况下 I&#x2F;O 多线程只针对发送响应数据，并不会以多线程的方式处理读请求。</p>
<blockquote>
<p>但是对于命令的执行，Redis 仍然使用单线程来处理</p>
</blockquote>
<h1 id="常用命令-7"><a href="#常用命令-7" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">expire key n <span class="comment"># 设置 key 在 n 秒后过期</span></span><br><span class="line">pexpire key n <span class="comment"># 设置 key 在 n 毫秒后过期</span></span><br><span class="line">expireat key n <span class="comment"># 设置 key 在某个时间戳（精确到秒）之后过期</span></span><br><span class="line">pexpireat key n <span class="comment"># 设置 key 在某个时间戳（精确到毫秒）之后过期</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置字符串时同时对 key 设置过期时间</span></span><br><span class="line"><span class="built_in">set</span> key value ex n</span><br><span class="line"><span class="built_in">set</span> key value px n</span><br><span class="line">setex key n value</span><br></pre></td></tr></table></figure>



<h2 id="查看-Key-剩余的存活时间"><a href="#查看-Key-剩余的存活时间" class="headerlink" title="查看 Key 剩余的存活时间"></a>查看 Key 剩余的存活时间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key <span class="comment"># 当 key 不存在时，返回 -2；当 key 存在但没有设置剩余生存时间时，返回 -1；否则，以秒为单位返回 key 的剩余生存时间</span></span><br></pre></td></tr></table></figure>



<h2 id="取消-Key-的过期时间"><a href="#取消-Key-的过期时间" class="headerlink" title="取消 Key 的过期时间"></a>取消 Key 的过期时间</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persist key <span class="comment"># 当过期时间移除成功时，返回 1；如果 key 不存在或 key 没有设置过期时间，返回 0</span></span><br></pre></td></tr></table></figure>



<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="介绍一下-Redis"><a href="#介绍一下-Redis" class="headerlink" title="介绍一下 Redis"></a>介绍一下 Redis</h2><p>一种<strong>基于内存</strong>实现的 <strong>Key-Value</strong> 数据结构的 <strong>NoSQL</strong> 数据库，常用于<strong>缓存，消息队列、分布式锁</strong>等场景</p>
<ul>
<li><p>基于内存：结合使用<strong>单线程架构</strong>以及 <strong>I&#x2F;O 多路复用模型</strong>，提供了高性能的内存数据库服务，提供了持久化策略，防止内存数据丢失的问题</p>
</li>
<li><p>NoSQL：非关系性数据库，相比关系性数据库，在扩展性、性能、大数据量存储方面更优</p>
</li>
</ul>
<p>提供了多种数据类型来支持不同的业务场景，比如 String、Hash、List、Set、Zset（有序集合）、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是原子性的（执行命令由单线程负责的，不存在并发竞争的问题）</p>
<p>Redis 还支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群（Redis Cluster）模式）、发布&#x2F;订阅模式，内存淘汰机制、过期删除机制</strong>等</p>
<h2 id="Redis-与-Memcached-的区别"><a href="#Redis-与-Memcached-的区别" class="headerlink" title="Redis 与 Memcached 的区别"></a>Redis 与 Memcached 的区别</h2><p>相同</p>
<ul>
<li>都是基于内存的数据库，一般都是当做缓存使用</li>
<li>都有过期策略</li>
<li>性能都很高</li>
</ul>
<p>不同</p>
<ul>
<li>Redis 支持丰富的数据结构，而 Memcached 只支持最简单的 Key-Value 数据类型</li>
<li>Redis 支持数据持久化，Memcached 不支持，Memcached 重启或者挂掉会导致数据丢失</li>
<li>Redis 原生支持集群模式，Memcached 没有，需要依赖客户端实现</li>
<li>Redis 支持发布订阅模型、Lua 脚本、事务等功能，Memcached 不支持</li>
</ul>
<h2 id="为什么使用-Redis-作为-MySQL-的缓存"><a href="#为什么使用-Redis-作为-MySQL-的缓存" class="headerlink" title="为什么使用 Redis 作为 MySQL 的缓存"></a>为什么使用 Redis 作为 MySQL 的缓存</h2><p>主要是因为 Redis 的<strong>高性能</strong>和<strong>高并发</strong>特性</p>
<ul>
<li><p>高性能：MySQL 需要从硬盘上读取数据，而 Redis 是基于内存的，速度会快很多</p>
</li>
<li><p>高并发：单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w</p>
</li>
</ul>
<h2 id="大-Key-对-Redis-的影响，如何避免？"><a href="#大-Key-对-Redis-的影响，如何避免？" class="headerlink" title="大 Key 对 Redis 的影响，如何避免？"></a>大 Key 对 Redis 的影响，如何避免？</h2><p>影响</p>
<p>1、客户端超时阻塞。由于 Redis 执行命令是单线程处理，在操作大 Key 时会比较耗时，就会阻塞 Redis，从客户端的视角就是响应时间过长</p>
<p>2、引发网络阻塞。如果每次获取大 Key 产生的网络流量较大，则随着访问量的增加，服务器的网络压力也会增加</p>
<p>3、阻塞工作线程。如果使用 <code>del</code> 删除大 Key（同步删除），则会阻塞工作线程</p>
<p>4、内存分布不均。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 Key 的 Redis 节点占用内存多，QPS 也会比较大</p>
<p>5、在 AOF 持久化中，如果写回策略为 <code>Always</code>，则主线程在执行 <code>fsync()</code> 函数时，阻塞的时间会比较久</p>
<p>6、在 AOF 重写机制和使用 <code>bgsave</code> 进行 RDB 持久化时，会阻塞主线程</p>
<ul>
<li>在创建子进程时需要复制父进程的页表等数据结构，大 Key 会导致这个过程耗时较长</li>
<li>父进程在修改共享数据中的大 Key 时，会发生写时复制，大 Key 占用的内存很大，因此复制过程也会更耗时</li>
</ul>
<p>解决方法</p>
<p>1、在设计阶段将大 Key 拆分成多个小 Key，并定时检查 Redis 是否存在大 Key</p>
<p>2、使用 <code>unlink</code> 命令（Redis 4.0+）删除大 Key，因为该命令的删除过程是异步的，不会阻塞主线程，而 <code>del</code> 是同步的</p>
<h2 id="Redis-管道有什么用"><a href="#Redis-管道有什么用" class="headerlink" title="Redis 管道有什么用"></a>Redis 管道有什么用</h2><p>管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<p>使用管道技术可以解决多个命令执行时的网络等待，它是把多个命令整合到一起发送给服务器端处理之后统一返回给客户端，这样就免去了每条命令执行后都要等待的情况，从而有效地提高了程序的执行效率。</p>
<p>但使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞。</p>
<p>要注意的是，管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能。</p>
<h2 id="Redis-的事务"><a href="#Redis-的事务" class="headerlink" title="Redis 的事务"></a>Redis 的事务</h2><p>Redis 最简单的事务实现方式是使用 <code>MULTI</code> 和 <code>EXEC</code> 命令将事务操作包围起来，事务中的多个命令被一次性发送给服务器</p>
<p><img src="/images/Redis/Redis%E4%BA%8B%E5%8A%A1.png" alt="Redis事务"></p>
<h2 id="Redis-事务支持回滚吗"><a href="#Redis-事务支持回滚吗" class="headerlink" title="Redis 事务支持回滚吗"></a>Redis 事务支持回滚吗</h2><p>Redis 中并没有提供回滚机制，虽然 Redis 提供了 DISCARD 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</p>
<h2 id="订阅发布（Pub-Sub）"><a href="#订阅发布（Pub-Sub）" class="headerlink" title="订阅发布（Pub&#x2F;Sub）"></a>订阅发布（Pub&#x2F;Sub）</h2><p>Redis Server 里维护了一个字典，Key 是 Channel 的名称，Value 是一个链表，保存所有订阅这个 Channel 的客户端</p>
<p>使用 <code>subscribe</code> 命令的时候，会将客户端添加到指定的链表中</p>
<p>使用 <code>publish</code> 命令的时候，会根据 Channel 名称找到链表，并将信息发布给所有订阅者</p>
<h2 id="Redis-存在线程安全问题吗"><a href="#Redis-存在线程安全问题吗" class="headerlink" title="Redis 存在线程安全问题吗"></a>Redis 存在线程安全问题吗</h2><p>从 Redis Server 层面，是不存在线程安全问题的</p>
<ul>
<li>Redis Server 本身是一个线程安全的 Key-Value 数据库，在 Redis Server 端执行指令时不需要任何的同步机制，不会存在线程安全问题</li>
<li>虽然 Redis 6.0 里增加了多线程模型，但这个多线程模型是用于处理网络 IO 事件，指令的执行过程仍采用主线程来处理，不会存在多个线程同时执行指令的情况</li>
</ul>
<p>从 Redis Client 层面，可能会在线程安全问题</p>
<ul>
<li>虽然 Redis Server 中的指令执行是原子的，但是如果存在多个 Redis Client 同时执行多个指令时，就无法保证原子性</li>
<li>解决措施<ul>
<li>尽可能使用 Redis 里的原子指令，如用 <code>incr/decr</code> 替换 <code>get+set</code></li>
<li>对多个客户端的资源访问进行加锁</li>
<li>通过 Lua 脚本实现多个指令的操作（将整个脚本作为一个整体执行，中间不会被其他线程的命令插入）</li>
</ul>
</li>
</ul>
<h2 id="如何用-Redis-实现分布式锁"><a href="#如何用-Redis-实现分布式锁" class="headerlink" title="如何用 Redis 实现分布式锁"></a>如何用 Redis 实现分布式锁</h2><p>分布式锁是用于分布式环境下并发控制的一种机制，用于控制某个资源在同一时刻只能被一个应用所使用。</p>
<p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁，而且 Redis 的读写性能高，可以应对高并发的锁操作场景。</p>
<p>Redis 的 <code>SET</code> 命令有个 <code>NX</code> 参数可以实现 <strong>key 不存在才插入</strong>，所以可以用它来实现分布式锁</p>
<ul>
<li>如果 key 不存在，则显示插入成功，用来表示加锁成功；</li>
<li>如果 key 存在，则会显示插入失败，用来表示加锁失败。</li>
</ul>
<p>基于 Redis 节点实现分布式锁时，对于加锁操作，需要满足三个条件</p>
<ul>
<li>加锁包括了<strong>读取锁变量、检查锁变量值和设置锁变量值</strong>三个操作，但需要以<strong>原子操作</strong>的方式完成，因此使用 <code>SET</code> 命令带上 <code>NX</code> 选项来实现加锁</li>
<li>锁变量需要<strong>设置过期时间</strong>，保证锁最终能够被释放，因此在 <code>SET</code> 命令执行时加上 <code>EX/PX</code> 选项</li>
<li>锁变量的值需要能<strong>区分来自不同客户端的加锁操作</strong>，保证锁的正确释放，因此使用 <code>SET</code> 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 1000</span><br></pre></td></tr></table></figure>

<p>解锁时需要两个操作：判断执行操作的客户端就是加锁的客户端、释放锁。为了保证解锁操作的原子性，可以使用  Lua 脚本完成</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&quot;get&quot;</span>, lock_key) == unique_value) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, lock_key)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>



<h3 id="基于-Redis-实现分布式锁的优缺点"><a href="#基于-Redis-实现分布式锁的优缺点" class="headerlink" title="基于 Redis 实现分布式锁的优缺点"></a>基于 Redis 实现分布式锁的优缺点</h3><p>优点</p>
<ul>
<li>性能高效且实现方便</li>
<li>避免单点故障。因为 Redis 是跨集群部署的，自然就避免了单点故障</li>
</ul>
<p>缺点</p>
<ul>
<li>超时时间不好设置。过长会影响性能，过短会保护不到共享资源（比如一个长业务还没有执行完，锁就释放并被另外一个业务获取了。可以基于续约的方式设置超时时间，先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间）</li>
<li>Redis 主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性。如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁</li>
</ul>
<h3 id="Redis-如何解决集群情况下分布式锁的可靠性？"><a href="#Redis-如何解决集群情况下分布式锁的可靠性？" class="headerlink" title="Redis 如何解决集群情况下分布式锁的可靠性？"></a>Redis 如何解决集群情况下分布式锁的可靠性？</h3><p>使用官方设计的分布式锁算法 Redlock（红锁）。它是基于多个 Redis 节点的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是孤立的节点。</p>
<blockquote>
<p>Redlock 算法的基本思路</p>
</blockquote>
<p>让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，则认为客户端成功地获得分布式锁，否则加锁失败。</p>
<blockquote>
<p> Redlock 算法加锁过程</p>
</blockquote>
<p>1、客户端获取当前时间 <code>t1</code></p>
<p>2、客户端按顺序依次向 N 个 Redis 节点执行加锁操作</p>
<p>3、一旦客户端从超过半数（$\geq \frac{N}{2} + 1$​）的 Redis 节点上成功获取到了锁，就再次获取当前时间 <code>t2</code>，然后计算计算整个加锁过程的总耗时 <code>t2-t1</code>。如果 <code>t2-t1</code> 小于锁的过期时间，则认为客户端加锁成功，否则加锁失败。</p>
<p>加锁成功后，客户端需要重新计算这把锁的有效时间（锁最初设置的过期时间 - 客户端从大多数节点获取锁的总耗时）。如果计算的结果已经来不及完成共享数据的操作了，可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p>
<p>加锁失败后，客户端向所有 Redis 节点发起释放锁的操作，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1、<a target="_blank" rel="noopener" href="https://xiaolincoding.com/Redis/">小林 coding - 图解 Redis</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/01/22/%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/" rel="prev" title="创建自己的博客">
      <i class="fa fa-chevron-left"></i> 创建自己的博客
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/02/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="next" title="操作系统">
      操作系统 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%94%AE%E5%80%BC%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">Redis 是如何实现键值对数据库的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDS"><span class="nav-number">1.2.</span> <span class="nav-text">SDS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS-%E4%B8%8E-C-%E7%9A%84%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.1.</span> <span class="nav-text">SDS 与 C 的原生字符串的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88Redis-5-0%EF%BC%89"><span class="nav-number">1.2.2.</span> <span class="nav-text">SDS 数据结构（Redis 5.0）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS-%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99"><span class="nav-number">1.2.3.</span> <span class="nav-text">SDS 扩容规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.3.1.</span> <span class="nav-text">链表节点结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.3.2.</span> <span class="nav-text">链表结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.3.3.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.4.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-number">1.4.</span> <span class="nav-text">压缩列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.4.1.</span> <span class="nav-text">压缩列表结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%8A%82%E7%9C%81%E5%86%85%E5%AD%98"><span class="nav-number">1.4.2.</span> <span class="nav-text">压缩列表为什么节省内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%A0%E6%88%90%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.4.3.</span> <span class="nav-text">造成连锁更新的原因</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.5.1.</span> <span class="nav-text">哈希表结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.5.2.</span> <span class="nav-text">哈希表节点结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rehash"><span class="nav-number">1.5.3.</span> <span class="nav-text">rehash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F-Rehash"><span class="nav-number">1.5.4.</span> <span class="nav-text">渐进式 Rehash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91-rehash-%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.5.5.</span> <span class="nav-text">触发 rehash 的条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="nav-number">1.6.</span> <span class="nav-text">整数集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.6.1.</span> <span class="nav-text">整数集合结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%8D%87%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="nav-number">1.6.2.</span> <span class="nav-text">整数集合的升级操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">1.7.</span> <span class="nav-text">跳表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.7.1.</span> <span class="nav-text">跳表节点结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.7.2.</span> <span class="nav-text">跳表结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E8%8A%82%E7%82%B9%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.3.</span> <span class="nav-text">跳表节点查询过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E8%8A%82%E7%82%B9%E5%B1%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.7.4.</span> <span class="nav-text">跳表节点层数设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#quicklist"><span class="nav-number">1.8.</span> <span class="nav-text">quicklist</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#quicklist-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.8.1.</span> <span class="nav-text">quicklist 结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#quicklistNode-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.8.2.</span> <span class="nav-text">quicklistNode 结构设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#listpack"><span class="nav-number">1.9.</span> <span class="nav-text">listpack</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="nav-number">2.1.</span> <span class="nav-text">字符串 String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">2.1.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.1.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C-Hash"><span class="nav-number">2.2.</span> <span class="nav-text">哈希 Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E8%A1%A8-List"><span class="nav-number">2.3.</span> <span class="nav-text">列表 List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="nav-number">2.3.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="nav-number">2.3.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88-Set"><span class="nav-number">2.4.</span> <span class="nav-text">集合 Set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="nav-number">2.4.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="nav-number">2.4.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-Zset"><span class="nav-number">2.5.</span> <span class="nav-text">有序集合 Zset</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ZSet-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88%E5%A6%82-AVL-%E6%95%B0%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91%E7%AD%89%EF%BC%89"><span class="nav-number">2.5.1.</span> <span class="nav-text">ZSet 为什么不使用平衡树（如 AVL 数、红黑树等）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="nav-number">2.5.2.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="nav-number">2.5.3.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E5%9B%BE-Bitmap"><span class="nav-number">2.6.</span> <span class="nav-text">位图 Bitmap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-5"><span class="nav-number">2.6.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="nav-number">2.6.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">2.7.</span> <span class="nav-text">HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="nav-number">2.7.1.</span> <span class="nav-text">常见命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="nav-number">2.7.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEO"><span class="nav-number">2.8.</span> <span class="nav-text">GEO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-1"><span class="nav-number">2.8.1.</span> <span class="nav-text">常见命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-7"><span class="nav-number">2.8.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream"><span class="nav-number">2.9.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-6"><span class="nav-number">2.9.1.</span> <span class="nav-text">常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-8"><span class="nav-number">2.9.2.</span> <span class="nav-text">应用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF%EF%BC%88Append-Only-File%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">AOF（Append Only File）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-%E6%97%A5%E5%BF%97%E5%86%85%E5%AE%B9"><span class="nav-number">3.1.1.</span> <span class="nav-text">AOF 日志内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%89%A7%E8%A1%8C%E5%86%99%E6%93%8D%E4%BD%9C%E5%86%8D%E8%AE%B0%E5%BD%95%E5%88%B0-AOF-%E6%97%A5%E5%BF%97%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.1.2.</span> <span class="nav-text">先执行写操作再记录到 AOF 日志的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="nav-number">3.1.3.</span> <span class="nav-text">AOF 日志写入流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%8F%90%E4%BE%9B%E7%9A%84%E7%A1%AC%E7%9B%98%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="nav-number">3.1.4.</span> <span class="nav-text">Redis 提供的硬盘写回策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.5.</span> <span class="nav-text">AOF 重写机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-%E5%90%8E%E5%8F%B0%E9%87%8D%E5%86%99"><span class="nav-number">3.1.6.</span> <span class="nav-text">AOF 后台重写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB"><span class="nav-number">3.2.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text">RDB 持久化的触发方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-bgsave-%E6%97%B6%E8%83%BD%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%90%97"><span class="nav-number">3.2.2.</span> <span class="nav-text">执行 bgsave 时能修改数据吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.2.3.</span> <span class="nav-text">RDB 持久化的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-%E5%92%8C-AOF-%E7%9A%84%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">RDB 和 AOF 的混合持久化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.3.1.</span> <span class="nav-text">混合持久化机制的优缺点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="nav-number">4.</span> <span class="nav-text">内存回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A-Key-%E5%B7%B2%E7%BB%8F%E8%BF%87%E6%9C%9F%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">Redis 如何判定 Key 已经过期？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-number">4.2.</span> <span class="nav-text">内存过期策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%97%B6%EF%BC%8C%E5%AF%B9%E8%BF%87%E6%9C%9F%E9%94%AE%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">Redis 持久化时，对过期键会如何处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F%E4%B8%AD%EF%BC%8C%E5%AF%B9%E8%BF%87%E6%9C%9F%E9%94%AE%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-number">4.4.</span> <span class="nav-text">Redis 主从模式中，对过期键会如何处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">4.5.</span> <span class="nav-text">内存淘汰策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%96%B0%E5%A2%9E-LFU-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-number">4.6.</span> <span class="nav-text">为什么需要新增 LFU 内存淘汰算法？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">5.1.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5%E7%9A%84"><span class="nav-number">5.1.1.</span> <span class="nav-text">主从服务器如何建立第一次同步的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD%EF%BC%9F"><span class="nav-number">5.1.2.</span> <span class="nav-text">什么是命令传播？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%9A%E4%B8%AA%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%8E%8B%E5%8A%9B"><span class="nav-number">5.1.3.</span> <span class="nav-text">如果有多个从服务器，如何减少主服务器的压力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="nav-number">5.1.4.</span> <span class="nav-text">增量复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E9%9C%80%E8%A6%81%E5%8F%91%E9%80%81%E5%93%AA%E4%BA%9B%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E7%BB%99%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%9F"><span class="nav-number">5.1.5.</span> <span class="nav-text">主服务器怎么知道需要发送哪些增量数据给从服务器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9E%B6%E6%9E%84%E4%B8%AD%EF%BC%8C%E8%BF%87%E6%9C%9F-Key-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">5.1.6.</span> <span class="nav-text">在主从复制架构中，过期 Key 如何处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%AD-replication-buffer-%E5%92%8C-repl-backlog-buffer-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.1.7.</span> <span class="nav-text">主从复制中 replication buffer 和 repl_backlog_buffer 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E6%97%B6%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1"><span class="nav-number">5.1.8.</span> <span class="nav-text">主从切换时如何减少数据丢失</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">哨兵模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E6%88%90%E7%9A%84%EF%BC%9F"><span class="nav-number">5.2.1.</span> <span class="nav-text">哨兵集群是如何组成的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-Cluster"><span class="nav-number">5.3.</span> <span class="nav-text">Redis Cluster</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E5%92%8C-Redis-Cluster-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.1.</span> <span class="nav-text">哨兵集群和 Redis Cluster 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-Cluster-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%A7%BD%E6%95%B0%E6%98%AF-16384"><span class="nav-number">5.3.2.</span> <span class="nav-text">为什么 Redis Cluster 的最大槽数是 16384</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">6.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">6.1.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">6.2.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">6.3.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">6.4.</span> <span class="nav-text">布隆过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">6.5.</span> <span class="nav-text">数据库与缓存如何保证数据一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Aside-%E7%AD%96%E7%95%A5%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%EF%BC%89"><span class="nav-number">6.5.1.</span> <span class="nav-text">Cache Aside 策略（旁路缓存策略）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0"><span class="nav-number">6.5.2.</span> <span class="nav-text">延迟双删</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%8D%E5%88%A0%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%93%8D%E4%BD%9C%E8%83%BD%E6%89%A7%E8%A1%8C%E6%88%90%E5%8A%9F"><span class="nav-number">6.5.3.</span> <span class="nav-text">先更新数据库再删缓存策略中，如何保证第二个操作能执行成功</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.</span> <span class="nav-text">Redis 线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%97"><span class="nav-number">7.1.</span> <span class="nav-text">Redis 是单线程吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">7.2.</span> <span class="nav-text">Redis 单线程模式是怎样的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E9%87%87%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="nav-number">7.3.</span> <span class="nav-text">Redis 采用单线程为什么还这么快</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-Redis-6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.4.</span> <span class="nav-text">在 Redis 6.0 之后为什么引入多线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-7"><span class="nav-number">8.</span> <span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">8.1.</span> <span class="nav-text">设置过期时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-Key-%E5%89%A9%E4%BD%99%E7%9A%84%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4"><span class="nav-number">8.2.</span> <span class="nav-text">查看 Key 剩余的存活时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%96%E6%B6%88-Key-%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">8.3.</span> <span class="nav-text">取消 Key 的过期时间</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E5%AE%83"><span class="nav-number">9.</span> <span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-Redis"><span class="nav-number">9.1.</span> <span class="nav-text">介绍一下 Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E4%B8%8E-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.2.</span> <span class="nav-text">Redis 与 Memcached 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-Redis-%E4%BD%9C%E4%B8%BA-MySQL-%E7%9A%84%E7%BC%93%E5%AD%98"><span class="nav-number">9.3.</span> <span class="nav-text">为什么使用 Redis 作为 MySQL 的缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7-Key-%E5%AF%B9-Redis-%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-number">9.4.</span> <span class="nav-text">大 Key 对 Redis 的影响，如何避免？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%AE%A1%E9%81%93%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">9.5.</span> <span class="nav-text">Redis 管道有什么用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="nav-number">9.6.</span> <span class="nav-text">Redis 的事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E5%9B%9E%E6%BB%9A%E5%90%97"><span class="nav-number">9.7.</span> <span class="nav-text">Redis 事务支持回滚吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83%EF%BC%88Pub-Sub%EF%BC%89"><span class="nav-number">9.8.</span> <span class="nav-text">订阅发布（Pub&#x2F;Sub）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%90%97"><span class="nav-number">9.9.</span> <span class="nav-text">Redis 存在线程安全问题吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8-Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">9.10.</span> <span class="nav-text">如何用 Redis 实现分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">9.10.1.</span> <span class="nav-text">基于 Redis 实现分布式锁的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%9B%86%E7%BE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="nav-number">9.10.2.</span> <span class="nav-text">Redis 如何解决集群情况下分布式锁的可靠性？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">10.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bling"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Bling</p>
  <div class="site-description" itemprop="description">绳锯木断，水滴石穿</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-01 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bling</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
